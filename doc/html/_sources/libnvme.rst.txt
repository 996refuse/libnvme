.. _filters.h:

**filters.h**


libnvme directory filter

.. c:function:: int nvme_namespace_filter (const struct dirent *d)


**Parameters**

``const struct dirent *d``


.. c:function:: int nvme_paths_filter (const struct dirent *d)


**Parameters**

``const struct dirent *d``


.. c:function:: int nvme_ctrls_filter (const struct dirent *d)


**Parameters**

``const struct dirent *d``


.. c:function:: int nvme_subsys_filter (const struct dirent *d)


**Parameters**

``const struct dirent *d``


.. c:function:: int nvme_scan_subsystems (struct dirent ***subsys)


**Parameters**

``struct dirent ***subsys``


.. c:function:: int nvme_scan_subsystem_namespaces (nvme_subsystem_t s, struct dirent ***namespaces)


**Parameters**

``nvme_subsystem_t s``

``struct dirent ***namespaces``


.. c:function:: int nvme_scan_ctrls (struct dirent ***ctrls)


**Parameters**

``struct dirent ***ctrls``


.. c:function:: int nvme_scan_ctrl_namespace_paths (nvme_ctrl_t c, struct dirent ***namespaces)


**Parameters**

``nvme_ctrl_t c``

``struct dirent ***namespaces``


.. c:function:: int nvme_scan_ctrl_namespaces (nvme_ctrl_t c, struct dirent ***namespaces)


**Parameters**

``nvme_ctrl_t c``

``struct dirent ***namespaces``


.. _ioctl.h:

**ioctl.h**


Linux NVMe ioctl interface functions



.. c:struct:: nvme_passthru_cmd


**Definition**

::

  struct nvme_passthru_cmd {
    __u8 opcode;
    __u8 flags;
    __u16 rsvd1;
    __u32 nsid;
    __u32 cdw2;
    __u32 cdw3;
    __u64 metadata;
    __u64 addr;
    __u32 metadata_len;
    __u32 data_len;
    __u32 cdw10;
    __u32 cdw11;
    __u32 cdw12;
    __u32 cdw13;
    __u32 cdw14;
    __u32 cdw15;
    __u32 timeout_ms;
    __u32 result;
  };

**Members**

``opcode``
  Operation code, see :c:type:`enum nvme_io_opcodes <nvme_io_opcodes>` and :c:type:`enum nvme_admin_opcodes <nvme_admin_opcodes>`

``flags``
  Not supported: intended for command flags (eg: SGL, FUSE)

``rsvd1``
  Reserved for future use

``nsid``
  Namespace Identifier, or Fabrics type

``cdw2``
  Command Dword 2 (no spec defined use)

``cdw3``
  Command Dword 3 (no spec defined use)

``metadata``
  User space address to metadata buffer (NULL if not used)

``addr``
  User space address to data buffer (NULL if not used)

``metadata_len``
  Metadata buffer transfer length

``data_len``
  Data buffer transfer length

``cdw10``
  Command Dword 10 (command specific)

``cdw11``
  Command Dword 11 (command specific)

``cdw12``
  Command Dword 12 (command specific)

``cdw13``
  Command Dword 13 (command specific)

``cdw14``
  Command Dword 14 (command specific)

``cdw15``
  Command Dword 15 (command specific)

``timeout_ms``
  If non-zero, overrides system default timeout in milliseconds

``result``
  Set on completion to the command's CQE DWORD 0 controller response





.. c:struct:: nvme_passthru_cmd64


**Definition**

::

  struct nvme_passthru_cmd64 {
    __u8 opcode;
    __u8 flags;
    __u16 rsvd1;
    __u32 nsid;
    __u32 cdw2;
    __u32 cdw3;
    __u64 metadata;
    __u64 addr;
    __u32 metadata_len;
    __u32 data_len;
    __u32 cdw10;
    __u32 cdw11;
    __u32 cdw12;
    __u32 cdw13;
    __u32 cdw14;
    __u32 cdw15;
    __u32 timeout_ms;
    __u32 rsvd2;
    __u64 result;
  };

**Members**

``opcode``
  Operation code, see :c:type:`enum nvme_io_opcodes <nvme_io_opcodes>` and :c:type:`enum nvme_admin_opcodes <nvme_admin_opcodes>`

``flags``
  Not supported: intended for command flags (eg: SGL, FUSE)

``rsvd1``
  Reserved for future use

``nsid``
  Namespace Identifier, or Fabrics type

``cdw2``
  Command Dword 2 (no spec defined use)

``cdw3``
  Command Dword 3 (no spec defined use)

``metadata``
  User space address to metadata buffer (NULL if not used)

``addr``
  User space address to data buffer (NULL if not used)

``metadata_len``
  Metadata buffer transfer length

``data_len``
  Data buffer transfer length

``cdw10``
  Command Dword 10 (command specific)

``cdw11``
  Command Dword 11 (command specific)

``cdw12``
  Command Dword 12 (command specific)

``cdw13``
  Command Dword 13 (command specific)

``cdw14``
  Command Dword 14 (command specific)

``cdw15``
  Command Dword 15 (command specific)

``timeout_ms``
  If non-zero, overrides system default timeout in milliseconds

``rsvd2``
  Reserved for future use (and fills an impicit struct pad

``result``
  Set on completion to the command's CQE DWORD 0-1 controller response



.. c:function:: int nvme_submit_admin_passthru64 (int fd, struct nvme_passthru_cmd64 *cmd, __u64 *result)

   Submit a 64-bit nvme passthrough admin command

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_passthru_cmd64 *cmd``
  The nvme admin command to send

``__u64 *result``
  Optional field to return the result from the CQE DW0-1

**Description**

Uses NVME_IOCTL_ADMIN64_CMD for the ioctl request.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_admin_passthru64 (int fd, __u8 opcode, __u8 flags, __u16 rsvd, __u32 nsid, __u32 cdw2, __u32 cdw3, __u32 cdw10, __u32 cdw11, __u32 cdw12, __u32 cdw13, __u32 cdw14, __u32 cdw15, __u32 data_len, void *data, __u32 metadata_len, void *metadata, __u32 timeout_ms, __u64 *result)

   Submit an nvme passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 opcode``
  The nvme io command to send

``__u8 flags``
  NVMe command flags (not used)

``__u16 rsvd``
  Reserevd for future use

``__u32 nsid``
  Namespace identifier

``__u32 cdw2``
  Command dword 2

``__u32 cdw3``
  Command dword 3

``__u32 cdw10``
  Command dword 10

``__u32 cdw11``
  Command dword 11

``__u32 cdw12``
  Command dword 12

``__u32 cdw13``
  Command dword 13

``__u32 cdw14``
  Command dword 14

``__u32 cdw15``
  Command dword 15

``__u32 data_len``
  Length of the data transfered in this command in bytes

``void *data``
  Pointer to user address of the data buffer

``__u32 metadata_len``
  Length of metadata transfered in this command

``void *metadata``
  Pointer to user address of the metadata buffer

``__u32 timeout_ms``
  How long the kernel waits for the command to complete

``__u64 *result``
  Optional field to return the result from the CQE dword 0

**Description**

Parameterized form of nvme_submit_admin_passthru64(). This sets up and
submits a :c:type:`struct nvme_passthru_cmd64 <nvme_passthru_cmd64>`.

Known values for **opcode** are defined in :c:type:`enum nvme_admin_opcode <nvme_admin_opcode>`.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_submit_admin_passthru (int fd, struct nvme_passthru_cmd *cmd, __u32 *result)

   Submit an nvme passthrough admin command

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_passthru_cmd *cmd``
  The nvme admin command to send

``__u32 *result``
  Optional field to return the result from the CQE DW0

**Description**

Uses NVME_IOCTL_ADMIN_CMD for the ioctl request.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_admin_passthru (int fd, __u8 opcode, __u8 flags, __u16 rsvd, __u32 nsid, __u32 cdw2, __u32 cdw3, __u32 cdw10, __u32 cdw11, __u32 cdw12, __u32 cdw13, __u32 cdw14, __u32 cdw15, __u32 data_len, void *data, __u32 metadata_len, void *metadata, __u32 timeout_ms, __u32 *result)

   Submit an nvme passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 opcode``
  The nvme io command to send

``__u8 flags``
  NVMe command flags (not used)

``__u16 rsvd``
  Reserevd for future use

``__u32 nsid``
  Namespace identifier

``__u32 cdw2``
  Command dword 2

``__u32 cdw3``
  Command dword 3

``__u32 cdw10``
  Command dword 10

``__u32 cdw11``
  Command dword 11

``__u32 cdw12``
  Command dword 12

``__u32 cdw13``
  Command dword 13

``__u32 cdw14``
  Command dword 14

``__u32 cdw15``
  Command dword 15

``__u32 data_len``
  Length of the data transfered in this command in bytes

``void *data``
  Pointer to user address of the data buffer

``__u32 metadata_len``
  Length of metadata transfered in this command

``void *metadata``
  Pointer to user address of the metadata buffer

``__u32 timeout_ms``
  How long the kernel waits for the command to complete

``__u32 *result``
  Optional field to return the result from the CQE dword 0

**Description**

Parameterized form of nvme_submit_admin_passthru(). This sets up and
submits a :c:type:`struct nvme_passthru_cmd <nvme_passthru_cmd>`.

Known values for **opcode** are defined in :c:type:`enum nvme_admin_opcode <nvme_admin_opcode>`.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_submit_io_passthru64 (int fd, struct nvme_passthru_cmd64 *cmd, __u64 *result)

   Submit a 64-bit nvme passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_passthru_cmd64 *cmd``
  The nvme io command to send

``__u64 *result``
  Optional field to return the result from the CQE DW0-1

**Description**

Uses NVME_IOCTL_IO64_CMD for the ioctl request.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_io_passthru64 (int fd, __u8 opcode, __u8 flags, __u16 rsvd, __u32 nsid, __u32 cdw2, __u32 cdw3, __u32 cdw10, __u32 cdw11, __u32 cdw12, __u32 cdw13, __u32 cdw14, __u32 cdw15, __u32 data_len, void *data, __u32 metadata_len, void *metadata, __u32 timeout_ms, __u64 *result)

   Submit an nvme io passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 opcode``
  The nvme io command to send

``__u8 flags``
  NVMe command flags (not used)

``__u16 rsvd``
  Reserevd for future use

``__u32 nsid``
  Namespace identifier

``__u32 cdw2``
  Command dword 2

``__u32 cdw3``
  Command dword 3

``__u32 cdw10``
  Command dword 10

``__u32 cdw11``
  Command dword 11

``__u32 cdw12``
  Command dword 12

``__u32 cdw13``
  Command dword 13

``__u32 cdw14``
  Command dword 14

``__u32 cdw15``
  Command dword 15

``__u32 data_len``
  Length of the data transfered in this command in bytes

``void *data``
  Pointer to user address of the data buffer

``__u32 metadata_len``
  Length of metadata transfered in this command

``void *metadata``
  Pointer to user address of the metadata buffer

``__u32 timeout_ms``
  How long the kernel waits for the command to complete

``__u64 *result``
  Optional field to return the result from the CQE dword 0

**Description**

Parameterized form of nvme_submit_io_passthru64(). This sets up and submits
a :c:type:`struct nvme_passthru_cmd64 <nvme_passthru_cmd64>`.

Known values for **opcode** are defined in :c:type:`enum nvme_io_opcode <nvme_io_opcode>`.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_submit_io_passthru (int fd, struct nvme_passthru_cmd *cmd, __u32 *result)

   Submit an nvme passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_passthru_cmd *cmd``
  The nvme io command to send

``__u32 *result``
  Optional field to return the result from the CQE DW0

**Description**

Uses NVME_IOCTL_IO_CMD for the ioctl request.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_io_passthru (int fd, __u8 opcode, __u8 flags, __u16 rsvd, __u32 nsid, __u32 cdw2, __u32 cdw3, __u32 cdw10, __u32 cdw11, __u32 cdw12, __u32 cdw13, __u32 cdw14, __u32 cdw15, __u32 data_len, void *data, __u32 metadata_len, void *metadata, __u32 timeout_ms, __u32 *result)

   Submit an nvme io passthrough command

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 opcode``
  The nvme io command to send

``__u8 flags``
  NVMe command flags (not used)

``__u16 rsvd``
  Reserevd for future use

``__u32 nsid``
  Namespace identifier

``__u32 cdw2``
  Command dword 2

``__u32 cdw3``
  Command dword 3

``__u32 cdw10``
  Command dword 10

``__u32 cdw11``
  Command dword 11

``__u32 cdw12``
  Command dword 12

``__u32 cdw13``
  Command dword 13

``__u32 cdw14``
  Command dword 14

``__u32 cdw15``
  Command dword 15

``__u32 data_len``
  Length of the data transfered in this command in bytes

``void *data``
  Pointer to user address of the data buffer

``__u32 metadata_len``
  Length of metadata transfered in this command

``void *metadata``
  Pointer to user address of the metadata buffer

``__u32 timeout_ms``
  How long the kernel waits for the command to complete

``__u32 *result``
  Optional field to return the result from the CQE dword 0

**Description**

Parameterized form of nvme_submit_io_passthru(). This sets up and submits
a :c:type:`struct nvme_passthru_cmd <nvme_passthru_cmd>`.

Known values for **opcode** are defined in :c:type:`enum nvme_io_opcode <nvme_io_opcode>`.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_subsystem_reset (int fd)

   Initiate a subsystem reset

**Parameters**

``int fd``
  File descriptor of nvme device

**Description**

This should only be sent to controller handles, not to namespaces.

**Return**

Zero if a subsystem reset was initiated or -1 with errno set
otherwise.


.. c:function:: int nvme_ctrl_reset (int fd)

   Initiate a controller reset

**Parameters**

``int fd``
  File descriptor of nvme device

**Description**

This should only be sent to controller handles, not to namespaces.

**Return**

0 if a reset was initiated or -1 with errno set otherwise.


.. c:function:: int nvme_ns_rescan (int fd)

   Initiate a controller rescan

**Parameters**

``int fd``
  File descriptor of nvme device

**Description**

This should only be sent to controller handles, not to namespaces.

**Return**

0 if a rescan was initiated or -1 with errno set otherwise.


.. c:function:: int nvme_get_nsid (int fd, __u32 *nsid)

   Retrieve the NSID from a namespace file descriptor

**Parameters**

``int fd``
  File descriptor of nvme namespace

``__u32 *nsid``
  User pointer to namespace id

**Description**

This should only be sent to namespace handles, not to controllers. The
kernel's interface returns the nsid as the return value. This is unfortunate
for many architectures that are incapable of allowing distinguishing a
namespace id > 0x80000000 from a negative error number.

**Return**

0 if **nsid** was set successfully or -1 with errno set otherwise.




.. c:struct:: nvme_identify_args

   Arguments for the NVMe Identify command

**Definition**

::

  struct nvme_identify_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    enum nvme_identify_cns cns;
    enum nvme_csi csi;
    __u32 nsid;
    __u16 cntid;
    __u16 cns_specific_id;
    __u8 uuidx;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  User space destination address to transfer the data

``args_size``
  Size of :c:type:`struct nvme_identify_args <nvme_identify_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms (0 for default timeout)

``cns``
  The Controller or Namespace structure, see **enum** nvme_identify_cns

``csi``
  Command Set Identifier

``nsid``
  Namespace identifier, if applicable

``cntid``
  The Controller Identifier, if applicable

``cns_specific_id``
  Identifier that is required for a particular CNS value

``uuidx``
  UUID Index if controller supports this id selection method



.. c:function:: int nvme_identify (struct nvme_identify_args *args)

   Send the NVMe Identify command

**Parameters**

``struct nvme_identify_args *args``
  :c:type:`struct nvme_identify_args <nvme_identify_args>` argument structure

**Description**

The Identify command returns a data buffer that describes information about
the NVM subsystem, the controller or the namespace(s).

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ctrl (int fd, struct nvme_id_ctrl *id)

   Retrieves nvme identify controller

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_id_ctrl *id``
  User space destination address to transfer the data,

**Description**

Sends nvme identify with CNS value ``NVME_IDENTIFY_CNS_CTRL``.

See :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>` for details on the data returned.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ns (int fd, __u32 nsid, struct nvme_id_ns *ns)

   Retrieves nvme identify namespace

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace to identify

``struct nvme_id_ns *ns``
  User space destination address to transfer the data

**Description**

If the Namespace Identifier (NSID) field specifies an active NSID, then the
Identify Namespace data structure is returned to the host for that specified
namespace.

If the controller supports the Namespace Management capability and the NSID
field is set to ``NVME_NSID_ALL``, then the controller returns an Identify Namespace
data structure that specifies capabilities that are common across namespaces
for this controller.

See :c:type:`struct nvme_id_ns <nvme_id_ns>` for details on the structure returned.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_allocated_ns (int fd, __u32 nsid, struct nvme_id_ns *ns)

   Same as nvme_identify_ns, but only for allocated namespaces

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace to identify

``struct nvme_id_ns *ns``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_active_ns_list (int fd, __u32 nsid, struct nvme_ns_list *list)

   Retrieves active namespaces id list

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return namespaces greater than this identifer

``struct nvme_ns_list *list``
  User space destination address to transfer the data

**Description**

A list of 1024 namespace IDs is returned to the host containing NSIDs in
increasing order that are greater than the value specified in the Namespace
Identifier (nsid) field of the command.

See :c:type:`struct nvme_ns_list <nvme_ns_list>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_allocated_ns_list (int fd, __u32 nsid, struct nvme_ns_list *list)

   Retrieves allocated namespace id list

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return namespaces greater than this identifer

``struct nvme_ns_list *list``
  User space destination address to transfer the data

**Description**

A list of 1024 namespace IDs is returned to the host containing NSIDs in
increasing order that are greater than the value specified in the Namespace
Identifier (nsid) field of the command.

See :c:type:`struct nvme_ns_list <nvme_ns_list>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ctrl_list (int fd, __u16 cntid, struct nvme_ctrl_list *cntlist)

   Retrieves identify controller list

**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 cntid``
  Starting CNTLID to return in the list

``struct nvme_ctrl_list *cntlist``
  User space destination address to transfer the data

**Description**

Up to 2047 controller identifiers is returned containing a controller
identifier greater than or equal to the controller identifier  specified in
**cntid**.

See :c:type:`struct nvme_ctrl_list <nvme_ctrl_list>` for a definition of the structure returned.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_nsid_ctrl_list (int fd, __u32 nsid, __u16 cntid, struct nvme_ctrl_list *cntlist)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return controllers that are attached to this nsid

``__u16 cntid``
  Starting CNTLID to return in the list

``struct nvme_ctrl_list *cntlist``
  User space destination address to transfer the data

**Description**

Up to 2047 controller identifiers is returned containing a controller
identifier greater than or equal to the controller identifier  specified in
**cntid**.

See :c:type:`struct nvme_ctrl_list <nvme_ctrl_list>` for a definition of the structure returned.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1


.. c:function:: int nvme_identify_ns_descs (int fd, __u32 nsid, struct nvme_ns_id_desc *descs)

   Retrieves namespace descriptor list

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  The namespace id to retrieve destriptors

``struct nvme_ns_id_desc *descs``
  User space destination address to transfer the data

**Description**

A list of Namespace Identification Descriptor structures is returned to the
host for the namespace specified in the Namespace Identifier (NSID) field if
it is an active NSID.

The data returned is in the form of an arrray of 'struct nvme_ns_id_desc'.

See :c:type:`struct nvme_ns_id_desc <nvme_ns_id_desc>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_nvmset_list (int fd, __u16 nvmsetid, struct nvme_id_nvmset_list *nvmset)

   Retrieves NVM Set List

**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 nvmsetid``
  NVM Set Identifier

``struct nvme_id_nvmset_list *nvmset``
  User space destination address to transfer the data

**Description**

Retrieves an NVM Set List, :c:type:`struct nvme_id_nvmset_list <nvme_id_nvmset_list>`. The data structure
is an ordered list by NVM Set Identifier, starting with the first NVM Set
Identifier supported by the NVM subsystem that is equal to or greater than
the NVM Set Identifier.

See :c:type:`struct nvme_id_nvmset_list <nvme_id_nvmset_list>` for the defintion of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_primary_ctrl (int fd, __u16 cntid, struct nvme_primary_ctrl_cap *cap)

   Retrieve NVMe Primary Controller identification

**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 cntid``
  Return controllers starting at this identifier

``struct nvme_primary_ctrl_cap *cap``
  User space destination buffer address to transfer the data

**Description**

See :c:type:`struct nvme_primary_ctrl_cap <nvme_primary_ctrl_cap>` for the defintion of the returned structure, **cap**.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_secondary_ctrl_list (int fd, __u32 nsid, __u16 cntid, struct nvme_secondary_ctrl_list *sc_list)

   Retrieves secondary controller list

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace identifier

``__u16 cntid``
  Return controllers starting at this identifier

``struct nvme_secondary_ctrl_list *sc_list``
  User space destination address to transfer the data

**Description**

A Secondary Controller List is returned to the host for up to 127 secondary
controllers associated with the primary controller processing this command.
The list contains entries for controller identifiers greater than or equal
to the value specified in the Controller Identifier (cntid).

See :c:type:`struct nvme_secondary_ctrls_list <nvme_secondary_ctrls_list>` for a defintion of the returned
structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ns_granularity (int fd, struct nvme_id_ns_granularity_list *gr_list)

   Retrieves namespace granularity identification

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_id_ns_granularity_list *gr_list``
  User space destination address to transfer the data

**Description**

If the controller supports reporting of Namespace Granularity, then a
Namespace Granularity List is returned to the host for up to sixteen
namespace granularity descriptors

See :c:type:`struct nvme_id_ns_granularity_list <nvme_id_ns_granularity_list>` for the definition of the returned
structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_uuid (int fd, struct nvme_id_uuid_list *uuid_list)

   Retrieves device's UUIDs

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_id_uuid_list *uuid_list``
  User space destination address to transfer the data

**Description**

Each UUID List entry is either 0h, the NVMe Invalid UUID, or a valid UUID.
Valid UUIDs are those which are non-zero and are not the NVMe Invalid UUID.

See :c:type:`struct nvme_id_uuid_list <nvme_id_uuid_list>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ns_csi (int fd, __u32 nsid, __u8 uuidx, enum nvme_csi csi, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace to identify

``__u8 uuidx``
  UUID Index for differentiating vendor specific encoding

``enum nvme_csi csi``
  Command Set Identifier

``void *data``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ctrl_csi (int fd, enum nvme_csi csi, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_csi csi``
  Command Set Identifier

``void *data``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_active_ns_list_csi (int fd, __u32 nsid, enum nvme_csi csi, struct nvme_ns_list *ns_list)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return namespaces greater than this identifier

``enum nvme_csi csi``
  Command Set Identifier

``struct nvme_ns_list *ns_list``
  User space destination address to transfer the data

**Description**

A list of 1024 namespace IDs is returned to the host containing active
NSIDs in increasing order that are greater than the value specified in
the Namespace Identifier (nsid) field of the command and matching the
I/O Command Set specified in the **csi** argument.

See :c:type:`struct nvme_ns_list <nvme_ns_list>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_allocated_ns_list_csi (int fd, __u32 nsid, enum nvme_csi csi, struct nvme_ns_list *ns_list)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return namespaces greater than this identifier

``enum nvme_csi csi``
  Command Set Identifier

``struct nvme_ns_list *ns_list``
  User space destination address to transfer the data

**Description**

A list of 1024 namespace IDs is returned to the host containing allocated
NSIDs in increasing order that are greater than the value specified in
the **nsid** field of the command and matching the I/O Command Set
specified in the **csi** argument.

See :c:type:`struct nvme_ns_list <nvme_ns_list>` for the definition of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_independent_identify_ns (int fd, __u32 nsid, struct nvme_id_independent_id_ns *ns)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Return namespaces greater than this identifier

``struct nvme_id_independent_id_ns *ns``
  I/O Command Set Independent Identify Namespace data
  structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_ns_csi_user_data_format (int fd, __u16 user_data_format, __u8 uuidx, enum nvme_csi csi, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 user_data_format``
  Return namespaces capability of identifier

``__u8 uuidx``
  UUID selection, if supported

``enum nvme_csi csi``
  Command Set Identifier

``void *data``
  *undescribed*

**Description**

Identify Namespace data structure for the specified User Data Format
index containing the namespace capabilities for the NVM Command Set.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_iocs_ns_csi_user_data_format (int fd, __u16 user_data_format, __u8 uuidx, enum nvme_csi csi, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 user_data_format``
  Return namespaces capability of identifier

``__u8 uuidx``
  UUID selection, if supported

``enum nvme_csi csi``
  Command Set Identifier

``void *data``
  *undescribed*

**Description**

I/O Command Set specific Identify Namespace data structure for
the specified User Data Format index containing the namespace
capabilities for the I/O Command Set specified in the CSI field.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_nvm_identify_ctrl (int fd, struct nvme_id_ctrl_nvm *id)


**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_id_ctrl_nvm *id``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_domain_list (int fd, __u16 domid, struct nvme_id_domain_list *list)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 domid``
  Domain ID

``struct nvme_id_domain_list *list``
  User space destiantion address to transfer data

**Description**

A list of 31 domain IDs is returned to the host containing domain
attributes in increasing order that are greater than the value
specified in the **domid** field.

See :c:type:`struct nvme_identify_domain_attr <nvme_identify_domain_attr>` for the definition of the
returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_endurance_group_list (int fd, __u16 endgrp_id, struct nvme_id_endurance_group_list *list)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 endgrp_id``
  Endurance group identifier

``struct nvme_id_endurance_group_list *list``
  Array of endurance group identifiers

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_identify_iocs (int fd, __u16 cntlid, struct nvme_id_iocs *iocs)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 cntlid``
  Controller ID

``struct nvme_id_iocs *iocs``
  User space destination address to transfer the data

**Description**

Retrieves list of the controller's supported io command set vectors. See
:c:type:`struct nvme_id_iocs <nvme_id_iocs>`.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_zns_identify_ns (int fd, __u32 nsid, struct nvme_zns_id_ns *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace to identify

``struct nvme_zns_id_ns *data``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_zns_identify_ctrl (int fd, struct nvme_zns_id_ctrl *id)


**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_zns_id_ctrl *id``
  User space destination address to transfer the data

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_get_log_args

   Arguments for the NVMe Admin Get Log command

**Definition**

::

  struct nvme_get_log_args {
    __u64 lpo;
    __u32 *result;
    void *log;
    int args_size;
    int fd;
    __u32 timeout;
    enum nvme_cmd_get_log_lid lid;
    __u32 len;
    __u32 nsid;
    enum nvme_csi csi;
    __u16 lsi;
    __u8 lsp;
    __u8 uuidx;
    bool rae;
    bool ot;
  };

**Members**

``lpo``
  Log page offset for partial log transfers

``result``
  The command completion result from CQE dword0

``log``
  User space destination address to transfer the data

``args_size``
  Length of the structure

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``lid``
  Log page identifier, see :c:type:`enum nvme_cmd_get_log_lid <nvme_cmd_get_log_lid>` for known
  values

``len``
  Length of provided user buffer to hold the log data in bytes

``nsid``
  Namespace identifier, if applicable

``csi``
  Command set identifier, see :c:type:`enum nvme_csi <nvme_csi>` for known values

``lsi``
  Log Specific Identifier

``lsp``
  Log specific field

``uuidx``
  UUID selection, if supported

``rae``
  Retain asynchronous events

``ot``
  Offset Type; if set **lpo** specifies the index into the list
  of data structures, otherwise **lpo** specifies the byte offset
  into the log page.



.. c:function:: int nvme_get_log (struct nvme_get_log_args *args)

   NVMe Admin Get Log command

**Parameters**

``struct nvme_get_log_args *args``
  :c:type:`struct nvme_get_log_args <nvme_get_log_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_supported_log_pages (int fd, bool rae, struct nvme_supported_log_pages *log)

   Retrieve nmve supported log pages

**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_supported_log_pages *log``
  Array of LID supported and Effects data structures

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_error (int fd, unsigned nr_entries, bool rae, struct nvme_error_log_page *err_log)

   Retrieve nvme error log

**Parameters**

``int fd``
  File descriptor of nvme device

``unsigned nr_entries``
  Number of error log entries allocated

``bool rae``
  Retain asynchronous events

``struct nvme_error_log_page *err_log``
  Array of error logs of size 'entries'

**Description**

This log page describes extended error information for a command that
completed with error, or may report an error that is not specific to a
particular command.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_smart (int fd, __u32 nsid, bool rae, struct nvme_smart_log *smart_log)

   Retrieve nvme smart log

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Optional namespace identifier

``bool rae``
  Retain asynchronous events

``struct nvme_smart_log *smart_log``
  User address to store the smart log

**Description**

This log page provides SMART and general health information. The information
provided is over the life of the controller and is retained across power
cycles. To request the controller log page, the namespace identifier
specified is FFFFFFFFh. The controller may also support requesting the log
page on a per namespace basis, as indicated by bit 0 of the LPA field in the
Identify Controller data structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_fw_slot (int fd, bool rae, struct nvme_firmware_slot *fw_log)

   Retrieves the controller firmware log

**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_firmware_slot *fw_log``
  User address to store the log page

**Description**

This log page describes the firmware revision stored in each firmware slot
supported. The firmware revision is indicated as an ASCII string. The log
page also indicates the active slot number.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_changed_ns_list (int fd, bool rae, struct nvme_ns_list *ns_log)

   Retrieve namespace changed list

**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_ns_list *ns_log``
  User address to store the log page

**Description**

This log page describes namespaces attached to this controller that have
changed since the last time the namespace was identified, been added, or
deleted.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_cmd_effects (int fd, enum nvme_csi csi, struct nvme_cmd_effects_log *effects_log)

   Retrieve nvme command effects log

**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_csi csi``
  Command Set Identifier

``struct nvme_cmd_effects_log *effects_log``
  User address to store the effects log

**Description**

This log page describes the commands that the controller supports and the
effects of those commands on the state of the NVM subsystem.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_device_self_test (int fd, struct nvme_self_test_log *log)

   Retrieve the device self test log

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_self_test_log *log``
  Userspace address of the log payload

**Description**

The log page indicates the status of an in progress self test and the
percent complete of that operation, and the results of the previous 20
self-test operations.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_create_telemetry_host (int fd, struct nvme_telemetry_log *log)

   Create host telemetry log

**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_telemetry_log *log``
  Userspace address of the log payload


.. c:function:: int nvme_get_log_telemetry_host (int fd, __u64 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u64 offset``
  Offset into the telemetry data

``__u32 len``
  Length of provided user buffer to hold the log data in bytes

``void *log``
  User address for log page data

**Description**

Retreives the Telemetry Host-Initiated log page at the requested offset
using the previously existing capture.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_telemetry_ctrl (int fd, bool rae, __u64 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u64 offset``
  Offset into the telemetry data

``__u32 len``
  Length of provided user buffer to hold the log data in bytes

``void *log``
  User address for log page data


.. c:function:: int nvme_get_log_endurance_group (int fd, __u16 endgid, struct nvme_endurance_group_log *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 endgid``
  Starting group identifier to return in the list

``struct nvme_endurance_group_log *log``
  User address to store the endurance log

**Description**

This log page indicates if an Endurance Group Event has occurred for a
particular Endurance Group. If an Endurance Group Event has occurred, the
details of the particular event are included in the Endurance Group
Information log page for that Endurance Group. An asynchronous event is
generated when an entry for an Endurance Group is newly added to this log
page.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_predictable_lat_nvmset (int fd, __u16 nvmsetid, struct nvme_nvmset_predictable_lat_log *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 nvmsetid``
  NVM set id

``struct nvme_nvmset_predictable_lat_log *log``
  User address to store the predictable latency log

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_predictable_lat_event (int fd, bool rae, __u32 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u32 offset``

``__u32 len``

``void *log``


.. c:function:: int nvme_get_log_ana (int fd, enum nvme_log_ana_lsp lsp, bool rae, __u64 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_log_ana_lsp lsp``
  Log specific, see :c:type:`enum nvme_get_log_ana_lsp <nvme_get_log_ana_lsp>`

``bool rae``
  Retain asynchronous events

``__u64 offset``
  Offset to the start of the log page

``__u32 len``
  The allocated length of the log page

``void *log``
  User address to store the ana log

**Description**

This log consists of a header describing the log and descriptors containing
the asymmetric namespace access information for ANA Groups that contain
namespaces that are attached to the controller processing the command.

See :c:type:`struct nvme_ana_rsp_hdr <nvme_ana_rsp_hdr>` for the defintion of the returned structure.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_ana_groups (int fd, bool rae, __u32 len, struct nvme_ana_group_desc *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u32 len``
  The allocated length of the log page

``struct nvme_ana_group_desc *log``
  User address to store the ana group log

**Description**

See :c:type:`struct nvme_ana_group_desc <nvme_ana_group_desc>` for the defintion of the returned structure.


.. c:function:: int nvme_get_log_lba_status (int fd, bool rae, __u64 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u64 offset``
  Offset to the start of the log page

``__u32 len``
  The allocated length of the log page

``void *log``
  User address to store the log page


.. c:function:: int nvme_get_log_endurance_grp_evt (int fd, bool rae, __u32 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u32 offset``
  Offset to the start of the log page

``__u32 len``
  The allocated length of the log page

``void *log``
  User address to store the log page


.. c:function:: int nvme_get_log_fid_supported_effects (int fd, bool rae, struct nvme_fid_supported_effects_log *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_fid_supported_effects_log *log``
  FID Supported and Effects data structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise


.. c:function:: int nvme_get_log_boot_partition (int fd, bool rae, __u8 lsp, __u32 len, struct nvme_boot_partition *part)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u8 lsp``
  The log specified field of LID

``__u32 len``
  The allocated size, minimum
  struct nvme_boot_partition

``struct nvme_boot_partition *part``
  User address to store the log page

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise


.. c:function:: int nvme_get_log_discovery (int fd, bool rae, __u32 offset, __u32 len, void *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``__u32 offset``
  Offset of this log to retrieve

``__u32 len``
  The allocated size for this portion of the log

``void *log``
  User address to store the discovery log

**Description**

Supported only by fabrics discovery controllers, returning discovery
records.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_media_unit_stat (int fd, __u16 domid, struct nvme_media_unit_stat_log *mus)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 domid``
  Domain Identifier selection, if supported

``struct nvme_media_unit_stat_log *mus``
  User address to store the Media Unit statistics log

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise


.. c:function:: int nvme_get_log_support_cap_config_list (int fd, __u16 domid, struct nvme_supported_cap_config_list_log *cap)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 domid``
  Domain Identifier selection, if supported

``struct nvme_supported_cap_config_list_log *cap``
  *undescribed*

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise


.. c:function:: int nvme_get_log_reservation (int fd, bool rae, struct nvme_resv_notification_log *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_resv_notification_log *log``
  User address to store the reservation log


.. c:function:: int nvme_get_log_sanitize (int fd, bool rae, struct nvme_sanitize_log_page *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_sanitize_log_page *log``
  User address to store the sanitize log

**Description**

The Sanitize Status log page reports sanitize operation time estimates and
information about the most recent sanitize operation.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_zns_changed_zones (int fd, __u32 nsid, bool rae, struct nvme_zns_changed_zone_log *log)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``bool rae``
  Retain asynchronous events

``struct nvme_zns_changed_zone_log *log``
  User address to store the changed zone log

**Description**

The list of zones that have changed state due to an exceptional event.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_persistent_event (int fd, enum nvme_pevent_log_action action, __u32 size, void *pevent_log)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_pevent_log_action action``
  Action the controller should take during processing this command

``__u32 size``
  Size of **pevent_log**

``void *pevent_log``
  User address to store the persistent event log




.. c:struct:: nvme_set_features_args

   Arguments for the NVMe Admin Set Feature command

**Definition**

::

  struct nvme_set_features_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 cdw11;
    __u32 cdw12;
    __u32 cdw15;
    __u32 data_len;
    bool save;
    __u8 uuidx;
    __u8 fid;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  User address of feature data, if applicable

``args_size``
  Size of :c:type:`struct nvme_set_features_args <nvme_set_features_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID, if applicable

``cdw11``
  Value to set the feature to

``cdw12``
  Feature specific command dword12 field

``cdw15``
  Feature specific command dword15 field

``data_len``
  Length of feature data, if applicable, in bytes

``save``
  Save value across power states

``uuidx``
  UUID Index for differentiating vendor specific encoding

``fid``
  Feature identifier



.. c:function:: int nvme_set_features (struct nvme_set_features_args *args)

   Set a feature attribute

**Parameters**

``struct nvme_set_features_args *args``
  :c:type:`struct nvme_set_features_args <nvme_set_features_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_data (int fd, __u8 fid, __u32 nsid, __u32 cdw11, bool save, __u32 data_len, void *data, __u32 *result)

   Helper function for **nvme_set_features\(\)**

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 fid``
  Feature identifier

``__u32 nsid``
  Namespace ID, if applicable

``__u32 cdw11``
  Value to set the feature to

``bool save``
  Save value across power states

``__u32 data_len``
  Length of feature data, if applicable, in bytes

``void *data``
  User address of feature data, if applicable

``__u32 *result``
  The command completion result from CQE dword0


.. c:function:: int nvme_set_features_simple (int fd, __u8 fid, __u32 nsid, __u32 cdw11, bool save, __u32 *result)

   Helper functionn for **nvme_set_features\(\)**

**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 fid``
  Feature identifier

``__u32 nsid``
  Namespace ID, if applicable

``__u32 cdw11``
  Value to set the feature to

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0


.. c:function:: int nvme_set_features_arbitration (int fd, __u8 ab, __u8 lpw, __u8 mpw, __u8 hpw, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 ab``

``__u8 lpw``

``__u8 mpw``

``__u8 hpw``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_power_mgmt (int fd, __u8 ps, __u8 wh, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 ps``

``__u8 wh``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_lba_range (int fd, __u32 nsid, __u32 nr_ranges, bool save, struct nvme_lba_range_type *data, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``__u32 nr_ranges``
  Number of ranges in **data**

``bool save``
  Save value across power states

``struct nvme_lba_range_type *data``
  User address of feature data

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_temp_thresh (int fd, __u16 tmpth, __u8 tmpsel, enum nvme_feat_tmpthresh_thsel thsel, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 tmpth``

``__u8 tmpsel``

``enum nvme_feat_tmpthresh_thsel thsel``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_err_recovery (int fd, __u32 nsid, __u16 tler, bool dulbe, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``__u16 tler``
  Time-limited error recovery value

``bool dulbe``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_volatile_wc (int fd, bool wce, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool wce``
  Write cache enable

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_irq_coalesce (int fd, __u8 thr, __u8 time, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 thr``

``__u8 time``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_irq_config (int fd, __u16 iv, bool cd, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 iv``

``bool cd``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_write_atomic (int fd, bool dn, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool dn``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_async_event (int fd, __u32 events, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 events``
  Events to enable

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_auto_pst (int fd, bool apste, bool save, struct nvme_feat_auto_pst *apst, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool apste``

``bool save``
  Save value across power states

``struct nvme_feat_auto_pst *apst``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_timestamp (int fd, bool save, __u64 timestamp)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool save``
  Save value across power states

``__u64 timestamp``
  The current timestamp value to assign to this this feature

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_hctm (int fd, __u16 tmt2, __u16 tmt1, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 tmt2``

``__u16 tmt1``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_nopsc (int fd, bool noppme, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool noppme``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_rrl (int fd, __u8 rrl, __u16 nvmsetid, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 rrl``
  Read recovery level setting

``__u16 nvmsetid``
  NVM set id

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_plm_config (int fd, bool enable, __u16 nvmsetid, bool save, struct nvme_plm_config *data, __u32*result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool enable``

``__u16 nvmsetid``

``bool save``
  Save value across power states

``struct nvme_plm_config *data``

``__u32*result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_plm_window (int fd, enum nvme_feat_plm_window_select sel, __u16 nvmsetid, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_feat_plm_window_select sel``

``__u16 nvmsetid``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_lba_sts_interval (int fd, __u16 lsiri, __u16 lsipi, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 lsiri``

``__u16 lsipi``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_host_behavior (int fd, bool save, struct nvme_feat_host_behavior *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool save``
  Save value across power states

``struct nvme_feat_host_behavior *data``

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_sanitize (int fd, bool nodrm, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool nodrm``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_endurance_evt_cfg (int fd, __u16 endgid, __u8 egwarn, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u16 endgid``

``__u8 egwarn``
  Flags to enable warning, see :c:type:`enum nvme_eg_critical_warning_flags <nvme_eg_critical_warning_flags>`

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_sw_progress (int fd, __u8 pbslc, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u8 pbslc``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_host_id (int fd, bool exhid, bool save, __u8 *hostid)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool exhid``

``bool save``
  Save value across power states

``__u8 *hostid``
  Host ID to set

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_resv_mask (int fd, __u32 mask, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 mask``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_resv_persist (int fd, bool ptpl, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool ptpl``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_set_features_write_protect (int fd, enum nvme_feat_nswpcfg_state state, bool save, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_feat_nswpcfg_state state``

``bool save``
  Save value across power states

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_get_features_args

   Arguments for the NVMe Admin Get Feature command

**Definition**

::

  struct nvme_get_features_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_get_features_sel sel;
    __u32 cdw11;
    __u32 data_len;
    __u8 fid;
    __u8 uuidx;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  User address of feature data, if applicable

``args_size``
  Size of :c:type:`struct nvme_get_features_args <nvme_get_features_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID, if applicable

``sel``
  Select which type of attribute to return,
  see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``cdw11``
  Feature specific command dword11 field

``data_len``
  Length of feature data, if applicable, in bytes

``fid``
  Feature identifier, see :c:type:`enum nvme_features_id <nvme_features_id>`

``uuidx``
  UUID Index for differentiating vendor specific encoding



.. c:function:: int nvme_get_features (struct nvme_get_features_args *args)

   Retrieve a feature attribute

**Parameters**

``struct nvme_get_features_args *args``
  :c:type:`struct nvme_get_features_args <nvme_get_features_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_data (int fd, enum nvme_features_id fid, __u32 nsid, __u32 data_len, void *data, __u32 *result)

   Helper function for **nvme_get_features\(\)**

**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_features_id fid``
  Feature identifier

``__u32 nsid``
  Namespace ID, if applicable

``__u32 data_len``
  Length of feature data, if applicable, in bytes

``void *data``
  User address of feature data, if applicable

``__u32 *result``
  The command completion result from CQE dword0


.. c:function:: int nvme_get_features_simple (int fd, enum nvme_features_id fid, __u32 nsid, __u32 *result)

   Helper function for **nvme_get_features\(\)**

**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_features_id fid``
  Feature identifier

``__u32 nsid``
  Namespace ID, if applicable

``__u32 *result``
  The command completion result from CQE dword0


.. c:function:: int nvme_get_features_arbitration (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_power_mgmt (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_lba_range (int fd, enum nvme_get_features_sel sel, struct nvme_lba_range_type *data, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``struct nvme_lba_range_type *data``
  User address of feature data, if applicable

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_temp_thresh (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_err_recovery (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_volatile_wc (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_num_queues (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_irq_coalesce (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_irq_config (int fd, enum nvme_get_features_sel sel, __u16 iv, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u16 iv``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_write_atomic (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_async_event (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_auto_pst (int fd, enum nvme_get_features_sel sel, struct nvme_feat_auto_pst *apst, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``struct nvme_feat_auto_pst *apst``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_host_mem_buf (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_timestamp (int fd, enum nvme_get_features_sel sel, struct nvme_timestamp *ts)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``struct nvme_timestamp *ts``
  Current timestamp

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_kato (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_hctm (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_nopsc (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_rrl (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_plm_config (int fd, enum nvme_get_features_sel sel, __u16 nvmsetid, struct nvme_plm_config *data, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u16 nvmsetid``
  NVM set id

``struct nvme_plm_config *data``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_plm_window (int fd, enum nvme_get_features_sel sel, __u16 nvmsetid, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u16 nvmsetid``
  NVM set id

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_lba_sts_interval (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_host_behavior (int fd, enum nvme_get_features_sel sel, struct nvme_feat_host_behavior *data, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``struct nvme_feat_host_behavior *data``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_sanitize (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_endurance_event_cfg (int fd, enum nvme_get_features_sel sel, __u16 endgid, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u16 endgid``

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_sw_progress (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_host_id (int fd, enum nvme_get_features_sel sel, bool exhid, __u32 len, __u8 *hostid)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``bool exhid``

``__u32 len``
  Length of **hostid**

``__u8 *hostid``
  Buffer for returned host ID

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_resv_mask (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_resv_persist (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_write_protect (int fd, __u32 nsid, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_features_iocs_profile (int fd, enum nvme_get_features_sel sel, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``enum nvme_get_features_sel sel``
  Select which type of attribute to return, see :c:type:`enum nvme_get_features_sel <nvme_get_features_sel>`

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_format_nvm_args

   Arguments for the Format Nvme Namespace command

**Definition**

::

  struct nvme_format_nvm_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_cmd_format_mset mset;
    enum nvme_cmd_format_pi pi;
    enum nvme_cmd_format_pil pil;
    enum nvme_cmd_format_ses ses;
    __u8 lbaf;
  };

**Members**

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_format_nvm_args <nvme_format_nvm_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Set to override default timeout to this value in milliseconds;
  useful for long running formats. 0 will use system default.

``nsid``
  Namespace ID to format

``mset``
  Metadata settings (extended or separated), true if extended

``pi``
  Protection information type

``pil``
  Protection information location (beginning or end), true if end

``ses``
  Secure erase settings

``lbaf``
  Logical block address format



.. c:function:: int nvme_format_nvm (struct nvme_format_nvm_args *args)

   Format nvme namespace(s)

**Parameters**

``struct nvme_format_nvm_args *args``
  :c:type:`struct nvme_format_nvme_args <nvme_format_nvme_args>` argument structure

**Description**

The Format NVM command low level formats the NVM media. This command is used
by the host to change the LBA data size and/or metadata size. A low level
format may destroy all data and metadata associated with all namespaces or
only the specific namespace associated with the command

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_ns_mgmt_args

   Arguments for NVMe Namespace Management command

**Definition**

::

  struct nvme_ns_mgmt_args {
    __u32 *result;
    struct nvme_id_ns *ns;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_ns_mgmt_sel sel;
    __u8 csi;
  };

**Members**

``result``
  NVMe command result

``ns``
  Namespace identication descriptors

``args_size``
  Size of :c:type:`struct nvme_ns_mgmt_args <nvme_ns_mgmt_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``sel``
  Type of management operation to perform

``csi``
  Command Set Identifier



.. c:function:: int nvme_ns_mgmt (struct nvme_ns_mgmt_args *args)

   Issue a Namespace management command

**Parameters**

``struct nvme_ns_mgmt_args *args``
  :c:type:`struct nvme_ns_mgmt_args <nvme_ns_mgmt_args>` Argument structure


.. c:function:: int nvme_ns_mgmt_create (int fd, struct nvme_id_ns *ns, __u32 *nsid, __u32 timeout, __u8 csi)


**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_id_ns *ns``
  Namespace identification that defines ns creation parameters

``__u32 *nsid``
  On success, set to the namespace id that was created

``__u32 timeout``
  Overide the default timeout to this value in milliseconds;
  set to 0 to use the system default.

``__u8 csi``
  Command Set Identifier

**Description**

On successful creation, the namespace exists in the subsystem, but is not
attached to any controller. Use the nvme_ns_attach_ctrls() to assign the
namespace to one or more controllers.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_ns_mgmt_delete (int fd, __u32 nsid)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace identifier to delete

**Description**

It is recommended that a namespace being deleted is not attached to any
controller. Use the nvme_ns_detach_ctrls() first if the namespace is still
attached.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_ns_attach_args

   Arguments for Nvme Namespace Management command

**Definition**

::

  struct nvme_ns_attach_args {
    __u32 *result;
    struct nvme_ctrl_list *ctrlist;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_ns_attach_sel sel;
  };

**Members**

``result``
  NVMe command result

``ctrlist``
  Controller list to modify attachment state of nsid

``args_size``
  Size of :c:type:`struct nvme_ns_attach_args <nvme_ns_attach_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID to execute attach selection

``sel``
  Attachment selection, see :c:type:`enum nvme_ns_attach_sel <nvme_ns_attach_sel>`



.. c:function:: int nvme_ns_attach (struct nvme_ns_attach_args *args)

   Attach or detach namespace to controller(s)

**Parameters**

``struct nvme_ns_attach_args *args``
  :c:type:`struct nvme_ns_attach_args <nvme_ns_attach_args>` Argument structure


.. c:function:: int nvme_ns_attach_ctrls (int fd, __u32 nsid, struct nvme_ctrl_list *ctrlist)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID to attach

``struct nvme_ctrl_list *ctrlist``
  Controller list to modify attachment state of nsid


.. c:function:: int nvme_ns_detach_ctrls (int fd, __u32 nsid, struct nvme_ctrl_list *ctrlist)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID to detach

``struct nvme_ctrl_list *ctrlist``
  Controller list to modify attachment state of nsid




.. c:struct:: nvme_fw_download_args

   Arguments for the NVMe Firmware Download command

**Definition**

::

  struct nvme_fw_download_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 offset;
    __u32 data_len;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  Userspace address of the firmware data

``args_size``
  Size of :c:type:`struct nvme_fw_download_args <nvme_fw_download_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``offset``
  Offset in the firmware data

``data_len``
  Length of data in this command in bytes



.. c:function:: int nvme_fw_download (struct nvme_fw_download_args *args)

   Download part or all of a firmware image to the controller

**Parameters**

``struct nvme_fw_download_args *args``
  :c:type:`struct nvme_fw_download_args <nvme_fw_download_args>` argument structure

**Description**

The Firmware Image Download command downloads all or a portion of an image
for a future update to the controller. The Firmware Image Download command
downloads a new image (in whole or in part) to the controller.

The image may be constructed of multiple pieces that are individually
downloaded with separate Firmware Image Download commands. Each Firmware
Image Download command includes a Dword Offset and Number of Dwords that
specify a dword range.

The new firmware image is not activated as part of the Firmware Image
Download command. Use the nvme_fw_commit() to activate a newly downloaded
image.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_fw_commit_args

   Arguments for the NVMe Firmware Commit command

**Definition**

::

  struct nvme_fw_commit_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    enum nvme_fw_commit_ca action;
    __u8 slot;
    bool bpid;
  };

**Members**

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_fw_commit_args <nvme_fw_commit_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``action``
  Action to use for the firmware image, see :c:type:`enum nvme_fw_commit_ca <nvme_fw_commit_ca>`

``slot``
  Firmware slot to commit the downloaded image

``bpid``
  Set to true to select the boot partition id



.. c:function:: int nvme_fw_commit (struct nvme_fw_commit_args *args)

   Commit firmware using the specified action

**Parameters**

``struct nvme_fw_commit_args *args``
  :c:type:`struct nvme_fw_commit_args <nvme_fw_commit_args>` argument structure

**Description**

The Firmware Commit command modifies the firmware image or Boot Partitions.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise. The command
status response may specify additional reset actions required to complete
the commit process.




.. c:struct:: nvme_security_send_args

   Arguments for the NVMe Security Send command

**Definition**

::

  struct nvme_security_send_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 tl;
    __u32 data_len;
    __u8 nssf;
    __u8 spsp0;
    __u8 spsp1;
    __u8 secp;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  Security data payload to send

``args_size``
  Size of :c:type:`struct nvme_security_send_args <nvme_security_send_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID to issue security command on

``tl``
  Protocol specific transfer length

``data_len``
  Data length of the payload in bytes

``nssf``
  NVMe Security Specific field

``spsp0``
  Security Protocol Specific field

``spsp1``
  Security Protocol Specific field

``secp``
  Security Protocol



.. c:function:: int nvme_security_send (struct nvme_security_send_args *args)


**Parameters**

``struct nvme_security_send_args *args``
  :c:type:`struct nvme_security_send <nvme_security_send>` argument structure

**Description**

The Security Send command transfers security protocol data to the
controller. The data structure transferred to the controller as part of this
command contains security protocol specific commands to be performed by the
controller. The data structure transferred may also contain data or
parameters associated with the security protocol commands.

The security data is protocol specific and is not defined by the NVMe
specification.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_security_receive_args

   Arguments for the NVMe Security Receive command

**Definition**

::

  struct nvme_security_receive_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 al;
    __u32 data_len;
    __u8 nssf;
    __u8 spsp0;
    __u8 spsp1;
    __u8 secp;
  };

**Members**

``result``
  The command completion result from CQE dword0

``data``
  Security data payload to send

``args_size``
  Size of :c:type:`struct nvme_security_receive_args <nvme_security_receive_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID to issue security command on

``al``
  Protocol specific allocation length

``data_len``
  Data length of the payload in bytes

``nssf``
  NVMe Security Specific field

``spsp0``
  Security Protocol Specific field

``spsp1``
  Security Protocol Specific field

``secp``
  Security Protocol



.. c:function:: int nvme_security_receive (struct nvme_security_receive_args *args)


**Parameters**

``struct nvme_security_receive_args *args``
  :c:type:`struct nvme_security_recevice <nvme_security_recevice>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_get_lba_status_args

   Arguments for the NVMe Get LBA Status command

**Definition**

::

  struct nvme_get_lba_status_args {
    __u64 slba;
    __u32 *result;
    struct nvme_lba_status *lbas;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 mndw;
    enum nvme_lba_status_atype atype;
    __u16 rl;
  };

**Members**

``slba``
  Starting logical block address to check statuses

``result``
  The command completion result from CQE dword0

``lbas``
  Data payload to return status descriptors

``args_size``
  Size of :c:type:`struct nvme_get_lba_status_args <nvme_get_lba_status_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID to retrieve LBA status

``mndw``
  Maximum number of dwords to return

``atype``
  Action type mechanism to determine LBA status desctriptors to
  return, see :c:type:`enum nvme_lba_status_atype <nvme_lba_status_atype>`

``rl``
  Range length from slba to perform the action



.. c:function:: int nvme_get_lba_status (struct nvme_get_lba_status_args *args)

   Retrieve information on possibly unrecoverable LBAs

**Parameters**

``struct nvme_get_lba_status_args *args``
  :c:type:`struct nvme_get_lba_status_args <nvme_get_lba_status_args>` argument structure

**Description**

The Get LBA Status command requests information about Potentially
Unrecoverable LBAs. Refer to the specification for action type descriptions.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_directive_send_args

   Arguments for the NVMe Directive Send command

**Definition**

::

  struct nvme_directive_send_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_directive_send_doper doper;
    enum nvme_directive_dtype dtype;
    __u32 cdw12;
    __u32 data_len;
    __u16 dspec;
  };

**Members**

``result``
  If successful, the CQE dword0 value

``data``
  Data payload to to be send

``args_size``
  Size of :c:type:`struct nvme_directive_send_args <nvme_directive_send_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID, if applicable

``doper``
  Directive send operation, see :c:type:`enum nvme_directive_send_doper <nvme_directive_send_doper>`

``dtype``
  Directive type, see :c:type:`enum nvme_directive_dtype <nvme_directive_dtype>`

``cdw12``
  Directive specific command dword12

``data_len``
  Length of data payload in bytes

``dspec``
  Directive specific field



.. c:function:: int nvme_directive_send (struct nvme_directive_send_args *args)

   Send directive command

**Parameters**

``struct nvme_directive_send_args *args``
  :c:type:`struct nvme_directive_send_args <nvme_directive_send_args>` argument structure

**Description**

Directives is a mechanism to enable host and NVM subsystem or controller
information exchange. The Directive Send command transfers data related to a
specific Directive Type from the host to the controller.

See the NVMe specification for more information.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_send_id_endir (int fd, __u32 nsid, bool endir, enum nvme_directive_dtype dtype, struct nvme_id_directives *id)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``

``bool endir``

``enum nvme_directive_dtype dtype``

``struct nvme_id_directives *id``

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_send_stream_release_identifier (int fd, __u32 nsid, __u16 stream_id)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``__u16 stream_id``
  Stream identifier

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_send_stream_release_resource (int fd, __u32 nsid)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_directive_recv_args

   Arguments for the NVMe Directive Receive command

**Definition**

::

  struct nvme_directive_recv_args {
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_directive_receive_doper doper;
    enum nvme_directive_dtype dtype;
    __u32 cdw12;
    __u32 data_len;
    __u16 dspec;
  };

**Members**

``result``
  If successful, the CQE dword0 value

``data``
  Usespace address of data payload

``args_size``
  Size of :c:type:`struct nvme_directive_recv_args <nvme_directive_recv_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID, if applicable

``doper``
  Directive send operation, see :c:type:`enum nvme_directive_send_doper <nvme_directive_send_doper>`

``dtype``
  Directive type, see :c:type:`enum nvme_directive_dtype <nvme_directive_dtype>`

``cdw12``
  Directive specific command dword12

``data_len``
  Length of data payload in bytes

``dspec``
  Directive specific field



.. c:function:: int nvme_directive_recv (struct nvme_directive_recv_args *args)

   Receive directive specific data

**Parameters**

``struct nvme_directive_recv_args *args``
  :c:type:`struct nvme_directive_recv_args <nvme_directive_recv_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_recv_identify_parameters (int fd, __u32 nsid, struct nvme_id_directives *id)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``struct nvme_id_directives *id``
  Identify parameters buffer

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_recv_stream_parameters (int fd, __u32 nsid, struct nvme_streams_directive_params *parms)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``struct nvme_streams_directive_params *parms``
  Streams directive parameters buffer

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_recv_stream_status (int fd, __u32 nsid, unsigned nr_entries, struct nvme_streams_directive_status *id)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``unsigned nr_entries``
  Number of streams to receive

``struct nvme_streams_directive_status *id``
  Stream status buffer

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_directive_recv_stream_allocate (int fd, __u32 nsid, __u16 nsr, __u32 *result)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``__u16 nsr``

``__u32 *result``

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_capacity_mgmt_args

   Arguments for the NVMe Capacity Management command

**Definition**

::

  struct nvme_capacity_mgmt_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 cdw11;
    __u32 cdw12;
    __u16 element_id;
    __u8 op;
  };

**Members**

``result``
  If successful, the CQE dword0 value

``args_size``
  Size of :c:type:`struct nvme_capacity_mgmt_args <nvme_capacity_mgmt_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``cdw11``
  Least significant 32 bits of the capacity in bytes of the
  Endurance Group or NVM Set to be created

``cdw12``
  Most significant 32 bits of the capacity in bytes of the
  Endurance Group or NVM Set to be created

``element_id``
  Value specific to the value of the Operation field

``op``
  Operation to be performed by the controller



.. c:function:: int nvme_capacity_mgmt (struct nvme_capacity_mgmt_args *args)


**Parameters**

``struct nvme_capacity_mgmt_args *args``
  :c:type:`struct nvme_capacity_mgmt_args <nvme_capacity_mgmt_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_lockdown_args

   Arguments for the NVME Lockdown command

**Definition**

::

  struct nvme_lockdown_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u8 scp;
    __u8 prhbt;
    __u8 ifc;
    __u8 ofi;
    __u8 uuidx;
  };

**Members**

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_lockdown_args <nvme_lockdown_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms (0 for default timeout)

``scp``
  Scope of the command

``prhbt``
  Prohibit or allow the command opcode or Set Features command

``ifc``
  Affected interface

``ofi``
  Opcode or Feature Identifier

``uuidx``
  UUID Index if controller supports this id selection method



.. c:function:: int nvme_lockdown (struct nvme_lockdown_args *args)

   Issue lockdown command

**Parameters**

``struct nvme_lockdown_args *args``
  :c:type:`struct nvme_lockdown_args <nvme_lockdown_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_set_property_args

   Arguments for NVMe Set Property command

**Definition**

::

  struct nvme_set_property_args {
    __u64 value;
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    int offset;
  };

**Members**

``value``
  The value to set the property

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_set_property_args <nvme_set_property_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``offset``
  Property offset from the base to set



.. c:function:: int nvme_set_property (struct nvme_set_property_args *args)

   Set controller property

**Parameters**

``struct nvme_set_property_args *args``
  :c:type:`struct nvme_set_property_args <nvme_set_property_args>` argument structure

**Description**

This is an NVMe-over-Fabrics specific command, not applicable to PCIe. These
properties align to the PCI MMIO controller registers.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_get_property_args

   Arguments for NVMe Get Property command

**Definition**

::

  struct nvme_get_property_args {
    __u64 *value;
    int args_size;
    int fd;
    __u32 timeout;
    int offset;
  };

**Members**

``value``
  Where the property's value will be stored on success

``args_size``
  Size of :c:type:`struct nvme_get_property_args <nvme_get_property_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``offset``
  Property offset from the base to retrieve



.. c:function:: int nvme_get_property (struct nvme_get_property_args *args)

   Get a controller property

**Parameters**

``struct nvme_get_property_args *args``
  :c:type:`struct nvme_get_propert_args <nvme_get_propert_args>` argument structure

**Description**

This is an NVMe-over-Fabrics specific command, not applicable to PCIe. These
properties align to the PCI MMIO controller registers.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_sanitize_nvm_args

   Arguments for the NVMe Sanitize NVM command

**Definition**

::

  struct nvme_sanitize_nvm_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    enum nvme_sanitize_sanact sanact;
    __u32 ovrpat;
    bool ause;
    __u8 owpass;
    bool oipbp;
    bool nodas;
  };

**Members**

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_sanitize_nvm_args <nvme_sanitize_nvm_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``sanact``
  Sanitize action, see :c:type:`enum nvme_sanitize_sanact <nvme_sanitize_sanact>`

``ovrpat``
  Overwrite pattern

``ause``
  Set to allow unrestriced sanitize exit

``owpass``
  Overwrite pass count

``oipbp``
  Set to overwrite invert pattern between passes

``nodas``
  Set to not deallocate blocks after sanitizing



.. c:function:: int nvme_sanitize_nvm (struct nvme_sanitize_nvm_args *args)

   Start a sanitize operation

**Parameters**

``struct nvme_sanitize_nvm_args *args``
  :c:type:`struct nvme_sanitize_nvm_args <nvme_sanitize_nvm_args>` argument structure

**Description**

A sanitize operation alters all user data in the NVM subsystem such that
recovery of any previous user data from any cache, the non-volatile media,
or any Controller Memory Buffer is not possible.

The Sanitize command starts a sanitize operation or to recover from a
previously failed sanitize operation. The sanitize operation types that may
be supported are Block Erase, Crypto Erase, and Overwrite. All sanitize
operations are processed in the background, i.e., completion of the sanitize
command does not indicate completion of the sanitize operation.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_dev_self_test_args

   Arguments for the NVMe Device Self Test command

**Definition**

::

  struct nvme_dev_self_test_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_dst_stc stc;
  };

**Members**

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_dev_self_test_args <nvme_dev_self_test_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID to test

``stc``
  Self test code, see :c:type:`enum nvme_dst_stc <nvme_dst_stc>`



.. c:function:: int nvme_dev_self_test (struct nvme_dev_self_test_args *args)

   Start or abort a self test

**Parameters**

``struct nvme_dev_self_test_args *args``
  :c:type:`struct nvme_dev_self_test <nvme_dev_self_test>` argument structure

**Description**

The Device Self-test command starts a device self-test operation or abort a
device self-test operation. A device self-test operation is a diagnostic
testing sequence that tests the integrity and functionality of the
controller and may include testing of the media associated with namespaces.
The controller may return a response to this command immediately while
running the self-test in the background.

Set the 'nsid' field to 0 to not include namepsaces in the test. Set to
0xffffffff to test all namespaces. All other values tests a specific
namespace, if present.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_virtual_mgmt_args

   Arguments for the NVMe Virtualization resource management command

**Definition**

::

  struct nvme_virtual_mgmt_args {
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    enum nvme_virt_mgmt_act act;
    enum nvme_virt_mgmt_rt rt;
    __u16 cntlid;
    __u16 nr;
  };

**Members**

``result``
  If successful, the CQE dword0

``args_size``
  Size of :c:type:`struct nvme_virtual_mgmt_args <nvme_virtual_mgmt_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``act``
  Virtual resource action, see :c:type:`enum nvme_virt_mgmt_act <nvme_virt_mgmt_act>`

``rt``
  Resource type to modify, see :c:type:`enum nvme_virt_mgmt_rt <nvme_virt_mgmt_rt>`

``cntlid``
  Controller id for which resources are bing modified

``nr``
  Number of resources being allocated or assigned



.. c:function:: int nvme_virtual_mgmt (struct nvme_virtual_mgmt_args *args)

   Virtualization resource management

**Parameters**

``struct nvme_virtual_mgmt_args *args``
  :c:type:`struct nvme_virtual_mgmt_args <nvme_virtual_mgmt_args>` argument structure

**Description**

The Virtualization Management command is supported by primary controllers
that support the Virtualization Enhancements capability. This command is
used for several functions:

     - Modifying Flexible Resource allocation for the primary controller
     - Assigning Flexible Resources for secondary controllers
     - Setting the Online and Offline state for secondary controllers

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_flush (int fd, __u32 nsid)

   Send an nvme flush command

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace identifier

**Description**

The Flush command requests that the contents of volatile write cache be made
non-volatile.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_io_args

   Arguments for NVMe I/O commands

**Definition**

::

  struct nvme_io_args {
    __u64 slba;
    __u64 storage_tag;
    __u32 *result;
    void *data;
    void *metadata;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 reftag;
    __u32 data_len;
    __u32 metadata_len;
    __u16 nlb;
    __u16 control;
    __u16 apptag;
    __u16 appmask;
    __u8 dsm;
    __u8 dspec;
  };

**Members**

``slba``
  Starting logical block

``storage_tag``
  This filed specifies Variable Sized Expected Logical Block
  Storage Tag (ELBST) and Expected Logical Block Reference
  Tag (ELBRT)

``result``
  The command completion result from CQE dword0

``data``
  Pointer to user address of the data buffer

``metadata``
  Pointer to user address of the metadata buffer

``args_size``
  Size of :c:type:`struct nvme_io_args <nvme_io_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID

``reftag``
  This field specifies the Initial Logical Block Reference Tag
  expected value. Used only if the namespace is formatted to use
  end-to-end protection information.

``data_len``
  Length of user buffer, **data**, in bytes

``metadata_len``
  Length of user buffer, **metadata**, in bytes

``nlb``
  Number of logical blocks to send (0's based value)

``control``
  Command control flags, see :c:type:`enum nvme_io_control_flags <nvme_io_control_flags>`.

``apptag``
  This field specifies the Application Tag Mask expected value.
  Used only if the namespace is formatted to use end-to-end
  protection information.

``appmask``
  This field specifies the Application Tag expected value. Used
  only if the namespace is formatted to use end-to-end protection
  information.

``dsm``
  Data set management attributes, see :c:type:`enum nvme_io_dsm_flags <nvme_io_dsm_flags>`

``dspec``
  Directive specific value



.. c:function:: int nvme_io (struct nvme_io_args *args, __u8 opcode)

   Submit an nvme user I/O command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

``__u8 opcode``
  Opcode to execute

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_read (struct nvme_io_args *args)

   Submit an nvme user read command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_write (struct nvme_io_args *args)

   Submit an nvme user write command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_compare (struct nvme_io_args *args)

   Submit an nvme user compare command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_write_zeros (struct nvme_io_args *args)

   Submit an nvme write zeroes command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Description**

The Write Zeroes command sets a range of logical blocks to zero.  After
successful completion of this command, the value returned by subsequent
reads of logical blocks in this range shall be all bytes cleared to 0h until
a write occurs to this LBA range.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_write_uncorrectable (struct nvme_io_args *args)

   Submit an nvme write uncorrectable command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Description**

The Write Uncorrectable command marks a range of logical blocks as invalid.
When the specified logical block(s) are read after this operation, a failure
is returned with Unrecovered Read Error status. To clear the invalid logical
block status, a write operation on those logical blocks is required.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_verify (struct nvme_io_args *args)

   Send an nvme verify command

**Parameters**

``struct nvme_io_args *args``
  :c:type:`struct nvme_io_args <nvme_io_args>` argument structure

**Description**

The Verify command verifies integrity of stored information by reading data
and metadata, if applicable, for the LBAs indicated without transferring any
data or metadata to the host.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_dsm_args

   Arguments for the NVMe Dataset Management command

**Definition**

::

  struct nvme_dsm_args {
    __u32 *result;
    struct nvme_dsm_range *dsm;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 attrs;
    __u16 nr_ranges;
  };

**Members**

``result``
  The command completion result from CQE dword0

``dsm``
  The data set management attributes

``args_size``
  Size of :c:type:`struct nvme_dsm_args <nvme_dsm_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``attrs``
  DSM attributes, see :c:type:`enum nvme_dsm_attributes <nvme_dsm_attributes>`

``nr_ranges``
  Number of block ranges in the data set management attributes



.. c:function:: int nvme_dsm (struct nvme_dsm_args *args)

   Send an nvme data set management command

**Parameters**

``struct nvme_dsm_args *args``
  :c:type:`struct nvme_dsm_args <nvme_dsm_args>` argument structure

**Description**

The Dataset Management command is used by the host to indicate attributes
for ranges of logical blocks. This includes attributes like frequency that
data is read or written, access size, and other information that may be used
to optimize performance and reliability, and may be used to
deallocate/unmap/trim those logical blocks.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_copy_args

   Arguments for the NVMe Copy command

**Definition**

::

  struct nvme_copy_args {
    __u64 sdlba;
    __u32 *result;
    struct nvme_copy_range *copy;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 ilbrt;
    int lr;
    int fua;
    __u16 nr;
    __u16 dspec;
    __u16 lbatm;
    __u16 lbat;
    __u8 prinfor;
    __u8 prinfow;
    __u8 dtype;
    __u8 format;
  };

**Members**

``sdlba``
  Start destination LBA

``result``
  The command completion result from CQE dword0

``copy``
  Range descriptior

``args_size``
  Size of :c:type:`struct nvme_copy_args <nvme_copy_args>`

``fd``
  File descriptor of the nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``ilbrt``
  Initial logical block reference tag

``lr``
  Limited retry

``fua``
  Force unit access

``nr``
  Number of ranges

``dspec``
  Directive specific value

``lbatm``
  Logical block application tag mask

``lbat``
  Logical block application tag

``prinfor``
  Protection information field for read

``prinfow``
  Protection information field for write

``dtype``
  Directive type

``format``
  Descriptor format



.. c:function:: int nvme_copy (struct nvme_copy_args *args)


**Parameters**

``struct nvme_copy_args *args``
  :c:type:`struct nvme_copy_args <nvme_copy_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_resv_acquire_args

   Arguments for the NVMe Reservation Acquire Comand

**Definition**

::

  struct nvme_resv_acquire_args {
    __u64 crkey;
    __u64 nrkey;
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_resv_rtype rtype;
    enum nvme_resv_racqa racqa;
    bool iekey;
  };

**Members**

``crkey``
  The current reservation key associated with the host

``nrkey``
  The reservation key to be unregistered from the namespace if
  the action is preempt

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_resv_acquire_args <nvme_resv_acquire_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``rtype``
  The type of reservation to be create, see :c:type:`enum nvme_resv_rtype <nvme_resv_rtype>`

``racqa``
  The action that is performed by the command, see :c:type:`enum nvme_resv_racqa <nvme_resv_racqa>`

``iekey``
  Set to ignore the existing key



.. c:function:: int nvme_resv_acquire (struct nvme_resv_acquire_args *args)

   Send an nvme reservation acquire

**Parameters**

``struct nvme_resv_acquire_args *args``
  :c:type:`struct nvme_resv_acquire <nvme_resv_acquire>` argument structure

**Description**

The Reservation Acquire command acquires a reservation on a namespace,
preempt a reservation held on a namespace, and abort a reservation held on a
namespace.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_resv_register_args

   Arguments for the NVMe Reservation Register command

**Definition**

::

  struct nvme_resv_register_args {
    __u64 crkey;
    __u64 nrkey;
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_resv_rrega rrega;
    enum nvme_resv_cptpl cptpl;
    bool iekey;
  };

**Members**

``crkey``
  The current reservation key associated with the host

``nrkey``
  The new reservation key to be register if action is register or
  replace

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_resv_register_args <nvme_resv_register_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``rrega``
  The registration action, see :c:type:`enum nvme_resv_rrega <nvme_resv_rrega>`

``cptpl``
  Change persist through power loss, see :c:type:`enum nvme_resv_cptpl <nvme_resv_cptpl>`

``iekey``
  Set to ignore the existing key



.. c:function:: int nvme_resv_register (struct nvme_resv_register_args *args)

   Send an nvme reservation register

**Parameters**

``struct nvme_resv_register_args *args``
  :c:type:`struct nvme_resv_register_args <nvme_resv_register_args>` argument structure

**Description**

The Reservation Register command registers, unregisters, or replaces a
reservation key.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_resv_release_args

   Arguments for the NVMe Reservation Release Command

**Definition**

::

  struct nvme_resv_release_args {
    __u64 crkey;
    __u32 *result;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_resv_rtype rtype;
    enum nvme_resv_rrela rrela;
    bool iekey;
  };

**Members**

``crkey``
  The current reservation key to release

``result``
  The command completion result from CQE dword0

``args_size``
  Size of :c:type:`struct nvme_resv_release_args <nvme_resv_release_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``rtype``
  The type of reservation to be create, see :c:type:`enum nvme_resv_rtype <nvme_resv_rtype>`

``rrela``
  Reservation releast action, see :c:type:`enum nvme_resv_rrela <nvme_resv_rrela>`

``iekey``
  Set to ignore the existing key



.. c:function:: int nvme_resv_release (struct nvme_resv_release_args *args)

   Send an nvme reservation release

**Parameters**

``struct nvme_resv_release_args *args``
  :c:type:`struct nvme_resv_release_args <nvme_resv_release_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_resv_report_args

   Arguments for the NVMe Reservation Report command

**Definition**

::

  struct nvme_resv_report_args {
    __u32 *result;
    struct nvme_resv_status *report;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 len;
    bool eds;
  };

**Members**

``result``
  The command completion result from CQE dword0

``report``
  The user space destination address to store the reservation
  report

``args_size``
  Size of :c:type:`struct nvme_resv_report_args <nvme_resv_report_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace identifier

``len``
  Number of bytes to request transfered with this command

``eds``
  Request extended Data Structure



.. c:function:: int nvme_resv_report (struct nvme_resv_report_args *args)

   Send an nvme reservation report

**Parameters**

``struct nvme_resv_report_args *args``
  struct nvme_resv_report_args argument structure

**Description**

Returns a Reservation Status data structure to memory that describes the
registration and reservation status of a namespace. See the defintion for
the returned structure, :c:type:`struct nvme_reservation_status <nvme_reservation_status>`, for more details.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_zns_mgmt_send_args

   Arguments for the NVMe ZNS Management Send command

**Definition**

::

  struct nvme_zns_mgmt_send_args {
    __u64 slba;
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_zns_send_action zsa;
    __u32 data_len;
    bool select_all;
    __u8 zsaso;
  };

**Members**

``slba``
  Starting logical block address

``result``
  The command completion result from CQE dword0

``data``
  Userspace address of the data

``args_size``
  Size of :c:type:`struct nvme_zns_mgmt_send_args <nvme_zns_mgmt_send_args>`

``fd``
  File descriptor of nvme device

``timeout``
  timeout in ms

``nsid``
  Namespace ID

``zsa``
  Zone send action

``data_len``
  Length of **data**

``select_all``
  Select all flag

``zsaso``
  Zone Send Action Specific Option



.. c:function:: int nvme_zns_mgmt_send (struct nvme_zns_mgmt_send_args *args)


**Parameters**

``struct nvme_zns_mgmt_send_args *args``
  :c:type:`struct nvme_zns_mgmt_send_args <nvme_zns_mgmt_send_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_zns_mgmt_recv_args

   Arguments for the NVMe ZNS Management Receive command

**Definition**

::

  struct nvme_zns_mgmt_recv_args {
    __u64 slba;
    __u32 *result;
    void *data;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    enum nvme_zns_recv_action zra;
    __u32 data_len;
    __u16 zrasf;
    bool zras_feat;
  };

**Members**

``slba``
  Starting logical block address

``result``
  The command completion result from CQE dword0

``data``
  Userspace address of the data

``args_size``
  Size of :c:type:`struct nvme_zns_mgmt_recv_args <nvme_zns_mgmt_recv_args>`

``fd``
  File descriptor of nvme device

``timeout``
  timeout in ms

``nsid``
  Namespace ID

``zra``
  zone receive action

``data_len``
  Length of **data**

``zrasf``
  Zone receive action specific field

``zras_feat``
  Zone receive action specific features



.. c:function:: int nvme_zns_mgmt_recv (struct nvme_zns_mgmt_recv_args *args)


**Parameters**

``struct nvme_zns_mgmt_recv_args *args``
  :c:type:`struct nvme_zns_mgmt_recv_args <nvme_zns_mgmt_recv_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_zns_report_zones (int fd, __u32 nsid, __u64 slba, enum nvme_zns_report_options opts, bool extended, bool partial, __u32 data_len, void *data, __u32 timeout, __u32 *result)

   Return the list of zones

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID

``__u64 slba``
  Starting LBA

``enum nvme_zns_report_options opts``
  Reporting options

``bool extended``
  Extended report

``bool partial``
  Partial report requested

``__u32 data_len``
  Length of the data buffer

``void *data``
  Userspace address of the report zones data

``__u32 timeout``
  timeout in ms

``__u32 *result``
  The command completion result from CQE dword0

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.




.. c:struct:: nvme_zns_append_args

   Arguments for the NVMe ZNS Append command

**Definition**

::

  struct nvme_zns_append_args {
    __u64 zslba;
    __u64 *result;
    void *data;
    void *metadata;
    int args_size;
    int fd;
    __u32 timeout;
    __u32 nsid;
    __u32 ilbrt;
    __u32 data_len;
    __u32 metadata_len;
    __u16 nlb;
    __u16 control;
    __u16 lbat;
    __u16 lbatm;
  };

**Members**

``zslba``
  Zone start logical block address

``result``
  The command completion result from CQE dword0

``data``
  Userspace address of the data

``metadata``
  Userspace address of the metadata

``args_size``
  Size of :c:type:`struct nvme_zns_append_args <nvme_zns_append_args>`

``fd``
  File descriptor of nvme device

``timeout``
  Timeout in ms

``nsid``
  Namespace ID

``ilbrt``
  Initial logical block reference tag

``data_len``
  Length of **data**

``metadata_len``
  Length of **metadata**

``nlb``
  Number of logical blocks

``control``

``lbat``
  Logical block application tag

``lbatm``
  Logical block application tag mask



.. c:function:: int nvme_zns_append (struct nvme_zns_append_args *args)

   Append data to a zone

**Parameters**

``struct nvme_zns_append_args *args``
  :c:type:`struct nvme_zns_append_args <nvme_zns_append_args>` argument structure

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. _linux.h:

**linux.h**


linux-specific utility functions

.. c:function:: int nvme_fw_download_seq (int fd, __u32 size, __u32 xfer, __u32 offset, void *buf)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 size``
  Total size of the firmware image to transfer

``__u32 xfer``
  Maximum size to send with each partial transfer

``__u32 offset``
  Starting offset to send with this firmware downlaod

``void *buf``
  Address of buffer containing all or part of the firmware image.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_ctrl_telemetry (int fd, bool rae, struct nvme_telemetry_log **log)


**Parameters**

``int fd``
  File descriptor of nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_telemetry_log **log``
  On success, set to the value of the allocated and retreived log.

**Description**

The total size allocated can be calculated as:
  (:c:type:`struct nvme_telemetry_log <nvme_telemetry_log>`.dalb3 + 1) * ``NVME_LOG_TELEM_BLOCK_SIZE``.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_host_telemetry (int fd, struct nvme_telemetry_log **log)


**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_telemetry_log **log``
  On success, set to the value of the allocated and retreived log.

**Description**

The total size allocated can be calculated as:
  (:c:type:`struct nvme_telemetry_log <nvme_telemetry_log>`.dalb3 + 1) * ``NVME_LOG_TELEM_BLOCK_SIZE``.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_new_host_telemetry (int fd, struct nvme_telemetry_log **log)


**Parameters**

``int fd``
  File descriptor of nvme device

``struct nvme_telemetry_log **log``
  On success, set to the value of the allocated and retreived log.

**Description**

The total size allocated can be calculated as:
  (:c:type:`struct nvme_telemetry_log <nvme_telemetry_log>`.dalb3 + 1) * ``NVME_LOG_TELEM_BLOCK_SIZE``.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_page (int fd, __u32 nsid, __u8 log_id, bool rae, __u32 xfer_len, __u32 data_len, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace Identifier, if applicable.

``__u8 log_id``
  Log Identifier, see :c:type:`enum nvme_cmd_get_log_lid <nvme_cmd_get_log_lid>`.

``bool rae``
  Retain asynchronous events

``__u32 xfer_len``
  Max log transfer size per request to split the total.

``__u32 data_len``
  Total length of the log to transfer.

``void *data``
  User address of at least :c:type:`data_len` to store the log.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_log_page_padded (int fd, __u32 nsid, __u8 log_id, bool rae, __u32 data_len, void *data)


**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace Identifier, if applicable.

``__u8 log_id``
  Log Identifier, see :c:type:`enum nvme_cmd_get_log_lid <nvme_cmd_get_log_lid>`.

``bool rae``
  Retain asynchronous events

``__u32 data_len``
  Total length of the log to transfer.

``void *data``
  User address of at least :c:type:`data_len` to store the log.

**Description**

Calls nvme_get_log_page() with a default 4k transfer length, as that is
guarnateed by the protocol to be a safe transfer size.

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_ana_log_len (int fd, size_t *analen)

   Retreive size of the current ANA log

**Parameters**

``int fd``
  File descriptor of nvme device

``size_t *analen``
  Pointer to where the length will be set on success

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_logical_block_size (int fd, __u32 nsid, int *blksize)

   Retrieve block size

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace id

``int *blksize``
  Pointer to where the block size will be set on success

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_get_lba_status_log (int fd, bool rae, struct nvme_lba_status_log **log)

   Retreive the LBA Status log page

**Parameters**

``int fd``
  File descriptor of the nvme device

``bool rae``
  Retain asynchronous events

``struct nvme_lba_status_log **log``
  On success, set to the value of the allocated and retreived log.


.. c:function:: int nvme_namespace_attach_ctrls (int fd, __u32 nsid, __u16 num_ctrls, __u16 *ctrlist)

   Attach namespace to controller(s)

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID to attach

``__u16 num_ctrls``
  Number of controllers in ctrlist

``__u16 *ctrlist``
  List of controller IDs to perform the attach action

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_namespace_detach_ctrls (int fd, __u32 nsid, __u16 num_ctrls, __u16 *ctrlist)

   Detach namespace from controller(s)

**Parameters**

``int fd``
  File descriptor of nvme device

``__u32 nsid``
  Namespace ID to detach

``__u16 num_ctrls``
  Number of controllers in ctrlist

``__u16 *ctrlist``
  List of controller IDs to perform the detach action

**Return**

The nvme command status if a response was received (see
:c:type:`enum nvme_status_field <nvme_status_field>`) or -1 with errno set otherwise.


.. c:function:: int nvme_open (const char *name)

   Open an nvme controller or namespace device

**Parameters**

``const char *name``
  The basename of the device to open

**Description**

This will look for the handle in /dev/ and validate the name and filetype
match linux conventions.

**Return**

A file descriptor for the device on a successful open, or -1 with
errno set otherwise.




.. c:enum:: nvme_hmac_alg

   HMAC algorithm

**Constants**

``NVME_HMAC_ALG_NONE``
  No HMAC algorithm

``NVME_HMAC_ALG_SHA2_256``
  SHA2-256

``NVME_HMAC_ALG_SHA2_384``
  SHA2-384

``NVME_HMAC_ALG_SHA2_512``
  SHA2-512


.. c:function:: int nvme_gen_dhchap_key (char *hostnqn, enum nvme_hmac_alg hmac, unsigned int key_len, unsigned char *secret, unsigned char *key)

   DH-HMAC-CHAP key generation

**Parameters**

``char *hostnqn``
  Host NVMe Qualified Name

``enum nvme_hmac_alg hmac``
  HMAC algorithm

``unsigned int key_len``
  Output key lenght

``unsigned char *secret``
  Secret to used for digest

``unsigned char *key``
  Generated DH-HMAC-CHAP key

**Return**

If key generation was successful the function returns 0 or
-1 with errno set otherwise.


.. _log.h:

**log.h**


logging functions

.. c:function:: void nvme_init_logging (nvme_root_t r, int lvl, bool log_pid, bool log_tstamp)

   initialize logging

**Parameters**

``nvme_root_t r``
  nvme_root_t context

``int lvl``
  logging level to set

``bool log_pid``
  boolean to enable logging of the PID

``bool log_tstamp``
  boolean to enable logging of the timestamp

**Description**

Sets the default logging variables for the library.


.. _tree.h:

**tree.h**


libnvme tree object interface

.. c:function:: nvme_root_t nvme_create_root (FILE *fp, int log_level)

   Initialize root object

**Parameters**

``FILE *fp``
  filedescriptor for logging messages

``int log_level``
  logging level to use

**Return**

initialized nvme_root_t object


.. c:function:: void nvme_free_tree (nvme_root_t r)

   Free root object

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Description**

Free an nvme_root_t object and all attached objects


.. c:function:: nvme_host_t nvme_first_host (nvme_root_t r)

   Start host iterator

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Return**

first nvme_host_t object in an iterator


.. c:function:: nvme_host_t nvme_next_host (nvme_root_t r, nvme_host_t h)

   Next host iterator

**Parameters**

``nvme_root_t r``
  nvme_root_t object

``nvme_host_t h``
  previous nvme_host_t iterator

**Return**

next nvme_host_t object in an iterator


.. c:function:: nvme_root_t nvme_host_get_root (nvme_host_t h)

   Returns nvme_root_t object

**Parameters**

``nvme_host_t h``
  host

**Return**

nvme_root_t object from **h**


.. c:function:: nvme_host_t nvme_lookup_host (nvme_root_t r, const char *hostnqn, const char *hostid)

   Lookup nvme_host_t object

**Parameters**

``nvme_root_t r``
  nvme_root_t object

``const char *hostnqn``
  Host NQN

``const char *hostid``
  Host ID

**Description**

Lookup a nvme_host_t object based on **hostnqn** and **hostid**
or create one if not found.

**Return**

nvme_host_t object


.. c:function:: const char * nvme_host_get_dhchap_key (nvme_host_t h)

   return host key

**Parameters**

``nvme_host_t h``
  Host for which the key should be returned

**Return**

DH-HMAC-CHAP host key or NULL if not set


.. c:function:: void nvme_host_set_dhchap_key (nvme_host_t h, const char *key)

   set host key

**Parameters**

``nvme_host_t h``
  Host for which the key should be set

``const char *key``
  DH-HMAC-CHAP Key to set or NULL to clear existing key


.. c:function:: nvme_host_t nvme_default_host (nvme_root_t r)

   Initializes the default host

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Description**

Initializes the default host object based on the values in
/etc/nvme/hostnqn and /etc/nvme/hostid and attaches it to **r**.

**Return**

nvme_host_t object


.. c:function:: nvme_subsystem_t nvme_first_subsystem (nvme_host_t h)

   Start subsystem iterator

**Parameters**

``nvme_host_t h``
  nvme_host_t object

**Return**

first nvme_subsystem_t object in an iterator


.. c:function:: nvme_subsystem_t nvme_next_subsystem (nvme_host_t h, nvme_subsystem_t s)

   Next subsystem iterator

**Parameters**

``nvme_host_t h``
  nvme_host_t object

``nvme_subsystem_t s``
  previous nvme_subsystem_t iterator

**Return**

next nvme_subsystem_t object in an iterator


.. c:function:: nvme_subsystem_t nvme_lookup_subsystem (struct nvme_host *h, const char *name, const char *subsysnqn)

   Lookup nvme_subsystem_t object

**Parameters**

``struct nvme_host *h``
  nvme_host_t object

``const char *name``
  Name of the subsystem (may be NULL)

``const char *subsysnqn``
  Subsystem NQN

**Description**

Lookup a nvme_subsystem_t object in **h** base on **name** (if present)
and **subsystemnqn** or create one if not found.

**Return**

nvme_subsystme_t object


.. c:function:: void nvme_free_subsystem (struct nvme_subsystem *s)

   Free a subsystem

**Parameters**

``struct nvme_subsystem *s``
  subsystem

**Description**

Frees **s** and all related objects.


.. c:function:: nvme_host_t nvme_subsystem_get_host (nvme_subsystem_t s)

   Returns nvme_host_t object

**Parameters**

``nvme_subsystem_t s``
  subsystem

**Return**

nvme_host_t object from **s**


.. c:function:: nvme_ns_t nvme_ctrl_first_ns (nvme_ctrl_t c)

   Start namespace iterator

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

first nvme_ns_t object of an **c** iterator


.. c:function:: nvme_ns_t nvme_ctrl_next_ns (nvme_ctrl_t c, nvme_ns_t n)

   Next namespace iterator

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``nvme_ns_t n``
  previous nvme_ns_t iterator

**Return**

next nvme_ns_t object of an **c** iterator


.. c:function:: nvme_path_t nvme_ctrl_first_path (nvme_ctrl_t c)

   Start path iterator

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

First nvme_path_t object of an **c** iterator


.. c:function:: nvme_path_t nvme_ctrl_next_path (nvme_ctrl_t c, nvme_path_t p)

   Next path iterator

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``nvme_path_t p``
  previous nvme_path_t object of an **c** iterator


.. c:function:: nvme_ctrl_t nvme_subsystem_first_ctrl (nvme_subsystem_t s)

   First ctrl iterator

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

**Return**

First nvme_ctrl_t object of an **s** iterator


.. c:function:: nvme_ctrl_t nvme_subsystem_next_ctrl (nvme_subsystem_t s, nvme_ctrl_t c)

   Next ctrl iterator

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

``nvme_ctrl_t c``
  previous nvme_ctrl_t object of an **s** iterator

**Return**

next nvme_ctrl_t object of an **s** iterator


.. c:function:: nvme_ctrl_t nvme_lookup_ctrl (nvme_subsystem_t s, const char *transport, const char *traddr, const char *host_traddr, const char *host_iface, const char *trsvcid, nvme_ctrl_t p)

   Lookup nvme_ctrl_t object

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

``const char *transport``
  transport name

``const char *traddr``
  transport address

``const char *host_traddr``
  host transport address

``const char *host_iface``
  host interface name

``const char *trsvcid``
  transport service identifier

``nvme_ctrl_t p``
  previous nvme_ctrl_t object

**Description**

Lookup a nvme_ctrl_t object in **s** based on **transport**, **traddr**,
**host_traddr**, **host_iface**, and **trsvcid**. **transport** must be specified,
other fields may be required depending on the transport. A new
object is created if none is found. If **p** is specified the lookup
will start at **p** instead of the first controller.

**Return**

nvme_ctrl_t object


.. c:function:: nvme_ctrl_t nvme_create_ctrl (nvme_root_t r, const char *subsysnqn, const char *transport, const char *traddr, const char *host_traddr, const char *host_iface, const char *trsvcid)

   Allocate an unconnected NVMe controller

**Parameters**

``nvme_root_t r``
  NVMe root element

``const char *subsysnqn``
  Subsystem NQN

``const char *transport``
  Transport type

``const char *traddr``
  Transport address

``const char *host_traddr``
  Host transport address

``const char *host_iface``
  Host interface name

``const char *trsvcid``
  Transport service ID

**Description**

Creates an unconnected nvme_ctrl_t object to be used for
nvme_add_ctrl().

**Return**

nvme_ctrl_t object


.. c:function:: nvme_ns_t nvme_subsystem_first_ns (nvme_subsystem_t s)

   Start namespace iterator

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

**Return**

First nvme_ns_t object of an **s** iterator


.. c:function:: nvme_ns_t nvme_subsystem_next_ns (nvme_subsystem_t s, nvme_ns_t n)

   Next namespace iterator

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

``nvme_ns_t n``
  previous nvme_ns_t iterator

**Return**

Next nvme_ns_t object of an **s** iterator


.. c:macro:: nvme_for_each_host_safe

``nvme_for_each_host_safe (r, h, _h)``

   Traverse host list

**Parameters**

``r``
  nvme_root_t object

``h``
  nvme_host_t object

``_h``
  temporary nvme_host_t object


.. c:macro:: nvme_for_each_host

``nvme_for_each_host (r, h)``

   Traverse host list

**Parameters**

``r``
  nvme_root_t object

``h``
  nvme_host_t object


.. c:macro:: nvme_for_each_subsystem_safe

``nvme_for_each_subsystem_safe (h, s, _s)``

   Traverse subsystems

**Parameters**

``h``
  nvme_host_t object

``s``
  nvme_subsystem_t object

``_s``
  temporary nvme_subsystem_t object


.. c:macro:: nvme_for_each_subsystem

``nvme_for_each_subsystem (h, s)``

   Traverse subsystems

**Parameters**

``h``
  nvme_host_t object

``s``
  nvme_subsystem_t object


.. c:macro:: nvme_subsystem_for_each_ctrl_safe

``nvme_subsystem_for_each_ctrl_safe (s, c, _c)``

   Traverse controllers

**Parameters**

``s``
  nvme_subsystem_t object

``c``
  nvme_ctrl_t object

``_c``
  temporary nvme_ctrl_t object


.. c:macro:: nvme_subsystem_for_each_ctrl

``nvme_subsystem_for_each_ctrl (s, c)``

   traverse controllers

**Parameters**

``s``
  nvme_subsystem_t object

``c``
  nvme_ctrl_t object


.. c:macro:: nvme_ctrl_for_each_ns_safe

``nvme_ctrl_for_each_ns_safe (c, n, _n)``

   traverse namespaces

**Parameters**

``c``
  nvme_ctrl_t object

``n``
  nvme_ns_t object

``_n``
  temporary nvme_ns_t object


.. c:macro:: nvme_ctrl_for_each_ns

``nvme_ctrl_for_each_ns (c, n)``

   traverse namespaces

**Parameters**

``c``
  nvme_ctrl_t object

``n``
  nvme_ns_t object


.. c:macro:: nvme_ctrl_for_each_path_safe

``nvme_ctrl_for_each_path_safe (c, p, _p)``

   Traverse paths

**Parameters**

``c``
  nvme_ctrl_t object

``p``
  nvme_path_t object

``_p``
  temporary nvme_path_t object


.. c:macro:: nvme_ctrl_for_each_path

``nvme_ctrl_for_each_path (c, p)``

   Traverse paths

**Parameters**

``c``
  nvme_ctrl_t object

``p``
  nvme_path_t object


.. c:macro:: nvme_subsystem_for_each_ns_safe

``nvme_subsystem_for_each_ns_safe (s, n, _n)``

   Traverse namespaces

**Parameters**

``s``
  nvme_subsystem_t object

``n``
  nvme_ns_t object

``_n``
  temporary nvme_ns_t object


.. c:macro:: nvme_subsystem_for_each_ns

``nvme_subsystem_for_each_ns (s, n)``

   Traverse namespaces

**Parameters**

``s``
  nvme_subsystem_t object

``n``
  nvme_ns_t object


.. c:function:: int nvme_ns_get_fd (nvme_ns_t n)

   Get associated filedescriptor

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

Filedescriptor associated with **n** or -1


.. c:function:: int nvme_ns_get_nsid (nvme_ns_t n)

   NSID of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

NSID of **n**


.. c:function:: int nvme_ns_get_lba_size (nvme_ns_t n)

   LBA size of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

LBA size of **n**


.. c:function:: int nvme_ns_get_meta_size (nvme_ns_t n)

   Metadata size of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

Metadata size of **n**


.. c:function:: uint64_t nvme_ns_get_lba_count (nvme_ns_t n)

   LBA count of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

LBA count of **n**


.. c:function:: uint64_t nvme_ns_get_lba_util (nvme_ns_t n)

   LBA utilisation of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

LBA utilisation of **n**


.. c:function:: enum nvme_csi nvme_ns_get_csi (nvme_ns_t n)

   Command set identifier of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

The namespace's command set identifier in use


.. c:function:: const uint8_t * nvme_ns_get_eui64 (nvme_ns_t n)

   64-bit eui of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Description**

Returns a pointer to the 64-bit eui


.. c:function:: const uint8_t * nvme_ns_get_nguid (nvme_ns_t n)

   128-bit nguid of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Description**

Returns a pointer to the 128-bit nguid


.. c:function:: void nvme_ns_get_uuid (nvme_ns_t n, uuid_t out)

   UUID of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``uuid_t out``
  buffer for the UUID

**Description**

Copies the namespace's uuid into **out**


.. c:function:: const char * nvme_ns_get_sysfs_dir (nvme_ns_t n)

   sysfs directory of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

sysfs directory name of **n**


.. c:function:: const char * nvme_ns_get_name (nvme_ns_t n)

   sysfs name of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

sysfs name of **n**


.. c:function:: const char * nvme_ns_get_generic_name (nvme_ns_t n)

   Returns name of generic namesapce chardev.

**Parameters**

``nvme_ns_t n``
  Namespace instance

**Return**

Name of generic namespace chardev


.. c:function:: const char * nvme_ns_get_firmware (nvme_ns_t n)

   Firmware string of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

Firmware string of **n**


.. c:function:: const char * nvme_ns_get_serial (nvme_ns_t n)

   Serial number of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

Serial number string of **n**


.. c:function:: const char * nvme_ns_get_model (nvme_ns_t n)

   Model of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

Model string of **n**


.. c:function:: nvme_subsystem_t nvme_ns_get_subsystem (nvme_ns_t n)

   nvme_subsystem_t of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

nvme_subsystem_t object of **n**


.. c:function:: nvme_ctrl_t nvme_ns_get_ctrl (nvme_ns_t n)

   nvme_ctrl_t of an nvme_ns_t object

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Description**

nvme_ctrl_t object may be NULL for a multipathed namespace

**Return**

nvme_ctrl_t object of **n** if present


.. c:function:: void nvme_free_ns (struct nvme_ns *n)

   free an nvme_ns_t object

**Parameters**

``struct nvme_ns *n``
  nvme_ns_t object


.. c:function:: int nvme_ns_read (nvme_ns_t n, void *buf, off_t offset, size_t count)

   Read from a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``void *buf``
  buffer into which the data will be transferred

``off_t offset``
  LBA offset of **n**

``size_t count``
  Number of sectors in **buf**

**Return**

Number of sectors read or -1 on error.


.. c:function:: int nvme_ns_write (nvme_ns_t n, void *buf, off_t offset, size_t count)

   Write to a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``void *buf``
  buffer with data to be written

``off_t offset``
  LBA offset of **n**

``size_t count``
  Number of sectors in **buf**

**Return**

Number of sectors written or -1 on error


.. c:function:: int nvme_ns_verify (nvme_ns_t n, off_t offset, size_t count)

   Verify data on a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``off_t offset``
  LBA offset of **n**

``size_t count``
  Number of sectors to be verified

**Return**

Number of sectors verified


.. c:function:: int nvme_ns_compare (nvme_ns_t n, void *buf, off_t offset, size_t count)

   Compare data on a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``void *buf``
  buffer with data to be compared

``off_t offset``
  LBA offset of **n**

``size_t count``
  Number of sectors in **buf**

**Return**

Number of sectors compared


.. c:function:: int nvme_ns_write_zeros (nvme_ns_t n, off_t offset, size_t count)

   Write zeros to a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``off_t offset``
  LBA offset in **n**

``size_t count``
  Number of sectors to be written

**Return**

Number of sectors written


.. c:function:: int nvme_ns_write_uncorrectable (nvme_ns_t n, off_t offset, size_t count)

   Issus a 'write uncorrectable' command

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``off_t offset``
  LBA offset in **n**

``size_t count``
  Number of sectors to be written

**Return**

Number of sectors written


.. c:function:: int nvme_ns_flush (nvme_ns_t n)

   Flush data to a namespace

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

**Return**

0 on success, -1 on error.


.. c:function:: int nvme_ns_identify (nvme_ns_t n, struct nvme_id_ns *ns)

   Issue an 'identify namespace' command

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``struct nvme_id_ns *ns``
  nvme_id_ns buffer

**Description**

Writes the data returned by the 'identify namespace' command
into **ns**.

**Return**

0 on success, -1 on error.


.. c:function:: int nvme_ns_identify_descs (nvme_ns_t n, struct nvme_ns_id_desc *descs)

   Issue an 'identify descriptors' command

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``struct nvme_ns_id_desc *descs``
  list of identify descriptors

**Description**

Writes the data returned by the 'identify descriptors' command
into **descs**.

**Return**

0 on success, -1 on error.


.. c:function:: const char * nvme_path_get_name (nvme_path_t p)

   sysfs name of an nvme_path_t object

**Parameters**

``nvme_path_t p``
  nvme_path_t object

**Return**

sysfs name of **p**


.. c:function:: const char * nvme_path_get_sysfs_dir (nvme_path_t p)

   sysfs directory of an nvme_path_t object

**Parameters**

``nvme_path_t p``
  nvme_path_t object

**Return**

sysfs directory of **p**


.. c:function:: const char * nvme_path_get_ana_state (nvme_path_t p)

   ANA state of an nvme_path_t object

**Parameters**

``nvme_path_t p``
  nvme_path_t object

**Return**

ANA (Asynchronous Namespace Access) state of **p**


.. c:function:: nvme_ctrl_t nvme_path_get_ctrl (nvme_path_t p)

   parent controller of an nvme_path_t object

**Parameters**

``nvme_path_t p``
  nvme_path_t object

**Return**

parent controller if present


.. c:function:: nvme_ns_t nvme_path_get_ns (nvme_path_t p)

   parent namespace of an nvme_path_t object

**Parameters**

``nvme_path_t p``
  nvme_path_t object

**Return**

parent namespace if present


.. c:function:: int nvme_ctrl_get_fd (nvme_ctrl_t c)

   Get associated filedescriptor

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Filedescriptor associated with **c** or -1


.. c:function:: const char * nvme_ctrl_get_name (nvme_ctrl_t c)

   sysfs name of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

sysfs name of **c**


.. c:function:: const char * nvme_ctrl_get_sysfs_dir (nvme_ctrl_t c)

   sysfs directory of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

sysfs directory name of **c**


.. c:function:: const char * nvme_ctrl_get_address (nvme_ctrl_t c)

   Address string of an nvme_ctrl_t

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

NVMe-over-Fabrics address string of **c** or empty string
of no address is present.


.. c:function:: const char * nvme_ctrl_get_firmware (nvme_ctrl_t c)

   Firmware string of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Firmware string of **c**


.. c:function:: const char * nvme_ctrl_get_model (nvme_ctrl_t c)

   Model of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Model string of **c**


.. c:function:: const char * nvme_ctrl_get_state (nvme_ctrl_t c)

   Running state of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

string indicating the running state of **c**


.. c:function:: const char * nvme_ctrl_get_numa_node (nvme_ctrl_t c)

   NUMA node of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

string indicating the NUMA node


.. c:function:: const char * nvme_ctrl_get_queue_count (nvme_ctrl_t c)

   Queue count of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Queue count of **c**


.. c:function:: const char * nvme_ctrl_get_serial (nvme_ctrl_t c)

   Serial number of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Serial number string of **c**


.. c:function:: const char * nvme_ctrl_get_sqsize (nvme_ctrl_t c)

   SQ size of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

SQ size (as string) of **c**


.. c:function:: const char * nvme_ctrl_get_transport (nvme_ctrl_t c)

   Transport type of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Transport type of **c**


.. c:function:: const char * nvme_ctrl_get_subsysnqn (nvme_ctrl_t c)

   Subsystem NQN of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Subsystem NQN of **c**


.. c:function:: nvme_subsystem_t nvme_ctrl_get_subsystem (nvme_ctrl_t c)

   Parent subsystem of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Parent nvme_subsystem_t object


.. c:function:: const char * nvme_ctrl_get_traddr (nvme_ctrl_t c)

   Transport address of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Transport address of **c**


.. c:function:: const char * nvme_ctrl_get_trsvcid (nvme_ctrl_t c)

   Transport service identifier of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Transport service identifier of **c** (if present)


.. c:function:: const char * nvme_ctrl_get_host_traddr (nvme_ctrl_t c)

   Host transport address of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Host transport address of **c** (if present)


.. c:function:: const char * nvme_ctrl_get_host_iface (nvme_ctrl_t c)

   Host interface name of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Host interface name of **c** (if present)


.. c:function:: const char * nvme_ctrl_get_dhchap_key (nvme_ctrl_t c)

   return controller key

**Parameters**

``nvme_ctrl_t c``
  controller for which the key should be returned

**Return**

DH-HMAC-CHAP controller key or NULL if not set


.. c:function:: void nvme_ctrl_set_dhchap_key (nvme_ctrl_t c, const char *key)

   set controller key

**Parameters**

``nvme_ctrl_t c``
  Controller for which the key should be set

``const char *key``
  DH-HMAC-CHAP Key to set or NULL to clear existing key


.. c:function:: struct nvme_fabrics_config * nvme_ctrl_get_config (nvme_ctrl_t c)

   Fabrics configuration of an nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Fabrics configuration of **c**


.. c:function:: void nvme_ctrl_set_discovered (nvme_ctrl_t c, bool discovered)

   Set the 'discovered' flag

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``bool discovered``
  value of the 'discovered' flag

**Description**

Set the 'discovered' flag of **c** to **discovered**


.. c:function:: bool nvme_ctrl_is_discovered (nvme_ctrl_t c)

   Returns the value of the 'discovered' flag

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Value of the 'discovered' flag of **c**


.. c:function:: void nvme_ctrl_set_persistent (nvme_ctrl_t c, bool persistent)

   Set the 'persistent' flag

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``bool persistent``
  value of the 'persistent' flag

**Description**

Set the 'persistent' flag of **c** to **persistent**


.. c:function:: bool nvme_ctrl_is_persistent (nvme_ctrl_t c)

   Returns the value of the 'persistent' flag

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Return**

Value of the 'persistent' flag of **c**


.. c:function:: void nvme_ctrl_set_discovery_ctrl (nvme_ctrl_t c, bool discovery)

   Set the 'discovery_ctrl' flag

**Parameters**

``nvme_ctrl_t c``
  Controller to be modified

``bool discovery``
  value of the discovery_ctrl flag

**Description**

Sets the 'discovery_ctrl' flag in **c** to specify whether
**c** connects to a discovery subsystem.


.. c:function:: bool nvme_ctrl_is_discovery_ctrl (nvme_ctrl_t c)

   Check the 'discovery_ctrl' flag

**Parameters**

``nvme_ctrl_t c``
  Controller to be checked

**Description**

Returns the value of the 'discovery_ctrl' flag which specifies whether
**c** connects to a discovery subsystem.

**Return**

value of the 'discover_ctrl' flag


.. c:function:: int nvme_ctrl_identify (nvme_ctrl_t c, struct nvme_id_ctrl *id)

   Issues an 'identify controller' command

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``struct nvme_id_ctrl *id``
  identify controller data structure

**Description**

Issues an 'identify controller' command to **c** and copies the
data into **id**.

**Return**

0 on success or -1 on failure.


.. c:function:: int nvme_disconnect_ctrl (nvme_ctrl_t c)

   Disconnect a controller

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

**Description**

Issues a 'disconnect' fabrics command to **c**

**Return**

0 on success, -1 on failure.


.. c:function:: nvme_ctrl_t nvme_scan_ctrl (nvme_root_t r, const char *name)

   Scan on a controller

**Parameters**

``nvme_root_t r``
  nvme_root_t object

``const char *name``
  name of the controller

**Description**

Scans a controller with sysfs name **name** and add it to **r**.

**Return**

nvme_ctrl_t object


.. c:function:: void nvme_rescan_ctrl (nvme_ctrl_t c)

   Rescan an existing nvme_ctrl_t object

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object


.. c:function:: int nvme_init_ctrl (nvme_host_t h, nvme_ctrl_t c, int instance)

   Initialize nvme_ctrl_t object for an existing nvme controller.

**Parameters**

``nvme_host_t h``
  nvme_host_t object

``nvme_ctrl_t c``
  nvme_ctrl_t object

``int instance``
  Instance number (e.g. 1 for nvme1)

**Return**

The ioctl() return code. Typically 0 on success.


.. c:function:: void nvme_free_ctrl (struct nvme_ctrl *c)


**Parameters**

``struct nvme_ctrl *c``


.. c:function:: void nvme_unlink_ctrl (struct nvme_ctrl *c)


**Parameters**

``struct nvme_ctrl *c``


.. c:function:: const char * nvme_subsystem_get_nqn (nvme_subsystem_t s)


**Parameters**

``nvme_subsystem_t s``


.. c:function:: const char * nvme_subsystem_get_sysfs_dir (nvme_subsystem_t s)

   sysfs directory of an nvme_subsystem_t object

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

**Return**

sysfs directory name of **s**


.. c:function:: const char * nvme_subsystem_get_name (nvme_subsystem_t s)

   sysfs name of an nvme_subsystem_t object

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

**Return**

sysfs name of **s**


.. c:function:: const char * nvme_subsystem_get_type (nvme_subsystem_t s)

   Returns the type of a subsystem

**Parameters**

``nvme_subsystem_t s``
  Subsystem

**Description**

Returns the subsystem type of **s**.

**Return**

'nvm' or 'discovery'


.. c:function:: int nvme_scan_topology (nvme_root_t r, nvme_scan_filter_t f)

   Scan NVMe topology and apply filter

**Parameters**

``nvme_root_t r``
  nvme_root_t object

``nvme_scan_filter_t f``
  filter to apply

**Description**

Scans the NVMe topology and filters out the resulting elements
by applying **f**.

**Return**

Number of elements scanned


.. c:function:: const char * nvme_host_get_hostnqn (nvme_host_t h)

   Host NQN of an nvme_host_t object

**Parameters**

``nvme_host_t h``
  nvme_host_t object

**Return**

Host NQN of **h**


.. c:function:: const char * nvme_host_get_hostid (nvme_host_t h)

   Host ID of an nvme_host_t object

**Parameters**

``nvme_host_t h``
  nvme_host_t object

**Return**

Host ID of **h**


.. c:function:: void nvme_free_host (nvme_host_t h)

   Free nvme_host_t object

**Parameters**

``nvme_host_t h``
  nvme_host_t object


.. c:function:: nvme_root_t nvme_scan (const char *config_file)

   Scan NVMe topology

**Parameters**

``const char *config_file``
  configuration file

**Return**

nvme_root_t object of found elements


.. c:function:: int nvme_read_config (nvme_root_t r, const char *config_file)

   Read NVMe json configuration file

**Parameters**

``nvme_root_t r``
  nvme_root_t object

``const char *config_file``
  json configuration file

**Description**

Read in the contents of **config_file** and merge them with
the elements in **r**.

**Return**

0 on success, -1 on failure with errno set.


.. c:function:: void nvme_refresh_topology (nvme_root_t r)

   refresh nvme_root_t object contents

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Description**

Removes all elements in **r** and rescans the existing topology.


.. c:function:: int nvme_update_config (nvme_root_t r)

   Update JSON configuration

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Description**

Updates the JSON configuration file with the contents of **r**.

**Return**

0 on success, -1 on failure.


.. c:function:: int nvme_dump_config (nvme_root_t r)

   Print the JSON configuration

**Parameters**

``nvme_root_t r``
  nvme_root_t object

**Description**

Prints the current contents of the JSON configuration
file to stdout.

**Return**

0 on success, -1 on failure.


.. c:function:: char * nvme_get_attr (const char *d, const char *attr)

   Read sysfs attribute

**Parameters**

``const char *d``
  sysfs directory

``const char *attr``
  sysfs attribute name

**Return**

string with the contents of **attr**


.. c:function:: char * nvme_get_subsys_attr (nvme_subsystem_t s, const char *attr)

   Read subsystem sysfs attribute

**Parameters**

``nvme_subsystem_t s``
  nvme_subsystem_t object

``const char *attr``
  sysfs attribute name

**Return**

string with the contents of **attr**


.. c:function:: char * nvme_get_ctrl_attr (nvme_ctrl_t c, const char *attr)

   Read controller sysfs attribute

**Parameters**

``nvme_ctrl_t c``
  nvme_ctrl_t object

``const char *attr``
  sysfs attribute name

**Return**

string with the contents of **attr**


.. c:function:: char * nvme_get_ns_attr (nvme_ns_t n, const char *attr)

   Read namespace sysfs attribute

**Parameters**

``nvme_ns_t n``
  nvme_ns_t object

``const char *attr``
  sysfs attribute name

**Return**

string with the contents of **attr**


.. c:function:: nvme_ns_t nvme_subsystem_lookup_namespace (struct nvme_subsystem *s, __u32 nsid)

   lookup namespace by NSID

**Parameters**

``struct nvme_subsystem *s``
  nvme_subsystem_t object

``__u32 nsid``
  namespace id

**Return**

nvme_ns_t of the namespace with id **nsid** in subsystem **s**


.. c:function:: char * nvme_get_path_attr (nvme_path_t p, const char *attr)

   Read path sysfs attribute

**Parameters**

``nvme_path_t p``
  nvme_path_t object

``const char *attr``
  sysfs attribute name

**Return**

string with the contents of **attr**


.. c:function:: nvme_ns_t nvme_scan_namespace (const char *name)

   scan namespace based on sysfs name

**Parameters**

``const char *name``
  sysfs name of the namespace to scan

**Return**

nvme_ns_t object or NULL if not found.


.. _types.h:

**types.h**


NVMe standard definitions

.. c:macro:: NVME_GET

``NVME_GET (value, name)``

   extract field from complex value

**Parameters**

``value``
  The original value of a complex field

``name``
  The name of the sub-field within an nvme value

**Description**

By convention, this library defines _SHIFT and _MASK such that mask can be
applied after the shift to isolate a specific set of bits that decode to a
sub-field.

**Return**

The 'name' field from 'value'


.. c:macro:: NVME_SET

``NVME_SET (value, name)``

   set field into complex value

**Parameters**

``value``
  The value to be set in its completed position

``name``
  The name of the sub-field within an nvme value

**Return**

The 




.. c:enum:: nvme_constants

   A place to stash various constant nvme values

**Constants**

``NVME_NSID_ALL``
  A broadcast value that is used to specify all
  namespaces

``NVME_NSID_NONE``
  The invalid namespace id, for when the nsid
  parameter is not used in a command

``NVME_UUID_NONE``
  Use to omit a uuid command parameter

``NVME_CNTLID_NONE``
  Use to omit a cntlid command parameter

``NVME_CNSSPECID_NONE``
  Use to omit a cns_specific_id command parameter

``NVME_LOG_LSP_NONE``
  Use to omit a log lsp command parameter

``NVME_LOG_LSI_NONE``
  Use to omit a log lsi command parameter

``NVME_LOG_LPO_NONE``
  Use to omit a log lpo command parameter

``NVME_IDENTIFY_DATA_SIZE``
  The transfer size for nvme identify commands

``NVME_LOG_SUPPORTED_LOG_PAGES_MAX``
  The lagest possible index in the supported
  log pages log.

``NVME_ID_NVMSET_LIST_MAX``
  The largest possible nvmset index in identify
  nvmeset

``NVME_ID_UUID_LIST_MAX``
  The largest possible uuid index in identify
  uuid list

``NVME_ID_CTRL_LIST_MAX``
  The largest possible controller index in
  identify controller list

``NVME_ID_NS_LIST_MAX``
  The largest possible namespace index in
  identify namespace list

``NVME_ID_SECONDARY_CTRL_MAX``
  The largest possible secondary controller index
  in identify secondary controller

``NVME_ID_DOMAIN_LIST_MAX``
  The largest possible domain index in the
  in domain list

``NVME_ID_ENDURANCE_GROUP_LIST_MAX``
  The largest possible endurance group
  index in the endurance group list

``NVME_ID_ND_DESCRIPTOR_MAX``
  The largest possible namespace granularity
  index in the namespace granularity descriptor
  list

``NVME_FEAT_LBA_RANGE_MAX``
  The largest possible LBA range index in feature
  lba range type

``NVME_LOG_ST_MAX_RESULTS``
  The largest possible self test result index in the
  device self test log

``NVME_LOG_TELEM_BLOCK_SIZE``
  Specification defined size of Telemetry Data Blocks

``NVME_LOG_FID_SUPPORTED_EFFECTS_MAX``
  The largest possible FID index in the 
  feature identifiers effects log.

``NVME_DSM_MAX_RANGES``
  The largest possible range index in a data-set
  management command

``NVME_NQN_LENGTH``
  Max length for NVMe Qualified Name

``NVMF_TRADDR_SIZE``
  Max Transport Address size

``NVMF_TSAS_SIZE``
  Max Transport Specific Address Subtype size

``NVME_ZNS_CHANGED_ZONES_MAX``
  Max number of zones in the changed zones log
  page




.. c:enum:: nvme_csi

   Defined command set indicators

**Constants**

``NVME_CSI_NVM``
  NVM Command Set Indicator

``NVME_CSI_ZNS``
  Zoned Namespace Command Set




.. c:enum:: nvme_register_offsets

   controller registers for all transports. This is the layout of BAR0/1 for PCIe, and properties for fabrics.

**Constants**

``NVME_REG_CAP``
  Controller Capabilities

``NVME_REG_VS``
  Version

``NVME_REG_INTMS``
  Interrupt Mask Set

``NVME_REG_INTMC``
  Interrupt Mask Clear

``NVME_REG_CC``
  Controller Configuration

``NVME_REG_CSTS``
  Controller Status

``NVME_REG_NSSR``
  NVM Subsystem Reset

``NVME_REG_AQA``
  Admin Queue Attributes

``NVME_REG_ASQ``
  Admin SQ Base Address

``NVME_REG_ACQ``
  Admin CQ Base Address

``NVME_REG_CMBLOC``
  Controller Memory Buffer Location

``NVME_REG_CMBSZ``
  Controller Memory Buffer Size

``NVME_REG_BPINFO``
  Boot Partition Information

``NVME_REG_BPRSEL``
  Boot Partition Read Select

``NVME_REG_BPMBL``
  Boot Partition Memory Buffer Location

``NVME_REG_CMBMSC``
  Controller Memory Buffer Memory Space Control

``NVME_REG_CMBSTS``
  Controller Memory Buffer Status

``NVME_REG_PMRCAP``
  Persistent Memory Capabilities

``NVME_REG_PMRCTL``
  Persistent Memory Region Control

``NVME_REG_PMRSTS``
  Persistent Memory Region Status

``NVME_REG_PMREBS``
  Persistent Memory Region Elasticity Buffer Size

``NVME_REG_PMRSWTP``
  Memory Region Sustained Write Throughput

``NVME_REG_PMRMSCL``
  Persistent Memory Region Controller Memory Space Control Lower

``NVME_REG_PMRMSCU``
  Persistent Memory Region Controller Memory Space Control Upper


.. c:function:: bool nvme_is_64bit_reg (__u32 offset)

   Checks if offset of the controller register is a know 64bit value.

**Parameters**

``__u32 offset``
  Offset of controller register field in bytes

**Description**

This function does not care about transport so that the offset is not going
to be checked inside of this function for the unsupported fields in a
specific transport. For example, BPMBL(Boot Partition Memory Buffer
Location) register is not supported by fabrics, but it can be checked here.

Returns true if given offset is 64bit register, otherwise it returns false.


.. c:function:: __u64 nvme_cmb_size (__u32 cmbsz)

   Calculate size of the controller memory buffer

**Parameters**

``__u32 cmbsz``
  Value from controller register ``NVME_REG_CMBSZ``

**Description**

Returns size of controller memory buffer in bytes


.. c:function:: __u64 nvme_pmr_size (__u32 pmrebs)

   Calculate size of persistent memory region elasticity buffer

**Parameters**

``__u32 pmrebs``
  Value from controller register ``NVME_REG_PMREBS``

**Description**

Returns size of controller persistent memory buffer in bytes


.. c:function:: __u64 nvme_pmr_throughput (__u32 pmrswtp)

   Calculate throughput of persistent memory buffer

**Parameters**

``__u32 pmrswtp``
  Value from controller register ``NVME_REG_PMRSWTP``

**Description**

Returns throughput of controller persistent memory buffer in bytes/second




.. c:enum:: nvme_psd_flags

   Possible flag values in nvme power state descriptor

**Constants**

``NVME_PSD_FLAGS_MXPS``
  Indicates the scale for the Maximum Power
  field. If this bit is cleared, then the scale of the
  Maximum Power field is in 0.01 Watts. If this bit is
  set, then the scale of the Maximum Power field is in
  0.0001 Watts.

``NVME_PSD_FLAGS_NOPS``
  Indicates whether the controller processes I/O
  commands in this power state. If this bit is cleared,
  then the controller processes I/O commands in this
  power state. If this bit is set, then the controller
  does not process I/O commands in this power state.




.. c:enum:: nvme_psd_ps

   Known values for :c:type:`struct nvme_psd <nvme_psd>` ``ips`` and ``aps``. Use with nvme_psd_power_scale() to extract the power scale field to match this enum.

**Constants**

``NVME_PSD_PS_100_MICRO_WATT``
  0.0001 watt scale

``NVME_PSD_PS_10_MILLI_WATT``
  0.01 watt scale


.. c:function:: unsigned int nvme_psd_power_scale (__u8 ps)

   power scale occupies the upper 3 bits

**Parameters**

``__u8 ps``
  power scale value




.. c:enum:: nvme_psd_workload

   Specifies a workload hint in the Power Management Feature (see :c:type:`struct nvme_psd <nvme_psd>`.apw) to inform the NVM subsystem or indicate the conditions for the active power level.

**Constants**

``NVME_PSD_WORKLOAD_1``
  Extended Idle Period with a Burst of Random Write
  consists of five minutes of idle followed by
  thirty-two random write commands of size 1 MiB
  submitted to a single controller while all other
  controllers in the NVM subsystem are idle, and then
  thirty (30) seconds of idle.

``NVME_PSD_WORKLOAD_2``
  Heavy Sequential Writes consists of 80,000
  sequential write commands of size 128 KiB submitted to
  a single controller while all other controllers in the
  NVM subsystem are idle.  The submission queue(s)
  should be sufficiently large allowing the host to
  ensure there are multiple commands pending at all
  times during the workload.




.. c:struct:: nvme_id_psd


**Definition**

::

  struct nvme_id_psd {
    __le16 mp;
    __u8 rsvd2;
    __u8 flags;
    __le32 enlat;
    __le32 exlat;
    __u8 rrt;
    __u8 rrl;
    __u8 rwt;
    __u8 rwl;
    __le16 idlp;
    __u8 ips;
    __u8 rsvd19;
    __le16 actp;
    __u8 apws;
    __u8 rsvd23[9];
  };

**Members**

``mp``
  Maximum Power indicates the sustained maximum power consumed by the
  NVM subsystem in this power state. The power in Watts is equal to
  the value in this field multiplied by the scale specified in the Max
  Power Scale bit (see :c:type:`enum nvme_psd_flags <nvme_psd_flags>`). A value of 0 indicates
  Maximum Power is not reported.

``rsvd2``
  Reserved

``flags``
  Additional decoding flags, see :c:type:`enum nvme_psd_flags <nvme_psd_flags>`.

``enlat``
  Entry Latency indicates the maximum latency in microseconds
  associated with entering this power state. A value of 0 indicates
  Entry Latency is not reported.

``exlat``
  Exit Latency indicates the maximum latency in microseconds
  associated with exiting this power state. A value of 0 indicates
  Exit Latency is not reported.

``rrt``
  Relative Read Throughput indicates the read throughput rank
  associated with this power state relative to others. The value in
  this is less than the number of supported power states.

``rrl``
  Relative Reade Latency indicates the read latency rank associated
  with this power state relative to others. The value in this field is
  less than the number of supported power states.

``rwt``
  Relative Write Throughput indicates write throughput rank associated
  with this power state relative to others. The value in this field is
  less than the number of supported power states

``rwl``
  Relative Write Latency indicates the write latency rank associated
  with this power state relative to others. The value in this field is
  less than the number of supported power states

``idlp``
  Idle Power indicates the typical power consumed by the NVM
  subsystem over 30 seconds in this power state when idle.

``ips``
  Idle Power Scale indicates the scale for :c:type:`struct nvme_id_psd <nvme_id_psd>`.idlp,
  see :c:type:`enum nvme_psd_ps <nvme_psd_ps>` for decoding this field.

``rsvd19``
  Reserved

``actp``
  Active Power indicates the largest average power consumed by the
  NVM subsystem over a 10 second period in this power state with
  the workload indicated in the Active Power Workload field.

``apws``
  Bits 7-6: Active Power Scale(APS) indicates the scale for the :c:type:`struct
  nvme_id_psd <nvme_id_psd>`.actp, see :c:type:`enum nvme_psd_ps <nvme_psd_ps>` for decoding this value.
  Bits 2-0: Active Power Workload(APW) indicates the workload
  used to calculate maximum power for this power state.
  See :c:type:`enum nvme_psd_workload <nvme_psd_workload>` for decoding this field.

``rsvd23``
  Reserved





.. c:struct:: nvme_id_ctrl

   Identify Controller data structure

**Definition**

::

  struct nvme_id_ctrl {
    __le16 vid;
    __le16 ssvid;
    char sn[20];
    char mn[40];
    char fr[8];
    __u8 rab;
    __u8 ieee[3];
    __u8 cmic;
    __u8 mdts;
    __le16 cntlid;
    __le32 ver;
    __le32 rtd3r;
    __le32 rtd3e;
    __le32 oaes;
    __le32 ctratt;
    __le16 rrls;
    __u8 rsvd102[9];
    __u8 cntrltype;
    __u8 fguid[16];
    __le16 crdt1;
    __le16 crdt2;
    __le16 crdt3;
    __u8 rsvd134[119];
    __u8 nvmsr;
    __u8 vwci;
    __u8 mec;
    __le16 oacs;
    __u8 acl;
    __u8 aerl;
    __u8 frmw;
    __u8 lpa;
    __u8 elpe;
    __u8 npss;
    __u8 avscc;
    __u8 apsta;
    __le16 wctemp;
    __le16 cctemp;
    __le16 mtfa;
    __le32 hmpre;
    __le32 hmmin;
    __u8 tnvmcap[16];
    __u8 unvmcap[16];
    __le32 rpmbs;
    __le16 edstt;
    __u8 dsto;
    __u8 fwug;
    __le16 kas;
    __le16 hctma;
    __le16 mntmt;
    __le16 mxtmt;
    __le32 sanicap;
    __le32 hmminds;
    __le16 hmmaxd;
    __le16 nsetidmax;
    __le16 endgidmax;
    __u8 anatt;
    __u8 anacap;
    __le32 anagrpmax;
    __le32 nanagrpid;
    __le32 pels;
    __le16 domainid;
    __u8 rsvd358[10];
    __u8 megcap[16];
    __u8 rsvd384[128];
    __u8 sqes;
    __u8 cqes;
    __le16 maxcmd;
    __le32 nn;
    __le16 oncs;
    __le16 fuses;
    __u8 fna;
    __u8 vwc;
    __le16 awun;
    __le16 awupf;
    __u8 icsvscc;
    __u8 nwpc;
    __le16 acwu;
    __le16 ocfs;
    __le32 sgls;
    __le32 mnan;
    __u8 maxdna[16];
    __le32 maxcna;
    __u8 rsvd564[204];
    char subnqn[NVME_NQN_LENGTH];
    __u8 rsvd1024[768];
    __le32 ioccsz;
    __le32 iorcsz;
    __le16 icdoff;
    __u8 fcatt;
    __u8 msdbd;
    __le16 ofcs;
    __u8 rsvd1806[242];
    struct nvme_id_psd      psd[32];
    __u8 vs[1024];
  };

**Members**

``vid``
  PCI Vendor ID, the company vendor identifier that is assigned by
  the PCI SIG.

``ssvid``
  PCI Subsystem Vendor ID, the company vendor identifier that is
  assigned by the PCI SIG for the subsystem.

``sn``
  Serial Number in ascii

``mn``
  Model Number in ascii

``fr``
  Firmware Revision in ascii, the currently active firmware
  revision for the NVM subsystem

``rab``
  Recommended Arbitration Burst, reported as a power of two

``ieee``
  IEEE assigned Organization Unique Identifier

``cmic``
  Controller Multipath IO and Namespace Sharing  Capabilities of
  the controller and NVM subsystem. See :c:type:`enum nvme_id_ctrl_cmic <nvme_id_ctrl_cmic>`.

``mdts``
  Max Data Transfer Size is the largest data transfer size. The
  host should not submit a command that exceeds this maximum data
  transfer size. The value is in units of the minimum memory page
  size (CAP.MPSMIN) and is reported as a power of two

``cntlid``
  Controller ID, the NVM subsystem unique controller identifier
  associated with the controller.

``ver``
  Version, this field contains the value reported in the Version
  register, or property (see :c:type:`enum nvme_registers <nvme_registers>` ``NVME_REG_VS``).

``rtd3r``
  RTD3 Resume Latency, the expected latency in microseconds to resume
  from Runtime D3

``rtd3e``
  RTD3 Exit Latency, the typical latency in microseconds to enter
  Runtime D3.

``oaes``
  Optional Async Events Supported, see **enum** nvme_id_ctrl_oaes.

``ctratt``
  Controller Attributes, see **enum** nvme_id_ctrl_ctratt.

``rrls``
  Read Recovery Levels. If a bit is set, then the corresponding
  Read Recovery Level is supported. If a bit is cleared, then the
  corresponding Read Recovery Level is not supported.

``rsvd102``
  Reserved

``cntrltype``
  Controller Type, see :c:type:`enum nvme_id_ctrl_cntrltype <nvme_id_ctrl_cntrltype>`

``fguid``
  FRU GUID, a 128-bit value that is globally unique for a given
  Field Replaceable Unit

``crdt1``
  Controller Retry Delay time in 100 millisecod units if CQE CRD
  field is 1

``crdt2``
  Controller Retry Delay time in 100 millisecod units if CQE CRD
  field is 2

``crdt3``
  Controller Retry Delay time in 100 millisecod units if CQE CRD
  field is 3

``rsvd134``
  Reserved

``nvmsr``
  NVM Subsystem Report, see :c:type:`enum nvme_id_ctrl_nvmsr <nvme_id_ctrl_nvmsr>`

``vwci``
  VPD Write Cycle Information, see :c:type:`enum nvme_id_ctrl_vwci <nvme_id_ctrl_vwci>`

``mec``
  Management Endpoint Capabilities, see :c:type:`enum nvme_id_ctrl_mec <nvme_id_ctrl_mec>`

``oacs``
  Optional Admin Command Support,the optional Admin commands and
  features supported by the controller, see :c:type:`enum nvme_id_ctrl_oacs <nvme_id_ctrl_oacs>`.

``acl``
  Abort Command Limit, the maximum number of concurrently
  executing Abort commands supported by the controller. This is a
  0's based value.

``aerl``
  Async Event Request Limit, the maximum number of concurrently
  outstanding Asynchronous Event Request commands supported by the
  controller This is a 0's based value.

``frmw``
  Firmware Updates indicates capabilities regarding firmware
  updates. See :c:type:`enum nvme_id_ctrl_frmw <nvme_id_ctrl_frmw>`.

``lpa``
  Log Page Attributes, see :c:type:`enum nvme_id_ctrl_lpa <nvme_id_ctrl_lpa>`.

``elpe``
  Error Log Page Entries, the maximum number of Error Information
  log entries that are stored by the controller. This field is a
  0's based value.

``npss``
  Number of Power States Supported, the number of NVM Express
  power states supported by the controller, indicating the number
  of valid entries in :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.psd. This is a 0's
  based value.

``avscc``
  Admin Vendor Specific Command Configuration, see
  :c:type:`enum nvme_id_ctrl_avscc <nvme_id_ctrl_avscc>`.

``apsta``
  Autonomous Power State Transition Attributes, see
  :c:type:`enum nvme_id_ctrl_apsta <nvme_id_ctrl_apsta>`.

``wctemp``
  Warning Composite Temperature Threshold indicates
  the minimum Composite Temperature field value (see :c:type:`struct
  nvme_smart_log <nvme_smart_log>`.critical_comp_time) that indicates an overheating
  condition during which controller operation continues.

``cctemp``
  Critical Composite Temperature Threshold, field indicates the
  minimum Composite Temperature field value (see :c:type:`struct
  nvme_smart_log <nvme_smart_log>`.critical_comp_time) that indicates a critical
  overheating condition.

``mtfa``
  Maximum Time for Firmware Activation indicates the maximum time
  the controller temporarily stops processing commands to activate
  the firmware image, specified in 100 millisecond units. This
  field is always valid if the controller supports firmware
  activation without a reset.

``hmpre``
  Host Memory Buffer Preferred Size indicates the preferred size
  that the host is requested to allocate for the Host Memory
  Buffer feature in 4 KiB units.

``hmmin``
  Host Memory Buffer Minimum Size indicates the minimum size that
  the host is requested to allocate for the Host Memory Buffer
  feature in 4 KiB units.

``tnvmcap``
  Total NVM Capacity, the total NVM capacity in the NVM subsystem.
  The value is in bytes.

``unvmcap``
  Unallocated NVM Capacity, the unallocated NVM capacity in the
  NVM subsystem. The value is in bytes.

``rpmbs``
  Replay Protected Memory Block Support, see
  :c:type:`enum nvme_id_ctrl_rpmbs <nvme_id_ctrl_rpmbs>`.

``edstt``
  Extended Device Self-test Time, if Device Self-test command is
  supported (see :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.oacs, ``NVME_CTRL_OACS_SELF_TEST``),
  then this field indicates the nominal amount of time in one
  minute units that the controller takes to complete an extended
  device self-test operation when in power state 0.

``dsto``
  Device Self-test Options, see :c:type:`enum nvme_id_ctrl_dsto <nvme_id_ctrl_dsto>`.

``fwug``
  Firmware Update Granularity indicates the granularity and
  alignment requirement of the firmware image being updated by the
  Firmware Image Download command. The value is reported in 4 KiB
  units. A value of 0h indicates no information on granularity is
  provided. A value of FFh indicates no restriction

``kas``
  Keep Alive Support indicates the granularity of the Keep Alive
  Timer in 100 millisecond units.

``hctma``
  Host Controlled Thermal Management Attributes, see
  :c:type:`enum nvme_id_ctrl_hctm <nvme_id_ctrl_hctm>`.

``mntmt``
  Minimum Thermal Management Temperature indicates the minimum
  temperature, in degrees Kelvin, that the host may request in the
  Thermal Management Temperature 1 field and Thermal Management
  Temperature 2 field of a Set Features command with the Feature
  Identifier field set to ``NVME_FEAT_FID_HCTM``.

``mxtmt``
  Maximum Thermal Management Temperature indicates the maximum
  temperature, in degrees Kelvin, that the host may request in the
  Thermal Management Temperature 1 field and Thermal Management
  Temperature 2 field of the Set Features command with the Feature
  Identifier set to ``NVME_FEAT_FID_HCTM``.

``sanicap``
  Sanitize Capabilities, see :c:type:`enum nvme_id_ctrl_sanicap <nvme_id_ctrl_sanicap>`

``hmminds``
  Host Memory Buffer Minimum Descriptor Entry Size indicates the
  minimum usable size of a Host Memory Buffer Descriptor Entry in
  4 KiB units.

``hmmaxd``
  Host Memory Maximum Descriptors Entries indicates the number of
  usable Host Memory Buffer Descriptor Entries.

``nsetidmax``
  NVM Set Identifier Maximum, defines the maximum value of a valid
  NVM Set Identifier for any controller in the NVM subsystem.

``endgidmax``
  Endurance Group Identifier Maximum, defines the maximum value of
  a valid Endurance Group Identifier for any controller in the NVM
  subsystem.

``anatt``
  ANA Transition Time indicates the maximum amount of time, in
  seconds, for a transition between ANA states or the maximum
  amount of time, in seconds, that the controller reports the ANA
  change state.

``anacap``
  Asymmetric Namespace Access Capabilities, see
  :c:type:`enum nvme_id_ctrl_anacap <nvme_id_ctrl_anacap>`.

``anagrpmax``
  ANA Group Identifier Maximum indicates the maximum value of a
  valid ANA Group Identifier for any controller in the NVM
  subsystem.

``nanagrpid``
  Number of ANA Group Identifiers indicates the number of ANA
  groups supported by this controller.

``pels``
  Persistent Event Log Size indicates the maximum reportable size
  for the Persistent Event Log.

``domainid``
  Domain Identifier indicates the identifier of the domain
  that contains this controller.

``rsvd358``
  Reserved

``megcap``
  Max Endurance Group Capacity indicates the maximum capacity
  of a single Endurance Group.

``rsvd384``
  Reserved

``sqes``
  Submission Queue Entry Size, see :c:type:`enum nvme_id_ctrl_sqes <nvme_id_ctrl_sqes>`.

``cqes``
  Completion Queue Entry Size, see :c:type:`enum nvme_id_ctrl_cqes <nvme_id_ctrl_cqes>`.

``maxcmd``
  Maximum Outstanding Commands indicates the maximum number of
  commands that the controller processes at one time for a
  particular queue.

``nn``
  Number of Namespaces indicates the maximum value of a valid
  nsid for the NVM subsystem. If the MNAN (:c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.mnan
  field is cleared to 0h, then this field also indicates the
  maximum number of namespaces supported by the NVM subsystem.

``oncs``
  Optional NVM Command Support, see :c:type:`enum nvme_id_ctrl_oncs <nvme_id_ctrl_oncs>`.

``fuses``
  Fused Operation Support, see :c:type:`enum nvme_id_ctrl_fuses <nvme_id_ctrl_fuses>`.

``fna``
  Format NVM Attributes, see :c:type:`enum nvme_id_ctrl_fna <nvme_id_ctrl_fna>`.

``vwc``
  Volatile Write Cache, see :c:type:`enum nvme_id_ctrl_vwc <nvme_id_ctrl_vwc>`.

``awun``
  Atomic Write Unit Normal indicates the size of the write
  operation guaranteed to be written atomically to the NVM across
  all namespaces with any supported namespace format during normal
  operation. This field is specified in logical blocks and is a
  0's based value.

``awupf``
  Atomic Write Unit Power Fail indicates the size of the write
  operation guaranteed to be written atomically to the NVM across
  all namespaces with any supported namespace format during a
  power fail or error condition. This field is specified in
  logical blocks and is a 0’s based value.

``icsvscc``
  NVM Vendor Specific Command Configuration, see
  :c:type:`enum nvme_id_ctrl_nvscc <nvme_id_ctrl_nvscc>`.

``nwpc``
  Namespace Write Protection Capabilities, see
  :c:type:`enum nvme_id_ctrl_nwpc <nvme_id_ctrl_nwpc>`.

``acwu``
  Atomic Compare & Write Unit indicates the size of the write
  operation guaranteed to be written atomically to the NVM across
  all namespaces with any supported namespace format for a Compare
  and Write fused operation. This field is specified in logical
  blocks and is a 0’s based value.

``ocfs``
  Optional Copy Formats Supported, each bit n means controller
  supports Copy Format n.

``sgls``
  SGL Support, see :c:type:`enum nvme_id_ctrl_sgls <nvme_id_ctrl_sgls>`

``mnan``
  Maximum Number of Allowed Namespaces indicates the maximum
  number of namespaces supported by the NVM subsystem.

``maxdna``
  Maximum Domain Namespace Attachments indicates the maximum
  of the sum of the numver of namespaces attached to each I/O
  controller in the Domain.

``maxcna``
  Maximum I/O Controller Namespace Attachments indicates the
  maximum number of namespaces that are allowed to be attached to
  this I/O controller.

``rsvd564``
  Reserved

``subnqn``
  NVM Subsystem NVMe Qualified Name, UTF-8 null terminated string

``rsvd1024``
  Reserved

``ioccsz``
  I/O Queue Command Capsule Supported Size, defines the maximum
  I/O command capsule size in 16 byte units.

``iorcsz``
  I/O Queue Response Capsule Supported Size, defines the maximum
  I/O response capsule size in 16 byte units.

``icdoff``
  In Capsule Data Offset, defines the offset where data starts
  within a capsule. This value is applicable to I/O Queues only.

``fcatt``
  Fabrics Controller Attributes, see :c:type:`enum nvme_id_ctrl_fcatt <nvme_id_ctrl_fcatt>`.

``msdbd``
  Maximum SGL Data Block Descriptors indicates the maximum
  number of SGL Data Block or Keyed SGL Data Block descriptors
  that a host is allowed to place in a capsule. A value of 0h
  indicates no limit.

``ofcs``
  Optional Fabric Commands Support, see :c:type:`enum nvme_id_ctrl_ofcs <nvme_id_ctrl_ofcs>`.

``rsvd1806``
  Reserved

``psd``
  Power State Descriptors, see :c:type:`struct nvme_id_psd <nvme_id_psd>`.

``vs``
  Vendor Specific





.. c:enum:: nvme_id_ctrl_cmic

   Controller Multipath IO and Namespace Sharing Capabilities of the controller and NVM subsystem.

**Constants**

``NVME_CTRL_CMIC_MULTI_PORT``
  If set, then the NVM subsystem may contain
  more than one NVM subsystem port, otherwise
  the NVM subsystem contains only a single
  NVM subsystem port.

``NVME_CTRL_CMIC_MULTI_CTRL``
  If set, then the NVM subsystem may contain
  two or more controllers, otherwise the
  NVM subsystem contains only a single
  controller. An NVM subsystem that contains
  multiple controllers may be used by
  multiple hosts, or may provide multiple
  paths for a single host.

``NVME_CTRL_CMIC_MULTI_SRIOV``
  If set, then the controller is associated
  with an SR-IOV Virtual Function, otherwise
  it is associated with a PCI Function
  or a Fabrics connection.

``NVME_CTRL_CMIC_MULTI_ANA_REPORTING``
  If set, then the NVM subsystem supports
  Asymmetric Namespace Access Reporting.




.. c:enum:: nvme_id_ctrl_oaes

   Optional Asynchronous Events Supported

**Constants**

``NVME_CTRL_OAES_NA``
  Namespace Attribute Notices event supported

``NVME_CTRL_OAES_FA``
  Firmware Activation Notices event supported

``NVME_CTRL_OAES_ANA``
  ANA Change Notices supported

``NVME_CTRL_OAES_PLEA``
  Predictable Latency Event Aggregate Log
  Change Notices event supported

``NVME_CTRL_OAES_LBAS``
  LBA Status Information Notices event supported

``NVME_CTRL_OAES_EGE``
  Endurance Group Events Aggregate Log Change
  Notices event supported

``NVME_CTRL_OAES_NS``
  Normal NVM Subsystem Shutdown event supported

``NVME_CTRL_OAES_ZD``
  Zone Descriptor Change Notifications supported

``NVME_CTRL_OAES_DL``
  Discover Log Page Change Notifications supported




.. c:enum:: nvme_id_ctrl_ctratt

   Controller attributes

**Constants**

``NVME_CTRL_CTRATT_128_ID``
  128-bit Host Identifier supported

``NVME_CTRL_CTRATT_NON_OP_PSP``
  Non-Operational Poser State Permissive Mode
  supported

``NVME_CTRL_CTRATT_NVM_SETS``
  NVM Sets supported

``NVME_CTRL_CTRATT_READ_RECV_LVLS``
  Read Recovery Levels supported

``NVME_CTRL_CTRATT_ENDURANCE_GROUPS``
  Endurance Groups supported

``NVME_CTRL_CTRATT_PREDICTABLE_LAT``
  Predictable Latency Mode supported

``NVME_CTRL_CTRATT_TBKAS``
  Traffic Based Keep Alive Support

``NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY``
  Namespace Granularity reporting
  supported

``NVME_CTRL_CTRATT_SQ_ASSOCIATIONS``
  SQ Associations supported

``NVME_CTRL_CTRATT_UUID_LIST``
  UUID List reporting supported

``NVME_CTRL_CTRATT_MDS``
  Multi-Domain Subsystem supported

``NVME_CTRL_CTRATT_FIXED_CAP``
  Fixed Capacity Management  supported

``NVME_CTRL_CTRATT_VARIABLE_CAP``
  Variable Capacity Managment supported

``NVME_CTRL_CTRATT_DEL_ENDURANCE_GROUPS``
  Delete Endurance Groups supported

``NVME_CTRL_CTRATT_DEL_NVM_SETS``
  Delete NVM Sets supported

``NVME_CTRL_CTRATT_ELBAS``
  Extended LBA Formats supported




.. c:enum:: nvme_id_ctrl_cntrltype

   Controller types

**Constants**

``NVME_CTRL_CNTRLTYPE_IO``
  NVM I/O controller

``NVME_CTRL_CNTRLTYPE_DISCOVERY``
  Discovery controller

``NVME_CTRL_CNTRLTYPE_ADMIN``
  Admin controller




.. c:enum:: nvme_id_ctrl_nvmsr

   This field reports information associated with the NVM Subsystem, see :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.nvmsr.

**Constants**

``NVME_CTRL_NVMSR_NVMESD``
  If set, then the NVM Subsystem is part of an NVMe
  Storage Device; if cleared, then the NVM Subsystem
  is not part of an NVMe Storage Device.

``NVME_CTRL_NVMSR_NVMEE``
  If set’, then the NVM Subsystem is part of an NVMe
  Enclosure; if cleared, then the NVM Subsystem is
  not part of an NVMe Enclosure.




.. c:enum:: nvme_id_ctrl_vwci

   This field indicates information about remaining number of times that VPD contents are able to be updated using the VPD Write command, see :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.vwci.

**Constants**

``NVME_CTRL_VWCI_VWCR``
  Mask to get value of VPD Write Cycles Remaining. If
  the VPD Write Cycle Remaining Valid bit is set, then
  this field contains a value indicating the remaining
  number of times that VPD contents are able to be
  updated using the VPD Write command. If this field is
  set to 7Fh, then the remaining number of times that
  VPD contents are able to be updated using the VPD
  Write command is greater than or equal to 7Fh.

``NVME_CTRL_VWCI_VWCRV``
  VPD Write Cycle Remaining Valid. If this bit is set,
  then the VPD Write Cycle Remaining field is valid. If
  this bit is cleared, then the VPD Write Cycles
  Remaining field is invalid and cleared to 0h.




.. c:enum:: nvme_id_ctrl_mec

   Flags indicatings the capabilities of the Management Endpoint in the Controller, :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.mec.

**Constants**

``NVME_CTRL_MEC_SMBUSME``
  If set, then the NVM Subsystem contains a Management
  Endpoint on an SMBus/I2C port.

``NVME_CTRL_MEC_PCIEME``
  If set, then the NVM Subsystem contains a Management
  Endpoint on a PCIe port.




.. c:enum:: nvme_id_ctrl_oacs

   Flags indicating the optional Admin commands and features supported by the controller, see :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.oacs.

**Constants**

``NVME_CTRL_OACS_SECURITY``
  If set, then the controller supports the
  Security Send and Security Receive commands.

``NVME_CTRL_OACS_FORMAT``
  If set then the controller supports the Format
  NVM command.

``NVME_CTRL_OACS_FW``
  If set, then the controller supports the
  Firmware Commit and Firmware Image Download commands.

``NVME_CTRL_OACS_NS_MGMT``
  If set, then the controller supports the
  Namespace Management capability

``NVME_CTRL_OACS_SELF_TEST``
  If set, then the controller supports the Device
  Self-test command.

``NVME_CTRL_OACS_DIRECTIVES``
  If set, then the controller supports Directives
  and the Directive Send and Directive Receive
  commands.

``NVME_CTRL_OACS_NVME_MI``
  If set, then the controller supports the NVMe-MI
  Send and NVMe-MI Receive commands.

``NVME_CTRL_OACS_VIRT_MGMT``
  If set, then the controller supports the
  Virtualization Management command.

``NVME_CTRL_OACS_DBBUF_CFG``
  If set, then the controller supports the
  Doorbell Buffer Config command.

``NVME_CTRL_OACS_LBA_STATUS``
  If set, then the controller supports the Get LBA
  Status capability.




.. c:enum:: nvme_id_ctrl_frmw

   Flags and values indicates capabilities regarding firmware updates from :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.frmw.

**Constants**

``NVME_CTRL_FRMW_1ST_RO``
  If set, the first firmware slot is readonly

``NVME_CTRL_FRMW_NR_SLOTS``
  Mask to get the value of the number of
  firmware slots that the controller supports.

``NVME_CTRL_FRMW_FW_ACT_NO_RESET``
  If set, the controller supports firmware
  activation without a reset.




.. c:enum:: nvme_id_ctrl_lpa

   Flags indicating optional attributes for log pages that are accessed via the Get Log Page command.

**Constants**

``NVME_CTRL_LPA_SMART_PER_NS``

``NVME_CTRL_LPA_CMD_EFFECTS``

``NVME_CTRL_LPA_EXTENDED``

``NVME_CTRL_LPA_TELEMETRY``

``NVME_CTRL_LPA_PERSETENT_EVENT``




.. c:enum:: nvme_id_ctrl_avscc

   Flags indicating the configuration settings for Admin Vendor Specific command handling.

**Constants**

``NVME_CTRL_AVSCC_AVS``
  If set, all Admin Vendor Specific Commands use the
  optional vendor specific command format with NDT and
  NDM fields.




.. c:enum:: nvme_id_ctrl_apsta

   Flags indicating the attributes of the autonomous power state transition feature.

**Constants**

``NVME_CTRL_APSTA_APST``
  If set, then the controller supports autonomous power
  state transitions.




.. c:enum:: nvme_id_ctrl_rpmbs

   This field indicates if the controller supports one or more Replay Protected Memory Blocks, from :c:type:`struct nvme_id_ctrl <nvme_id_ctrl>`.rpmbs.

**Constants**

``NVME_CTRL_RPMBS_NR_UNITS``
  Mask to get the value of the Number of RPMB Units

``NVME_CTRL_RPMBS_AUTH_METHOD``
  Mask to get the value of the Authentication Method

``NVME_CTRL_RPMBS_TOTAL_SIZE``
  Mask to get the value of Total Size

``NVME_CTRL_RPMBS_ACCESS_SIZE``
  Mask to get the value of Access Size




.. c:enum:: nvme_id_ctrl_dsto

   Flags indicating the optional Device Self-test command or operation behaviors supported by the controller or NVM subsystem.

**Constants**

``NVME_CTRL_DSTO_ONE_DST``
  If set,  then the NVM subsystem supports only one
  device self-test operation in progress at a time.




.. c:enum:: nvme_id_ctrl_hctm

   Flags indicate the attributes of the host controlled thermal management feature

**Constants**

``NVME_CTRL_HCTMA_HCTM``
  then the controller supports host controlled thermal
  management, and the Set Features command and Get
  Features command with the Feature Identifier field
  set to ``NVME_FEAT_FID_HCTM``.




.. c:enum:: nvme_id_ctrl_sanicap

   Indicates attributes for sanitize operations.

**Constants**

``NVME_CTRL_SANICAP_CES``
  Crypto Erase Support. If set, then the
  controller supports the Crypto Erase sanitize operation.

``NVME_CTRL_SANICAP_BES``
  Block Erase Support. If set, then the controller
  supports the Block Erase sanitize operation.

``NVME_CTRL_SANICAP_OWS``
  Overwrite Support. If set, then the controller
  supports the Overwrite sanitize operation.

``NVME_CTRL_SANICAP_NDI``
  No-Deallocate Inhibited. If set and the No-
  Deallocate Response Mode bit is set, then the
  controller deallocates after the sanitize
  operation even if the No-Deallocate After
  Sanitize bit is set in a Sanitize command.

``NVME_CTRL_SANICAP_NODMMAS``
  No-Deallocate Modifies Media After Sanitize,
  mask to extract value.




.. c:enum:: nvme_id_ctrl_anacap

   This field indicates the capabilities associated with Asymmetric Namespace Access Reporting.

**Constants**

``NVME_CTRL_ANACAP_OPT``
  If set, then the controller is able to
  report ANA Optimized state.

``NVME_CTRL_ANACAP_NON_OPT``
  If set, then the controller is able to
  report ANA Non-Optimized state.

``NVME_CTRL_ANACAP_INACCESSIBLE``
  If set, then the controller is able to
  report ANA Inaccessible state.

``NVME_CTRL_ANACAP_PERSISTENT_LOSS``
  If set, then the controller is able to
  report ANA Persistent Loss state.

``NVME_CTRL_ANACAP_CHANGE``
  If set, then the controller is able to
  report ANA Change state.

``NVME_CTRL_ANACAP_GRPID_NO_CHG``
  If set, then the ANAGRPID field in the
  Identify Namespace data structure
  (:c:type:`struct nvme_id_ns <nvme_id_ns>`.anagrpid), does not
  change while the namespace is attached to
  any controller.

``NVME_CTRL_ANACAP_GRPID_MGMT``
  If set, then the controller supports a
  non-zero value in the ANAGRPID field of
  the Namespace Management command.




.. c:enum:: nvme_id_ctrl_sqes

   Defines the required and maximum Submission Queue entry size when using the NVM Command Set.

**Constants**

``NVME_CTRL_SQES_MIN``
  Mask to get the value of the required Submission Queue
  Entry size when using the NVM Command Set.

``NVME_CTRL_SQES_MAX``
  Mask to get the value of the maximum Submission Queue
  entry size when using the NVM Command Set.




.. c:enum:: nvme_id_ctrl_cqes

   Defines the required and maximum Completion Queue entry size when using the NVM Command Set.

**Constants**

``NVME_CTRL_CQES_MIN``
  Mask to get the value of the required Completion Queue
  Entry size when using the NVM Command Set.

``NVME_CTRL_CQES_MAX``
  Mask to get the value of the maximum Completion Queue
  entry size when using the NVM Command Set.




.. c:enum:: nvme_id_ctrl_oncs

   This field indicates the optional NVM commands and features supported by the controller.

**Constants**

``NVME_CTRL_ONCS_COMPARE``
  If set, then the controller supports
  the Compare command.

``NVME_CTRL_ONCS_WRITE_UNCORRECTABLE``
  If set, then the controller supports
  the Write Uncorrectable command.

``NVME_CTRL_ONCS_DSM``
  If set, then the controller supports
  the Dataset Management command.

``NVME_CTRL_ONCS_WRITE_ZEROES``
  If set, then the controller supports
  the Write Zeroes command.

``NVME_CTRL_ONCS_SAVE_FEATURES``
  If set, then the controller supports
  the Save field set to a non-zero value
  in the Set Features command and the
  Select field set to a non-zero value in
  the Get Features command.

``NVME_CTRL_ONCS_RESERVATIONS``
  If set, then the controller supports
  reservations.

``NVME_CTRL_ONCS_TIMESTAMP``
  If set, then the controller supports
  the Timestamp feature.

``NVME_CTRL_ONCS_VERIFY``
  If set, then the controller supports
  the Verify command.




.. c:enum:: nvme_id_ctrl_fuses

   This field indicates the fused operations that the controller supports.

**Constants**

``NVME_CTRL_FUSES_COMPARE_AND_WRITE``
  If set, then the controller supports the
  Compare and Write fused operation.




.. c:enum:: nvme_id_ctrl_fna

   This field indicates attributes for the Format NVM command.

**Constants**

``NVME_CTRL_FNA_FMT_ALL_NAMESPACES``
  If set, then all namespaces in an NVM
  subsystem shall be configured with the
  same attributes and a format (excluding
  secure erase) of any namespace results in
  a format of all namespaces in an NVM
  subsystem. If cleared, then the
  controller supports format on a per
  namespace basis.

``NVME_CTRL_FNA_SEC_ALL_NAMESPACES``
  If set, then any secure erase performed
  as part of a format operation results in
  a secure erase of all namespaces in the
  NVM subsystem. If cleared, then any
  secure erase performed as part of a
  format results in a secure erase of the
  particular namespace specified.

``NVME_CTRL_FNA_CRYPTO_ERASE``
  If set, then cryptographic erase is
  supported. If cleared, then cryptographic
  erase is not supported.




.. c:enum:: nvme_id_ctrl_vwc


**Constants**

``NVME_CTRL_VWC_PRESENT``
  If set, indicates a volatile write cache is present.
  If a volatile write cache is present, then the host
  controls whether the volatile write cache is enabled
  with a Set Features command specifying the value
  ``NVME_FEAT_FID_VOLATILE_WC``.

``NVME_CTRL_VWC_FLUSH``
  Mask to get the value of the flush command behavior.




.. c:enum:: nvme_id_ctrl_nvscc

   This field indicates the configuration settings for NVM Vendor Specific command handling.

**Constants**

``NVME_CTRL_NVSCC_FMT``
  If set, all NVM Vendor Specific Commands use the
  format format with NDT and NDM fields.




.. c:enum:: nvme_id_ctrl_nwpc

   This field indicates the optional namespace write protection capabilities supported by the controller.

**Constants**

``NVME_CTRL_NWPC_WRITE_PROTECT``
  If set, then the controller shall
  support the No Write Protect and
  Write Protect namespace write
  protection states and may support
  the Write Protect Until Power
  Cycle state and Permanent Write
  Protect namespace write
  protection states.

``NVME_CTRL_NWPC_WRITE_PROTECT_POWER_CYCLE``
  If set, then the controller
  supports the Write Protect Until
  Power Cycle state.

``NVME_CTRL_NWPC_WRITE_PROTECT_PERMANENT``
  If set, then the controller
  supports the Permanent Write
  Protect state.




.. c:enum:: nvme_id_ctrl_sgls

   This field indicates if SGLs are supported for the NVM Command Set and the particular SGL types supported.

**Constants**

``NVME_CTRL_SGLS_SUPPORTED``

``NVME_CTRL_SGLS_KEYED``

``NVME_CTRL_SGLS_BIT_BUCKET``

``NVME_CTRL_SGLS_MPTR_BYTE_ALIGNED``

``NVME_CTRL_SGLS_OVERSIZE``

``NVME_CTRL_SGLS_MPTR_SGL``

``NVME_CTRL_SGLS_OFFSET``

``NVME_CTRL_SGLS_TPORT``




.. c:enum:: nvme_id_ctrl_fcatt

   This field indicates attributes of the controller that are specific to NVMe over Fabrics.

**Constants**

``NVME_CTRL_FCATT_DYNAMIC``
  If cleared, then the NVM subsystem uses a dynamic
  controller model. If set, then the NVM subsystem
  uses a static controller model.




.. c:enum:: nvme_id_ctrl_ofcs

   Indicate whether the controller supports optional fabric commands.

**Constants**

``NVME_CTRL_OFCS_DISCONNECT``
  If set, then the controller supports the
  Disconnect command and deletion of individual
  I/O Queues.




.. c:struct:: nvme_lbaf

   LBA Format Data Structure

**Definition**

::

  struct nvme_lbaf {
    __le16 ms;
    __u8 ds;
    __u8 rp;
  };

**Members**

``ms``
  Metadata Size indicates the number of metadata bytes provided per LBA
  based on the LBA Data Size indicated.

``ds``
  LBA Data Size indicates the LBA data size supported, reported as a
  power of two.

``rp``
  Relative Performance, see :c:type:`enum nvme_lbaf_rp <nvme_lbaf_rp>`.





.. c:enum:: nvme_lbaf_rp

   This field indicates the relative performance of the LBA format indicated relative to other LBA formats supported by the controller.

**Constants**

``NVME_LBAF_RP_BEST``
  Best performance

``NVME_LBAF_RP_BETTER``
  Better performance

``NVME_LBAF_RP_GOOD``
  Good performance

``NVME_LBAF_RP_DEGRADED``
  Degraded performance

``NVME_LBAF_RP_MASK``
  Mask to get the relative performance value from the
  field




.. c:struct:: nvme_id_ns

   Identify Namespace data structure

**Definition**

::

  struct nvme_id_ns {
    __le64 nsze;
    __le64 ncap;
    __le64 nuse;
    __u8 nsfeat;
    __u8 nlbaf;
    __u8 flbas;
    __u8 mc;
    __u8 dpc;
    __u8 dps;
    __u8 nmic;
    __u8 rescap;
    __u8 fpi;
    __u8 dlfeat;
    __le16 nawun;
    __le16 nawupf;
    __le16 nacwu;
    __le16 nabsn;
    __le16 nabo;
    __le16 nabspf;
    __le16 noiob;
    __u8 nvmcap[16];
    __le16 npwg;
    __le16 npwa;
    __le16 npdg;
    __le16 npda;
    __le16 nows;
    __le16 mssrl;
    __le32 mcl;
    __u8 msrc;
    __u8 rsvd81;
    __u8 nulbaf;
    __u8 rsvd83[9];
    __le32 anagrpid;
    __u8 rsvd96[3];
    __u8 nsattr;
    __le16 nvmsetid;
    __le16 endgid;
    __u8 nguid[16];
    __u8 eui64[8];
    struct nvme_lbaf        lbaf[64];
    __u8 vs[3712];
  };

**Members**

``nsze``
  Namespace Size indicates the total size of the namespace in
  logical blocks. The number of logical blocks is based on the
  formatted LBA size.

``ncap``
  Namespace Capacity indicates the maximum number of logical blocks
  that may be allocated in the namespace at any point in time. The
  number of logical blocks is based on the formatted LBA size.

``nuse``
  Namespace Utilization indicates the current number of logical
  blocks allocated in the namespace. This field is smaller than or
  equal to the Namespace Capacity. The number of logical blocks is
  based on the formatted LBA size.

``nsfeat``
  Namespace Features, see :c:type:`enum nvme_id_nsfeat <nvme_id_nsfeat>`.

``nlbaf``
  Number of LBA Formats defines the number of supported LBA data
  size and metadata size combinations supported by the namespace
  and the highest possible index to :c:type:`struct nvme_id_ns <nvme_id_ns>`.lbaf.

``flbas``
  Formatted LBA Size, see :c:type:`enum nvme_id_ns_flbas <nvme_id_ns_flbas>`.

``mc``
  Metadata Capabilities, see :c:type:`enum nvme_id_ns_mc <nvme_id_ns_mc>`.

``dpc``
  End-to-end Data Protection Capabilities, see
  :c:type:`enum nvme_id_ns_dpc <nvme_id_ns_dpc>`.

``dps``
  End-to-end Data Protection Type Settings, see
  :c:type:`enum nvme_id_ns_dps <nvme_id_ns_dps>`.

``nmic``
  Namespace Multi-path I/O and Namespace Sharing Capabilities, see
  :c:type:`enum nvme_id_ns_nmic <nvme_id_ns_nmic>`.

``rescap``
  Reservation Capabilities, see :c:type:`enum nvme_id_ns_rescap <nvme_id_ns_rescap>`.

``fpi``
  Format Progress Indicator, see :c:type:`enum nvme_nd_ns_fpi <nvme_nd_ns_fpi>`.

``dlfeat``
  Deallocate Logical Block Features, see :c:type:`enum nvme_id_ns_dlfeat <nvme_id_ns_dlfeat>`.

``nawun``
  Namespace Atomic Write Unit Normal indicates the
  namespace specific size of the write operation guaranteed to be
  written atomically to the NVM during normal operation.

``nawupf``
  Namespace Atomic Write Unit Power Fail indicates the
  namespace specific size of the write operation guaranteed to be
  written atomically to the NVM during a power fail or error
  condition.

``nacwu``
  Namespace Atomic Compare & Write Unit indicates the namespace
  specific size of the write operation guaranteed to be written
  atomically to the NVM for a Compare and Write fused command.

``nabsn``
  Namespace Atomic Boundary Size Normal indicates the atomic
  boundary size for this namespace for the NAWUN value. This field
  is specified in logical blocks.

``nabo``
  Namespace Atomic Boundary Offset indicates the LBA on this
  namespace where the first atomic boundary starts.

``nabspf``
  Namespace Atomic Boundary Size Power Fail indicates the atomic
  boundary size for this namespace specific to the Namespace Atomic
  Write Unit Power Fail value. This field is specified in logical
  blocks.

``noiob``
  Namespace Optimal I/O Boundary indicates the optimal I/O boundary
  for this namespace. This field is specified in logical blocks.
  The host should construct Read and Write commands that do not
  cross the I/O boundary to achieve optimal performance.

``nvmcap``
  NVM Capacity indicates the total size of the NVM allocated to
  this namespace. The value is in bytes.

``npwg``
  Namespace Preferred Write Granularity indicates the smallest
  recommended write granularity in logical blocks for this
  namespace. This is a 0's based value.

``npwa``
  Namespace Preferred Write Alignment indicates the recommended
  write alignment in logical blocks for this namespace. This is a
  0's based value.

``npdg``
  Namespace Preferred Deallocate Granularity indicates the
  recommended granularity in logical blocks for the Dataset
  Management command with the Attribute - Deallocate bit.

``npda``
  Namespace Preferred Deallocate Alignment indicates the
  recommended alignment in logical blocks for the Dataset
  Management command with the Attribute - Deallocate bit

``nows``
  Namespace Optimal Write Size indicates the size in logical blocks
  for optimal write performance for this namespace. This is a 0's
  based value.

``mssrl``
  Maximum Single Source Range Length indicates the maximum number
  of logical blocks that may be specified in each valid Source Range
  field of a Copy command.

``mcl``
  Maximum Copy Length indicates the maximum number of logical
  blocks that may be specified in a Copy command.

``msrc``
  Maximum Source Range Count indicates the maximum number of Source
  Range entries that may be used to specify source data in a Copy
  command. This is a 0’s based value.

``rsvd81``
  Reserved

``nulbaf``
  Number of Unique Capability LBA Formats defines the number of
  supported user data size and metadata size combinations supported
  by the namespace that may not share the same capabilities. LBA
  formats shall be allocated in order and packed sequentially.

``rsvd83``
  Reserved

``anagrpid``
  ANA Group Identifier indicates the ANA Group Identifier of the
  ANA group of which the namespace is a member.

``rsvd96``
  Reserved

``nsattr``
  Namespace Attributes, see :c:type:`enum nvme_id_ns_attr <nvme_id_ns_attr>`.

``nvmsetid``
  NVM Set Identifier indicates the NVM Set with which this
  namespace is associated.

``endgid``
  Endurance Group Identifier indicates the Endurance Group with
  which this namespace is associated.

``nguid``
  Namespace Globally Unique Identifier contains a 128-bit value
  that is globally unique and assigned to the namespace when the
  namespace is created. This field remains fixed throughout the
  life of the namespace and is preserved across namespace and
  controller operations

``eui64``
  IEEE Extended Unique Identifier contains a 64-bit IEEE Extended
  Unique Identifier (EUI-64) that is globally unique and assigned
  to the namespace when the namespace is created. This field
  remains fixed throughout the life of the namespace and is
  preserved across namespace and controller operations

``lbaf``
  LBA Format, see :c:type:`struct nvme_lbaf <nvme_lbaf>`.

``vs``
  Vendor Specific





.. c:enum:: nvme_id_nsfeat

   This field defines features of the namespace.

**Constants**

``NVME_NS_FEAT_THIN``
  If set, indicates that the namespace supports thin
  provisioning. Specifically, the Namespace Capacity
  reported may be less than the Namespace Size.

``NVME_NS_FEAT_NATOMIC``
  If set, indicates that the fields NAWUN, NAWUPF, and
  NACWU are defined for this namespace and should be
  used by the host for this namespace instead of the
  AWUN, AWUPF, and ACWU fields in the Identify
  Controller data structure.

``NVME_NS_FEAT_DULBE``
  If set, indicates that the controller supports the
  Deallocated or Unwritten Logical Block error for
  this namespace.

``NVME_NS_FEAT_ID_REUSE``
  If set, indicates that the value in the NGUID field
  for this namespace, if non- zero, is never reused by
  the controller and that the value in the EUI64 field
  for this namespace, if non-zero, is never reused by
  the controller.

``NVME_NS_FEAT_IO_OPT``
  If set, indicates that the fields NPWG, NPWA, NPDG,
  NPDA, and NOWS are defined for this namespace and
  should be used by the host for I/O optimization




.. c:enum:: nvme_id_ns_flbas

   This field indicates the LBA data size & metadata size combination that the namespace has been formatted with

**Constants**

``NVME_NS_FLBAS_LOWER_MASK``
  Mask to get the index of one of the supported
  LBA Formats's least significant
  4bits indicated in
  :c:type:`struct nvme_id_ns <nvme_id_ns>`.lbaf.

``NVME_NS_FLBAS_META_EXT``
  Applicable only if format contains metadata. If
  this bit is set, indicates that the metadata is
  transferred at the end of the data LBA, creating an
  extended data LBA. If cleared, indicates that all
  of the metadata for a command is transferred as a
  separate contiguous buffer of data.

``NVME_NS_FLBAS_HIGHER_MASK``
  Mask to get the index of one of
  the supported LBA Formats's most significant
  2bits indicated in
  :c:type:`struct nvme_id_ns <nvme_id_ns>`.lbaf.




.. c:enum:: nvme_id_ns_mc

   This field indicates the capabilities for metadata.

**Constants**

``NVME_NS_MC_EXTENDED``
  If set, indicates the namespace supports the metadata
  being transferred as part of a separate buffer that is
  specified in the Metadata Pointer.

``NVME_NS_MC_SEPARATE``
  If set, indicates that the namespace supports the
  metadata being transferred as part of an extended data LBA.




.. c:enum:: nvme_id_ns_dpc

   This field indicates the capabilities for the end-to-end data protection feature.

**Constants**

``NVME_NS_DPC_PI_TYPE1``
  If set, indicates that the namespace supports
  Protection Information Type 1.

``NVME_NS_DPC_PI_TYPE2``
  If set, indicates that the namespace supports
  Protection Information Type 2.

``NVME_NS_DPC_PI_TYPE3``
  If set, indicates that the namespace supports
  Protection Information Type 3.

``NVME_NS_DPC_PI_FIRST``
  If set, indicates that the namespace supports
  protection information transferred as the first eight
  bytes of metadata.

``NVME_NS_DPC_PI_LAST``
  If set, indicates that the namespace supports
  protection information transferred as the last eight
  bytes of metadata.




.. c:enum:: nvme_id_ns_dps

   This field indicates the Type settings for the end-to-end data protection feature.

**Constants**

``NVME_NS_DPS_PI_NONE``
  Protection information is not enabled

``NVME_NS_DPS_PI_TYPE1``
  Protection information is enabled, Type 1

``NVME_NS_DPS_PI_TYPE2``
  Protection information is enabled, Type 2

``NVME_NS_DPS_PI_TYPE3``
  Protection information is enabled, Type 3

``NVME_NS_DPS_PI_MASK``
  Mask to get the value of the PI type

``NVME_NS_DPS_PI_FIRST``
  If set, indicates that the protection information, if
  enabled, is transferred as the first eight bytes of
  metadata.




.. c:enum:: nvme_id_ns_nmic

   This field specifies multi-path I/O and namespace sharing capabilities of the namespace.

**Constants**

``NVME_NS_NMIC_SHARED``
  If set, then the namespace may be attached to two or
  more controllers in the NVM subsystem concurrently




.. c:enum:: nvme_id_ns_rescap

   This field indicates the reservation capabilities of the namespace.

**Constants**

``NVME_NS_RESCAP_PTPL``
  If set, indicates that the namespace supports the
  Persist Through Power Loss capability.

``NVME_NS_RESCAP_WE``
  If set, indicates that the namespace supports the
  Write Exclusive reservation type.

``NVME_NS_RESCAP_EA``
  If set, indicates that the namespace supports the
  Exclusive Access reservation type.

``NVME_NS_RESCAP_WERO``
  If set, indicates that the namespace supports the
  Write Exclusive - Registrants Only reservation type.

``NVME_NS_RESCAP_EARO``
  If set, indicates that the namespace supports the
  Exclusive Access - Registrants Only reservation type.

``NVME_NS_RESCAP_WEAR``
  If set, indicates that the namespace supports the
  Write Exclusive - All Registrants reservation type.

``NVME_NS_RESCAP_EAAR``
  If set, indicates that the namespace supports the
  Exclusive Access - All Registrants reservation type.

``NVME_NS_RESCAP_IEK_13``
  If set, indicates that Ignore Existing Key is used
  as defined in revision 1.3 or later of this specification.




.. c:enum:: nvme_nd_ns_fpi

   If a format operation is in progress, this field indicates the percentage of the namespace that remains to be formatted.

**Constants**

``NVME_NS_FPI_REMAINING``
  Mask to get the format percent remaining value

``NVME_NS_FPI_SUPPORTED``
  If set, indicates that the namespace supports the
  Format Progress Indicator defined for the field.




.. c:enum:: nvme_id_ns_dlfeat

   This field indicates information about features that affect deallocating logical blocks for this namespace.

**Constants**

``NVME_NS_DLFEAT_RB``
  Mask to get the value of the read behavior

``NVME_NS_DLFEAT_RB_NR``
  Read behvaior is not reported

``NVME_NS_DLFEAT_RB_ALL_0S``
  A deallocated logical block returns all bytes
  cleared to 0h.

``NVME_NS_DLFEAT_RB_ALL_FS``
  A deallocated logical block returns all bytes
  set to FFh.

``NVME_NS_DLFEAT_WRITE_ZEROES``
  If set, indicates that the controller supports
  the Deallocate bit in the Write Zeroes command
  for this namespace.

``NVME_NS_DLFEAT_CRC_GUARD``
  If set, indicates that the Guard field for
  deallocated logical blocks that contain
  protection information is set to the CRC for
  the value read from the deallocated logical
  block and its metadata




.. c:enum:: nvme_id_ns_attr

   Specifies attributes of the namespace.

**Constants**

``NVME_NS_NSATTR_WRITE_PROTECTED``
  If set, then the namespace is currently
  write protected and all write access to the
  namespace shall fail.




.. c:struct:: nvme_ns_id_desc


**Definition**

::

  struct nvme_ns_id_desc {
    __u8 nidt;
    __u8 nidl;
    __le16 rsvd;
    __u8 nid[];
  };

**Members**

``nidt``
  Namespace Identifier Type, see :c:type:`enum nvme_ns_id_desc_nidt <nvme_ns_id_desc_nidt>`

``nidl``
  Namespace Identifier Length contains the length in bytes of the
  :c:type:`struct nvme_id_ns <nvme_id_ns>`.nid.

``rsvd``
  Reserved

``nid``
  Namespace Identifier contains a value that is globally unique and
  assigned to the namespace when the namespace is created. The length
  is defined in :c:type:`struct nvme_id_ns <nvme_id_ns>`.nidl.





.. c:enum:: nvme_ns_id_desc_nidt

   Known namespace identifier types

**Constants**

``NVME_NIDT_EUI64``
  IEEE Extended Unique Identifier, the NID field contains a
  copy of the EUI64 field in the struct nvme_id_ns.eui64.

``NVME_NIDT_NGUID``
  Namespace Globally Unique Identifier, the NID field
  contains a copy of the NGUID field in struct nvme_id_ns.nguid.

``NVME_NIDT_UUID``
  The NID field contains a 128-bit Universally Unique
  Identifier (UUID) as specified in RFC 4122.

``NVME_NIDT_CSI``
  The NID field contains the command set indentifier.




.. c:struct:: nvme_nvmset_attr

   NVM Set Attributes Entry

**Definition**

::

  struct nvme_nvmset_attr {
    __le16 nvmsetid;
    __le16 endgid;
    __u8 rsvd4[4];
    __le32 rr4kt;
    __le32 ows;
    __u8 tnvmsetcap[16];
    __u8 unvmsetcap[16];
    __u8 rsvd48[80];
  };

**Members**

``nvmsetid``
  NVM Set Identifier

``endgid``
  Endurance Group Identifier

``rsvd4``
  Reserved

``rr4kt``
  Random 4 KiB Read Typical indicates the typical
  time to complete a 4 KiB random read in 100 nanosecond units
  when the NVM Set is in a Predictable Latency Mode Deterministic
  Window and there is 1 outstanding command per NVM Set.

``ows``
  Optimal Write Size

``tnvmsetcap``
  Total NVM Set Capacity

``unvmsetcap``
  Unallocated NVM Set Capacity

``rsvd48``
  Reserved





.. c:struct:: nvme_id_nvmset_list


**Definition**

::

  struct nvme_id_nvmset_list {
    __u8 nid;
    __u8 rsvd1[127];
    struct nvme_nvmset_attr ent[NVME_ID_NVMSET_LIST_MAX];
  };

**Members**

``nid``
  Nvmset id

``rsvd1``
  Reserved

``ent``
  nvmset id list





.. c:struct:: nvme_id_independent_id_ns


**Definition**

::

  struct nvme_id_independent_id_ns {
    __u8 nsfeat;
    __u8 nmic;
    __u8 rescap;
    __u8 fpi;
    __le32 anagrpid;
    __u8 nsattr;
    __u8 rsvd9;
    __le16 nvmsetid;
    __le16 endgid;
    __u8 nstat;
    __u8 rsvd15[4081];
  };

**Members**

``nsfeat``

``nmic``

``rescap``

``fpi``

``anagrpid``

``nsattr``

``rsvd9``

``nvmsetid``

``endgid``

``nstat``

``rsvd15``





.. c:struct:: nvme_id_ns_granularity_desc


**Definition**

::

  struct nvme_id_ns_granularity_desc {
    __le64 nszegran;
    __le64 ncapgran;
  };

**Members**

``nszegran``

``ncapgran``





.. c:struct:: nvme_id_ns_granularity_list


**Definition**

::

  struct nvme_id_ns_granularity_list {
    __le32 attributes;
    __u8 num_descriptors;
    __u8 rsvd5[27];
    struct nvme_id_ns_granularity_desc entry[NVME_ID_ND_DESCRIPTOR_MAX];
    __u8 rsvd288[3808];
  };

**Members**

``attributes``

``num_descriptors``

``rsvd5``

``entry``

``rsvd288``





.. c:struct:: nvme_id_uuid_list_entry


**Definition**

::

  struct nvme_id_uuid_list_entry {
    __u8 header;
    __u8 rsvd1[15];
    __u8 uuid[16];
  };

**Members**

``header``

``rsvd1``

``uuid``





.. c:enum:: nvme_id_uuid


**Constants**

``NVME_ID_UUID_HDR_ASSOCIATION_MASK``

``NVME_ID_UUID_ASSOCIATION_NONE``

``NVME_ID_UUID_ASSOCIATION_VENDOR``

``NVME_ID_UUID_ASSOCIATION_SUBSYSTEM_VENDOR``




.. c:struct:: nvme_id_uuid_list


**Definition**

::

  struct nvme_id_uuid_list {
    __u8 rsvd0[32];
    struct nvme_id_uuid_list_entry entry[NVME_ID_UUID_LIST_MAX];
  };

**Members**

``rsvd0``

``entry``





.. c:struct:: nvme_ctrl_list


**Definition**

::

  struct nvme_ctrl_list {
    __le16 num;
    __le16 identifier[NVME_ID_CTRL_LIST_MAX];
  };

**Members**

``num``

``identifier``





.. c:struct:: nvme_ns_list


**Definition**

::

  struct nvme_ns_list {
    __le32 ns[NVME_ID_NS_LIST_MAX];
  };

**Members**

``ns``





.. c:struct:: nvme_id_ctrl_nvm


**Definition**

::

  struct nvme_id_ctrl_nvm {
    __u8 vsl;
    __u8 wzsl;
    __u8 wusl;
    __u8 dmrl;
    __u32 dmrsl;
    __u64 dmsl;
    __u8 rsvd16[4080];
  };

**Members**

``vsl``

``wzsl``

``wusl``

``dmrl``

``dmrsl``

``dmsl``

``rsvd16``





.. c:struct:: nvme_nvm_id_ns


**Definition**

::

  struct nvme_nvm_id_ns {
    __le64 lbstm;
    __u8 pic;
    __u8 rsvd9[3];
    __le32 elbaf[64];
    __u8 rsvd268[3828];
  };

**Members**

``lbstm``
  Logical Block Storage Tag Mask

``pic``
  Protection Information Capabilities

``rsvd9``
  Reserved

``elbaf``
  List of Extended LBA Format Support

``rsvd268``
  Reserved





.. c:struct:: nvme_zns_lbafe


**Definition**

::

  struct nvme_zns_lbafe {
    __le64 zsze;
    __u8 zdes;
    __u8 rsvd9[7];
  };

**Members**

``zsze``

``zdes``

``rsvd9``





.. c:struct:: nvme_zns_id_ns

   Zoned Namespace Command Set Specific Identify Namespace Data Structure

**Definition**

::

  struct nvme_zns_id_ns {
    __le16 zoc;
    __le16 ozcs;
    __le32 mar;
    __le32 mor;
    __le32 rrl;
    __le32 frl;
    __le32 rrl1;
    __le32 rrl2;
    __le32 rrl3;
    __le32 frl1;
    __le32 frl2;
    __le32 frl3;
    __le32 numzrwa;
    __le16 zrwafg;
    __le16 zrwasz;
    __u8 zrwacap;
    __u8 rsvd53[2763];
    struct nvme_zns_lbafe   lbafe[64];
    __u8 vs[256];
  };

**Members**

``zoc``
  Zone Operation Characteristics

``ozcs``
  Optional Zoned Command Support

``mar``
  Maximum Active Resources

``mor``
  Maximum Open Resources

``rrl``
  Reset Recommended Limit

``frl``
  Finish Recommended Limit

``rrl1``
  Reset Recommended Limit 1

``rrl2``
  Reset Recommended Limit 2

``rrl3``
  Reset Recommended Limit 3

``frl1``
  Finish Recommended Limit 1

``frl2``
  Finish Recommended Limit 2

``frl3``
  Finish Recommended Limit 3

``numzrwa``
  Number of ZRWA Resources

``zrwafg``
  ZRWA Flush Granularity

``zrwasz``
  ZRWA Size

``zrwacap``
  ZRWA Capability

``rsvd53``
  Reserved

``lbafe``
  LBA Format Extension

``vs``
  Vendor Specific





.. c:struct:: nvme_zns_id_ctrl


**Definition**

::

  struct nvme_zns_id_ctrl {
    __u8 zasl;
    __u8 rsvd1[4095];
  };

**Members**

``zasl``

``rsvd1``
  Reserved





.. c:struct:: nvme_primary_ctrl_cap


**Definition**

::

  struct nvme_primary_ctrl_cap {
    __le16 cntlid;
    __le16 portid;
    __u8 crt;
    __u8 rsvd5[27];
    __le32 vqfrt;
    __le32 vqrfa;
    __le16 vqrfap;
    __le16 vqprt;
    __le16 vqfrsm;
    __le16 vqgran;
    __u8 rsvd48[16];
    __le32 vifrt;
    __le32 virfa;
    __le16 virfap;
    __le16 viprt;
    __le16 vifrsm;
    __le16 vigran;
    __u8 rsvd80[4016];
  };

**Members**

``cntlid``

``portid``

``crt``

``rsvd5``

``vqfrt``

``vqrfa``

``vqrfap``

``vqprt``

``vqfrsm``

``vqgran``

``rsvd48``

``vifrt``

``virfa``

``virfap``

``viprt``

``vifrsm``

``vigran``

``rsvd80``





.. c:struct:: nvme_secondary_ctrl


**Definition**

::

  struct nvme_secondary_ctrl {
    __le16 scid;
    __le16 pcid;
    __u8 scs;
    __u8 rsvd5[3];
    __le16 vfn;
    __le16 nvq;
    __le16 nvi;
    __u8 rsvd14[18];
  };

**Members**

``scid``

``pcid``

``scs``

``rsvd5``

``vfn``

``nvq``

``nvi``

``rsvd14``





.. c:struct:: nvme_secondary_ctrl_list


**Definition**

::

  struct nvme_secondary_ctrl_list {
    __u8 num;
    __u8 rsvd[31];
    struct nvme_secondary_ctrl sc_entry[NVME_ID_SECONDARY_CTRL_MAX];
  };

**Members**

``num``

``rsvd``

``sc_entry``





.. c:struct:: nvme_id_iocs

   NVMe Identify IO Command Set data structure

**Definition**

::

  struct nvme_id_iocs {
    __u64 iocsc[512];
  };

**Members**

``iocsc``
  List of supported IO Command Set Combination vectors





.. c:struct:: nvme_id_domain_attr

   Domain Attributes Entry

**Definition**

::

  struct nvme_id_domain_attr {
    __le16 dom_id;
    __u8 rsvd2[14];
    __u8 dom_cap[16];
    __u8 unalloc_dom_cap[16];
    __u8 max_egrp_dom_cap[16];
    __u8 rsvd64[64];
  };

**Members**

``dom_id``

``rsvd2``

``dom_cap``

``unalloc_dom_cap``

``max_egrp_dom_cap``

``rsvd64``





.. c:struct:: nvme_id_domain_list


**Definition**

::

  struct nvme_id_domain_list {
    __u8 num;
    __u8 rsvd[127];
    struct nvme_id_domain_attr domain_attr[NVME_ID_DOMAIN_LIST_MAX];
  };

**Members**

``num``
  Number of domain attributes

``rsvd``
  Reserved

``domain_attr``
  List of domain attributes





.. c:struct:: nvme_id_endurance_group_list


**Definition**

::

  struct nvme_id_endurance_group_list {
    __le16 num;
    __le16 identifier[NVME_ID_ENDURANCE_GROUP_LIST_MAX];
  };

**Members**

``num``

``identifier``





.. c:struct:: nvme_supported_log_pages


**Definition**

::

  struct nvme_supported_log_pages {
    __le32 lid_support[NVME_LOG_SUPPORTED_LOG_PAGES_MAX];
  };

**Members**

``lid_support``


**Description**

Supported Log Pages (Log Identifier 00h)




.. c:struct:: nvme_error_log_page

   Error Information Log Entry (Log Identifier 01h)

**Definition**

::

  struct nvme_error_log_page {
    __le64 error_count;
    __le16 sqid;
    __le16 cmdid;
    __le16 status_field;
    __le16 parm_error_location;
    __le64 lba;
    __le32 nsid;
    __u8 vs;
    __u8 trtype;
    __u8 rsvd[2];
    __le64 cs;
    __le16 trtype_spec_info;
    __u8 rsvd2[22];
  };

**Members**

``error_count``
  Error Count: a 64-bit incrementing error count,
  indicating a unique identifier for this error. The error
  count starts at ``1h``, is incremented for each unique error
  log entry, and is retained across power off conditions.
  A value of ``0h`` indicates an invalid entry; this value
  is used when there are lost entries or when there are
  fewer errors than the maximum number of entries the
  controller supports. If the value of this field is
  ``FFFFFFFFh``, then the field shall be set to 1h when
  incremented (i.e., rolls over to ``1h``). Prior to NVMe
  1.4, processing of incrementing beyond ``FFFFFFFFh`` is
  unspecified.

``sqid``
  Submission Queue ID: indicates the Submission Queue
  Identifier of the command that the error information is
  associated with. If the error is not specific to
  a particular command, then this field shall be set to
  ``FFFFh``.

``cmdid``
  Command ID: indicates the Command Identifier of the
  command that the error is associated with. If the error
  is not specific to a particular command, then this field
  shall be set to ``FFFFh``.

``status_field``
  Bits 15-1: Status Field: indicates the Status Field for
  the command that completed. If the error is not specific
  to a particular command, then this field reports the most
  applicable status value.
  Bit 0: Phase Tag: may indicate the Phase Tag posted for
  the command.

``parm_error_location``
  Parameter Error Location: indicates the byte and bit of
  the command parameter that the error is associated with,
  if applicable. If the parameter spans multiple bytes or
  bits, then the location indicates the first byte and bit
  of the parameter.
  Bits 10-8: Bit in command that contained the error.
  Valid values are 0 to 7.
  Bits 7-0: Byte in command that contained the error.
  Valid values are 0 to 63.

``lba``
  LBA: This field indicates the first LBA that experienced
  the error condition, if applicable.

``nsid``
  Namespace: This field indicates the NSID of the namespace
  that the error is associated with, if applicable.

``vs``
  Vendor Specific Information Available: If there is
  additional vendor specific error information available,
  this field provides the log page identifier associated
  with that page. A value of ``0h`` indicates that no additional
  information is available. Valid values are in the range
  of ``80h`` to ``FFh``.

``trtype``
  Transport Type (TRTYPE): indicates the Transport Type of
  the transport associated with the error. The values in
  this field are the same as the TRTYPE values in the
  Discovery Log Page Entry. If the error is not transport
  related, this field shall be cleared to ``0h``. If the error
  is transport related, this field shall be set to the type
  of the transport - see :c:type:`enum nvme_trtype <nvme_trtype>`.

``rsvd``
  Reserved

``cs``
  Command Specific Information: This field contains command
  specific information. If used, the command definition
  specifies the information returned.

``trtype_spec_info``

``rsvd2``





.. c:enum:: nvme_err_pel


**Constants**

``NVME_ERR_PEL_BYTE_MASK``

``NVME_ERR_PEL_BIT_MASK``




.. c:struct:: nvme_smart_log

   SMART / Health Information Log (Log Identifier 02h)

**Definition**

::

  struct nvme_smart_log {
    __u8 critical_warning;
    __u8 temperature[2];
    __u8 avail_spare;
    __u8 spare_thresh;
    __u8 percent_used;
    __u8 endu_grp_crit_warn_sumry;
    __u8 rsvd7[25];
    __u8 data_units_read[16];
    __u8 data_units_written[16];
    __u8 host_reads[16];
    __u8 host_writes[16];
    __u8 ctrl_busy_time[16];
    __u8 power_cycles[16];
    __u8 power_on_hours[16];
    __u8 unsafe_shutdowns[16];
    __u8 media_errors[16];
    __u8 num_err_log_entries[16];
    __le32 warning_temp_time;
    __le32 critical_comp_time;
    __le16 temp_sensor[8];
    __le32 thm_temp1_trans_count;
    __le32 thm_temp2_trans_count;
    __le32 thm_temp1_total_time;
    __le32 thm_temp2_total_time;
    __u8 rsvd232[280];
  };

**Members**

``critical_warning``
  This field indicates critical warnings for the state
  of the controller. Critical warnings may result in an
  asynchronous event notification to the host. Bits in
  this field represent the current associated state and
  are not persistent (see :c:type:`enum nvme_smart_crit <nvme_smart_crit>`).

``temperature``
  Composite Temperature: Contains a value corresponding
  to a temperature in Kelvins that represents the current
  composite temperature of the controller and namespace(s)
  associated with that controller. The manner in which
  this value is computed is implementation specific and
  may not represent the actual temperature of any physical
  point in the NVM subsystem. Warning and critical
  overheating composite temperature threshold values are
  reported by the WCTEMP and CCTEMP fields in the Identify
  Controller data structure.

``avail_spare``
  Available Spare: Contains a normalized percentage (0%
  to 100%) of the remaining spare capacity available.

``spare_thresh``
  Available Spare Threshold: When the Available Spare
  falls below the threshold indicated in this field, an
  asynchronous event completion may occur. The value is
  indicated as a normalized percentage (0% to 100%).
  The values 101 to 255 are reserved.

``percent_used``
  Percentage Used: Contains a vendor specific estimate
  of the percentage of NVM subsystem life used based on
  the actual usage and the manufacturer's prediction of
  NVM life. A value of 100 indicates that the estimated
  endurance of the NVM in the NVM subsystem has been
  consumed, but may not indicate an NVM subsystem failure.
  The value is allowed to exceed 100. Percentages greater
  than 254 shall be represented as 255. This value shall
  be updated once per power-on hour (when the controller
  is not in a sleep state).

``endu_grp_crit_warn_sumry``
  Endurance Group Critical Warning Summary: This field
  indicates critical warnings for the state of Endurance
  Groups. Bits in this field represent the current associated
  state and are not persistent (see :c:type:`enum nvme_smart_egcw <nvme_smart_egcw>`).

``rsvd7``
  Reserved

``data_units_read``
  Data Units Read: Contains the number of 512 byte data
  units the host has read from the controller; this value
  does not include metadata. This value is reported in
  thousands (i.e., a value of 1 corresponds to 1000
  units of 512 bytes read) and is rounded up (e.g., one
  indicates the that number of 512 byte data units read
  is from 1 to 1000, three indicates that the number of
  512 byte data units read is from 2001 to 3000). When
  the LBA size is a value other than 512 bytes, the
  controller shall convert the amount of data read to
  512 byte units. For the NVM command set, logical blocks
  read as part of Compare, Read, and Verify operations
  shall be included in this value. A value of ``0h`` in
  this field indicates that the number of Data Units Read
  is not reported.

``data_units_written``
  Data Units Written: Contains the number of 512 byte
  data units the host has written to the controller;
  this value does not include metadata. This value is
  reported in thousands (i.e., a value of 1 corresponds
  to 1000 units of 512 bytes written) and is rounded up
  (e.g., one indicates that the number of 512 byte data
  units written is from 1 to 1,000, three indicates that
  the number of 512 byte data units written is from 2001
  to 3000). When the LBA size is a value other than 512
  bytes, the controller shall convert the amount of data
  written to 512 byte units. For the NVM command set,
  logical blocks written as part of Write operations shall
  be included in this value. Write Uncorrectable commands
  and Write Zeroes commands shall not impact this value.
  A value of ``0h`` in this field indicates that the number
  of Data Units Written is not reported.

``host_reads``
  Host Read Commands: Contains the number of read commands
  completed by the controller. For the NVM command set,
  this value is the sum of the number of Compare commands
  and the number of Read commands.

``host_writes``
  Host Write Commands: Contains the number of write
  commands completed by the controller. For the NVM
  command set, this is the number of Write commands.

``ctrl_busy_time``
  Controller Busy Time: Contains the amount of time the
  controller is busy with I/O commands. The controller
  is busy when there is a command outstanding to an I/O
  Queue (specifically, a command was issued via an I/O
  Submission Queue Tail doorbell write and the corresponding
  completion queue entry has not been posted yet to the
  associated I/O Completion Queue). This value is
  reported in minutes.

``power_cycles``
  Power Cycles: Contains the number of power cycles.

``power_on_hours``
  Power On Hours: Contains the number of power-on hours.
  This may not include time that the controller was
  powered and in a non-operational power state.

``unsafe_shutdowns``
  Unsafe Shutdowns: Contains the number of unsafe
  shutdowns. This count is incremented when a Shutdown
  Notification (CC.SHN) is not received prior to loss of power.

``media_errors``
  Media and Data Integrity Errors: Contains the number
  of occurrences where the controller detected an
  unrecovered data integrity error. Errors such as
  uncorrectable ECC, CRC checksum failure, or LBA tag
  mismatch are included in this field. Errors introduced
  as a result of a Write Uncorrectable command may or
  may not be included in this field.

``num_err_log_entries``
  Number of Error Information Log Entries: Contains the
  number of Error Information log entries over the life
  of the controller.

``warning_temp_time``
  Warning Composite Temperature Time: Contains the amount
  of time in minutes that the controller is operational
  and the Composite Temperature is greater than or equal
  to the Warning Composite Temperature Threshold (WCTEMP)
  field and less than the Critical Composite Temperature
  Threshold (CCTEMP) field in the Identify Controller
  data structure. If the value of the WCTEMP or CCTEMP
  field is ``0h``, then this field is always cleared to ``0h``
  regardless of the Composite Temperature value.

``critical_comp_time``
  Critical Composite Temperature Time: Contains the amount
  of time in minutes that the controller is operational
  and the Composite Temperature is greater than or equal
  to the Critical Composite Temperature Threshold (CCTEMP)
  field in the Identify Controller data structure. If
  the value of the CCTEMP field is ``0h``, then this field
  is always cleared to 0h regardless of the Composite
  Temperature value.

``temp_sensor``
  Temperature Sensor 1-8: Contains the current temperature
  in degrees Kelvin reported by temperature sensors 1-8.
  The physical point in the NVM subsystem whose temperature
  is reported by the temperature sensor and the temperature
  accuracy is implementation specific. An implementation
  that does not implement the temperature sensor reports
  a value of ``0h``.

``thm_temp1_trans_count``
  Thermal Management Temperature 1 Transition Count:
  Contains the number of times the controller transitioned
  to lower power active power states or performed vendor
  specific thermal management actions while minimizing
  the impact on performance in order to attempt to reduce
  the Composite Temperature because of the host controlled
  thermal management feature (i.e., the Composite
  Temperature rose above the Thermal Management
  Temperature 1). This counter shall not wrap once the
  value ``FFFFFFFFh`` is reached. A value of ``0h``, indicates
  that this transition has never occurred or this field
  is not implemented.

``thm_temp2_trans_count``
  Thermal Management Temperature 2 Transition Count

``thm_temp1_total_time``
  Total Time For Thermal Management Temperature 1:
  Contains the number of seconds that the controller
  had transitioned to lower power active power states or
  performed vendor specific thermal management actions
  while minimizing the impact on performance in order to
  attempt to reduce the Composite Temperature because of
  the host controlled thermal management feature. This
  counter shall not wrap once the value ``FFFFFFFFh`` is
  reached. A value of ``0h``, indicates that this transition
  has never occurred or this field is not implemented.

``thm_temp2_total_time``
  Total Time For Thermal Management Temperature 2

``rsvd232``
  Reserved





.. c:enum:: nvme_smart_crit

   Critical Warning

**Constants**

``NVME_SMART_CRIT_SPARE``
  If set, then the available spare capacity has fallen
  below the threshold.

``NVME_SMART_CRIT_TEMPERATURE``
  If set, then a temperature is either greater
  than or equal to an over temperature threshold; or
  less than or equal to an under temperature threshold.

``NVME_SMART_CRIT_DEGRADED``
  If set, then the NVM subsystem reliability has
  been degraded due to significant media related errors
  or any internal error that degrades NVM subsystem
  reliability.

``NVME_SMART_CRIT_MEDIA``
  If set, then all of the media has been placed in read
  only mode. The controller shall not set this bit if
  the read-only condition on the media is a result of
  a change in the write protection state of a namespace.

``NVME_SMART_CRIT_VOLATILE_MEMORY``
  If set, then the volatile memory backup
  device has failed. This field is only valid if the
  controller has a volatile memory backup solution.

``NVME_SMART_CRIT_PMR_RO``
  If set, then the Persistent Memory Region has become
  read-only or unreliable.




.. c:enum:: nvme_smart_egcw

   Endurance Group Critical Warning Summary

**Constants**

``NVME_SMART_EGCW_SPARE``
  If set, then the available spare capacity of one or
  more Endurance Groups has fallen below the threshold.

``NVME_SMART_EGCW_DEGRADED``
  If set, then the reliability of one or more
  Endurance Groups has been degraded due to significant
  media related errors or any internal error that
  degrades NVM subsystem reliability.

``NVME_SMART_EGCW_RO``
  If set, then the namespaces in one or more Endurance
  Groups have been placed in read only mode not as
  a result of a change in the write protection state
  of a namespace.




.. c:struct:: nvme_firmware_slot


**Definition**

::

  struct nvme_firmware_slot {
    __u8 afi;
    __u8 rsvd1[7];
    char frs[7][8];
    __u8 rsvd2[448];
  };

**Members**

``afi``

``rsvd1``

``frs``

``rsvd2``





.. c:struct:: nvme_cmd_effects_log


**Definition**

::

  struct nvme_cmd_effects_log {
    __le32 acs[256];
    __le32 iocs[256];
    __u8 rsvd[2048];
  };

**Members**

``acs``

``iocs``

``rsvd``





.. c:enum:: nvme_cmd_effects


**Constants**

``NVME_CMD_EFFECTS_CSUPP``

``NVME_CMD_EFFECTS_LBCC``

``NVME_CMD_EFFECTS_NCC``

``NVME_CMD_EFFECTS_NIC``

``NVME_CMD_EFFECTS_CCC``

``NVME_CMD_EFFECTS_CSE_MASK``

``NVME_CMD_EFFECTS_UUID_SEL``




.. c:struct:: nvme_st_result

   Self-test Result

**Definition**

::

  struct nvme_st_result {
    __u8 dsts;
    __u8 seg;
    __u8 vdi;
    __u8 rsvd;
    __le64 poh;
    __le32 nsid;
    __le64 flba;
    __u8 sct;
    __u8 sc;
    __u8 vs[2];
  };

**Members**

``dsts``
  Device Self-test Status: Indicates the device self-test code and the
  status of the operation (see :c:type:`enum nvme_status_result <nvme_status_result>` and :c:type:`enum nvme_st_code <nvme_st_code>`).

``seg``
  Segment Number: Iindicates the segment number where the first self-test
  failure occurred. If Device Self-test Status (**dsts**) is not set to
  #NVME_ST_RESULT_KNOWN_SEG_FAIL, then this field should be ignored.

``vdi``
  Valid Diagnostic Information: Indicates the diagnostic failure
  information that is reported. See :c:type:`enum nvme_st_valid_diag_info <nvme_st_valid_diag_info>`.

``rsvd``
  Reserved

``poh``
  Power On Hours (POH): Indicates the number of power-on hours at the
  time the device self-test operation was completed or aborted. This
  does not include time that the controller was powered and in a low
  power state condition.

``nsid``
  Namespace Identifier (NSID): Indicates the namespace that the Failing
  LBA occurred on. Valid only when the NSID Valid bit
  (#NVME_ST_VALID_DIAG_INFO_NSID) is set in the Valid Diagnostic
  Information (**vdi**) field.

``flba``
  Failing LBA: indicates the LBA of the logical block that caused the
  test to fail. If the device encountered more than one failed logical
  block during the test, then this field only indicates one of those
  failed logical blocks. Valid only when the NSID Valid bit
  (#NVME_ST_VALID_DIAG_INFO_FLBA) is set in the Valid Diagnostic
  Information (**vdi**) field.

``sct``
  Status Code Type: This field may contain additional information related
  to errors or conditions. Bits 2:0 may contain additional information
  relating to errors or conditions that occurred during the device
  self-test operation represented in the same format used in the Status
  Code Type field of the completion queue entry (refer to :c:type:`enum nvme_status_field <nvme_status_field>`).
  Valid only when the NSID Valid bit (#NVME_ST_VALID_DIAG_INFO_SCT) is
  set in the Valid Diagnostic Information (**vdi**) field.

``sc``
  Status Code: This field may contain additional information relating
  to errors or conditions that occurred during the device self-test
  operation represented in the same format used in the Status Code field
  of the completion queue entry. Valid only when the SCT Valid bit
  (#NVME_ST_VALID_DIAG_INFO_SC) is set in the Valid Diagnostic
  Information (**vdi**) field.

``vs``
  Vendor Specific.





.. c:enum:: nvme_status_result

   Result of the device self-test operation

**Constants**

``NVME_ST_RESULT_NO_ERR``
  Operation completed without error.

``NVME_ST_RESULT_ABORTED``
  Operation was aborted by a Device Self-test command.

``NVME_ST_RESULT_CLR``
  Operation was aborted by a Controller Level Reset.

``NVME_ST_RESULT_NS_REMOVED``
  Operation was aborted due to a removal of
  a namespace from the namespace inventory.

``NVME_ST_RESULT_ABORTED_FORMAT``
  Operation was aborted due to the processing
  of a Format NVM command.

``NVME_ST_RESULT_FATAL_ERR``
  A fatal error or unknown test error occurred
  while the controller was executing the device
  self-test operation and the operation did
  not complete.

``NVME_ST_RESULT_UNKNOWN_SEG_FAIL``
  Operation completed with a segment that failed
  and the segment that failed is not known.

``NVME_ST_RESULT_KNOWN_SEG_FAIL``
  Operation completed with one or more failed
  segments and the first segment that failed
  is indicated in the Segment Number field.

``NVME_ST_RESULT_ABORTED_UNKNOWN``
  Operation was aborted for unknown reason.

``NVME_ST_RESULT_ABORTED_SANITIZE``
  Operation was aborted due to a sanitize operation.

``NVME_ST_RESULT_NOT_USED``
  Entry not used (does not contain a test result).

``NVME_ST_RESULT_MASK``
  Mask to get the status result value from
  the :c:type:`struct nvme_st_result <nvme_st_result>`.dsts field.




.. c:enum:: nvme_st_code

   Self-test Code value

**Constants**

``NVME_ST_CODE_RESERVED``
  Reserved.

``NVME_ST_CODE_SHORT``
  Short device self-test operation.

``NVME_ST_CODE_EXTENDED``
  Extended device self-test operation.

``NVME_ST_CODE_VS``
  Vendor specific.

``NVME_ST_CODE_SHIFT``
  Shift amount to get the code value from the
  :c:type:`struct nvme_st_result <nvme_st_result>`.dsts field.




.. c:enum:: nvme_st_curr_op

   Current Device Self-Test Operation

**Constants**

``NVME_ST_CURR_OP_NOT_RUNNING``
  No device self-test operation in progress.

``NVME_ST_CURR_OP_SHORT``
  Short device self-test operation in progress.

``NVME_ST_CURR_OP_EXTENDED``
  Extended device self-test operation in progress.

``NVME_ST_CURR_OP_VS``
  Vendor specific.

``NVME_ST_CURR_OP_RESERVED``
  Reserved.

``NVME_ST_CURR_OP_MASK``
  Mask to get the current operation value from the
  :c:type:`struct nvme_self_test_log <nvme_self_test_log>`.current_operation field.

``NVME_ST_CURR_OP_CMPL_MASK``
  Mask to get the current operation completion value
  from the :c:type:`struct nvme_self_test_log <nvme_self_test_log>`.completion field.




.. c:enum:: nvme_st_valid_diag_info

   Valid Diagnostic Information

**Constants**

``NVME_ST_VALID_DIAG_INFO_NSID``
  NSID Valid: if set, then the contents of
  the Namespace Identifier field are valid.

``NVME_ST_VALID_DIAG_INFO_FLBA``
  FLBA Valid: if set, then the contents of
  the Failing LBA field are valid.

``NVME_ST_VALID_DIAG_INFO_SCT``
  SCT Valid: if set, then the contents of
  the Status Code Type field are valid.

``NVME_ST_VALID_DIAG_INFO_SC``
  SC Valid: if set, then the contents of
  the Status Code field are valid.




.. c:struct:: nvme_self_test_log

   Device Self-test (Log Identifier 06h)

**Definition**

::

  struct nvme_self_test_log {
    __u8 current_operation;
    __u8 completion;
    __u8 rsvd[2];
    struct nvme_st_result   result[NVME_LOG_ST_MAX_RESULTS];
  };

**Members**

``current_operation``
  Current Device Self-Test Operation: indicates the status
  of the current device self-test operation. If a device
  self-test operation is in process (i.e., this field is set
  to #NVME_ST_CURR_OP_SHORT or #NVME_ST_CURR_OP_EXTENDED),
  then the controller shall not set this field to
  #NVME_ST_CURR_OP_NOT_RUNNING until a new Self-test Result
  Data Structure is created (i.e., if a device self-test
  operation completes or is aborted, then the controller
  shall create a Self-test Result Data Structure prior to
  setting this field to #NVME_ST_CURR_OP_NOT_RUNNING).
  See :c:type:`enum nvme_st_curr_op <nvme_st_curr_op>`.

``completion``
  Current Device Self-Test Completion: indicates the percentage
  of the device self-test operation that is complete (e.g.,
  a value of 25 indicates that 25% of the device self-test
  operation is complete and 75% remains to be tested).
  If the **current_operation** field is cleared to
  #NVME_ST_CURR_OP_NOT_RUNNING (indicating there is no device
  self-test operation in progress), then this field is ignored.

``rsvd``
  Reserved

``result``
  Self-test Result Data Structures, see :c:type:`struct nvme_st_result <nvme_st_result>`.





.. c:enum:: nvme_cmd_get_log_telemetry_host_lsp


**Constants**

``NVME_LOG_TELEM_HOST_LSP_RETAIN``

``NVME_LOG_TELEM_HOST_LSP_CREATE``




.. c:struct:: nvme_telemetry_log

   Retrieve internal data specific to the manufacturer.

**Definition**

::

  struct nvme_telemetry_log {
    __u8 lpi;
    __u8 rsvd1[4];
    __u8 ieee[3];
    __le16 dalb1;
    __le16 dalb2;
    __le16 dalb3;
    __u8 rsvd14[2];
    __le32 dalb4;
    __u8 rsvd20[362];
    __u8 ctrlavail;
    __u8 ctrldgn;
    __u8 rsnident[128];
    __u8 data_area[];
  };

**Members**

``lpi``
  Log Identifier, either ``NVME_LOG_LID_TELEMETRY_HOST`` or
  ``NVME_LOG_LID_TELEMETRY_CTRL``

``rsvd1``
  Reserved

``ieee``
  IEEE OUI Identifier is the Organization Unique Identifier (OUI)
  for the controller vendor that is able to interpret the data.

``dalb1``
  Telemetry Controller-Initiated Data Area 1 Last Block is
  the value of the last block in this area.

``dalb2``
  Telemetry Controller-Initiated Data Area 1 Last Block is
  the value of the last block in this area.

``dalb3``
  Telemetry Controller-Initiated Data Area 1 Last Block is
  the value of the last block in this area.

``rsvd14``
  Reserved

``dalb4``
  Telemetry Controller-Initiated Data Area 4 Last Block is
  the value of the last block in this area.

``rsvd20``
  Reserved

``ctrlavail``
  Telemetry Controller-Initiated Data Available, if cleared,
  then the controller telemetry log does not contain saved
  internal controller state. If this field is set to 1h, the
  controller log contains saved internal controller state. If
  this field is set to 1h, the data will be latched until the
  host releases it by reading the log with RAE cleared.

``ctrldgn``
  Telemetry Controller-Initiated Data Generation Number is
  a value that is incremented each time the controller initiates a
  capture of its internal controller state in the controller .

``rsnident``
  Reason Identifieris a vendor specific identifier that describes
  the operating conditions of the controller at the time of
  capture.

``data_area``
  Telemetry data blocks, vendor specific information data.


**Description**

This log consists of a header describing the log and zero or more Telemetry
Data Blocks. All Telemetry Data Blocks are ``NVME_LOG_TELEM_BLOCK_SIZE``, 512
bytes, in size. This log captures the controller’s internal state.




.. c:struct:: nvme_endurance_group_log


**Definition**

::

  struct nvme_endurance_group_log {
    __u8 critical_warning;
    __u8 rsvd1[2];
    __u8 avl_spare;
    __u8 avl_spare_threshold;
    __u8 percent_used;
    __u8 rsvd6[26];
    __u8 endurance_estimate[16];
    __u8 data_units_read[16];
    __u8 data_units_written[16];
    __u8 media_units_written[16];
    __u8 host_read_cmds[16];
    __u8 host_write_cmds[16];
    __u8 media_data_integrity_err[16];
    __u8 num_err_info_log_entries[16];
    __u8 rsvd160[352];
  };

**Members**

``critical_warning``

``rsvd1``

``avl_spare``

``avl_spare_threshold``

``percent_used``

``rsvd6``

``endurance_estimate``

``data_units_read``

``data_units_written``

``media_units_written``

``host_read_cmds``

``host_write_cmds``

``media_data_integrity_err``

``num_err_info_log_entries``

``rsvd160``





.. c:enum:: nvme_eg_critical_warning_flags


**Constants**

``NVME_EG_CRITICAL_WARNING_SPARE``

``NVME_EG_CRITICAL_WARNING_DEGRADED``

``NVME_EG_CRITICAL_WARNING_READ_ONLY``




.. c:struct:: nvme_aggregate_endurance_group_event


**Definition**

::

  struct nvme_aggregate_endurance_group_event {
    __le64 num_entries;
    __le16 entries[];
  };

**Members**

``num_entries``
  Number or entries

``entries``
  List of entries





.. c:struct:: nvme_nvmset_predictable_lat_log


**Definition**

::

  struct nvme_nvmset_predictable_lat_log {
    __u8 status;
    __u8 rsvd1;
    __le16 event_type;
    __u8 rsvd4[28];
    __le64 dtwin_rt;
    __le64 dtwin_wt;
    __le64 dtwin_tmax;
    __le64 ndwin_tmin_hi;
    __le64 ndwin_tmin_lo;
    __u8 rsvd72[56];
    __le64 dtwin_re;
    __le64 dtwin_we;
    __le64 dtwin_te;
    __u8 rsvd152[360];
  };

**Members**

``status``

``rsvd1``

``event_type``

``rsvd4``

``dtwin_rt``

``dtwin_wt``

``dtwin_tmax``

``ndwin_tmin_hi``

``ndwin_tmin_lo``

``rsvd72``

``dtwin_re``

``dtwin_we``

``dtwin_te``

``rsvd152``





.. c:enum:: nvme_nvmeset_pl_status


**Constants**

``NVME_NVMSET_PL_STATUS_DISABLED``

``NVME_NVMSET_PL_STATUS_DTWIN``

``NVME_NVMSET_PL_STATUS_NDWIN``




.. c:enum:: nvme_nvmset_pl_events


**Constants**

``NVME_NVMSET_PL_EVENT_DTWIN_READ_WARN``

``NVME_NVMSET_PL_EVENT_DTWIN_WRITE_WARN``

``NVME_NVMSET_PL_EVENT_DTWIN_TIME_WARN``

``NVME_NVMSET_PL_EVENT_DTWIN_EXCEEDED``

``NVME_NVMSET_PL_EVENT_DTWIN_EXCURSION``




.. c:struct:: nvme_aggregate_predictable_lat_event


**Definition**

::

  struct nvme_aggregate_predictable_lat_event {
    __le64 num_entries;
    __le16 entries[];
  };

**Members**

``num_entries``
  Number of entries

``entries``
  Entry list





.. c:struct:: nvme_ana_group_desc


**Definition**

::

  struct nvme_ana_group_desc {
    __le32 grpid;
    __le32 nnsids;
    __le64 chgcnt;
    __u8 state;
    __u8 rsvd17[15];
    __le32 nsids[];
  };

**Members**

``grpid``
  ANA group id

``nnsids``
  Number of namespaces in **nsids**

``chgcnt``
  Change counter

``state``
  ANA state

``rsvd17``
  Reserved

``nsids``
  List of namespaces





.. c:enum:: nvme_ana_state


**Constants**

``NVME_ANA_STATE_OPTIMIZED``

``NVME_ANA_STATE_NONOPTIMIZED``

``NVME_ANA_STATE_INACCESSIBLE``

``NVME_ANA_STATE_PERSISTENT_LOSS``

``NVME_ANA_STATE_CHANGE``




.. c:struct:: nvme_ana_log


**Definition**

::

  struct nvme_ana_log {
    __le64 chgcnt;
    __le16 ngrps;
    __u8 rsvd10[6];
    struct nvme_ana_group_desc descs[];
  };

**Members**

``chgcnt``

``ngrps``

``rsvd10``

``descs``





.. c:struct:: nvme_persistent_event_log


**Definition**

::

  struct nvme_persistent_event_log {
    __u8 lid;
    __u8 rsvd1[3];
    __le32 tnev;
    __le64 tll;
    __u8 rv;
    __u8 rsvd17;
    __le16 lhl;
    __le64 ts;
    __u8 poh[16];
    __le64 pcc;
    __le16 vid;
    __le16 ssvid;
    char sn[20];
    char mn[40];
    char subnqn[NVME_NQN_LENGTH];
    __le16 gen_number;
    __le32 rci;
    __u8 rsvd378[102];
    __u8 seb[32];
  };

**Members**

``lid``

``rsvd1``

``tnev``

``tll``

``rv``

``rsvd17``

``lhl``

``ts``

``poh``

``pcc``

``vid``

``ssvid``

``sn``

``mn``

``subnqn``

``gen_number``

``rci``

``rsvd378``

``seb``





.. c:struct:: nvme_persistent_event_entry


**Definition**

::

  struct nvme_persistent_event_entry {
    __u8 etype;
    __u8 etype_rev;
    __u8 ehl;
    __u8 rsvd3;
    __le16 cntlid;
    __le64 ets;
    __u8 rsvd14[6];
    __le16 vsil;
    __le16 el;
  };

**Members**

``etype``

``etype_rev``

``ehl``

``rsvd3``

``cntlid``

``ets``

``rsvd14``

``vsil``

``el``





.. c:enum:: nvme_persistent_event_types


**Constants**

``NVME_PEL_SMART_HEALTH_EVENT``

``NVME_PEL_FW_COMMIT_EVENT``

``NVME_PEL_TIMESTAMP_EVENT``

``NVME_PEL_POWER_ON_RESET_EVENT``

``NVME_PEL_NSS_HW_ERROR_EVENT``

``NVME_PEL_CHANGE_NS_EVENT``

``NVME_PEL_FORMAT_START_EVENT``

``NVME_PEL_FORMAT_COMPLETION_EVENT``

``NVME_PEL_SANITIZE_START_EVENT``

``NVME_PEL_SANITIZE_COMPLETION_EVENT``

``NVME_PEL_SET_FEATURE_EVENT``

``NVME_PEL_TELEMETRY_CRT``

``NVME_PEL_THERMAL_EXCURSION_EVENT``




.. c:struct:: nvme_fw_commit_event


**Definition**

::

  struct nvme_fw_commit_event {
    __le64 old_fw_rev;
    __le64 new_fw_rev;
    __u8 fw_commit_action;
    __u8 fw_slot;
    __u8 sct_fw;
    __u8 sc_fw;
    __le16 vndr_assign_fw_commit_rc;
  };

**Members**

``old_fw_rev``

``new_fw_rev``

``fw_commit_action``

``fw_slot``

``sct_fw``

``sc_fw``

``vndr_assign_fw_commit_rc``





.. c:struct:: nvme_time_stamp_change_event


**Definition**

::

  struct nvme_time_stamp_change_event {
    __le64 previous_timestamp;
    __le64 ml_secs_since_reset;
  };

**Members**

``previous_timestamp``

``ml_secs_since_reset``





.. c:struct:: nvme_power_on_reset_info_list


**Definition**

::

  struct nvme_power_on_reset_info_list {
    __le16 cid;
    __u8 fw_act;
    __u8 op_in_prog;
    __u8 rsvd4[12];
    __le32 ctrl_power_cycle;
    __le64 power_on_ml_seconds;
    __le64 ctrl_time_stamp;
  };

**Members**

``cid``

``fw_act``

``op_in_prog``

``rsvd4``

``ctrl_power_cycle``

``power_on_ml_seconds``

``ctrl_time_stamp``





.. c:struct:: nvme_nss_hw_err_event


**Definition**

::

  struct nvme_nss_hw_err_event {
    __le16 nss_hw_err_event_code;
    __u8 rsvd2[2];
    __u8 *add_hw_err_info;
  };

**Members**

``nss_hw_err_event_code``

``rsvd2``

``add_hw_err_info``





.. c:struct:: nvme_change_ns_event


**Definition**

::

  struct nvme_change_ns_event {
    __le32 nsmgt_cdw10;
    __u8 rsvd4[4];
    __le64 nsze;
    __u8 rsvd16[8];
    __le64 nscap;
    __u8 flbas;
    __u8 dps;
    __u8 nmic;
    __u8 rsvd35;
    __le32 ana_grp_id;
    __le16 nvmset_id;
    __le16 rsvd42;
    __le32 nsid;
  };

**Members**

``nsmgt_cdw10``

``rsvd4``

``nsze``

``rsvd16``

``nscap``

``flbas``

``dps``

``nmic``

``rsvd35``

``ana_grp_id``

``nvmset_id``

``rsvd42``

``nsid``





.. c:struct:: nvme_format_nvm_start_event


**Definition**

::

  struct nvme_format_nvm_start_event {
    __le32 nsid;
    __u8 fna;
    __u8 rsvd5[3];
    __le32 format_nvm_cdw10;
  };

**Members**

``nsid``

``fna``

``rsvd5``

``format_nvm_cdw10``





.. c:struct:: nvme_format_nvm_compln_event


**Definition**

::

  struct nvme_format_nvm_compln_event {
    __le32 nsid;
    __u8 smallest_fpi;
    __u8 format_nvm_status;
    __le16 compln_info;
    __le32 status_field;
  };

**Members**

``nsid``

``smallest_fpi``

``format_nvm_status``

``compln_info``

``status_field``





.. c:struct:: nvme_sanitize_start_event


**Definition**

::

  struct nvme_sanitize_start_event {
    __le32 sani_cap;
    __le32 sani_cdw10;
    __le32 sani_cdw11;
  };

**Members**

``sani_cap``

``sani_cdw10``

``sani_cdw11``





.. c:struct:: nvme_sanitize_compln_event


**Definition**

::

  struct nvme_sanitize_compln_event {
    __le16 sani_prog;
    __le16 sani_status;
    __le16 cmpln_info;
    __u8 rsvd6[2];
  };

**Members**

``sani_prog``

``sani_status``

``cmpln_info``

``rsvd6``





.. c:struct:: nvme_set_feature_event


**Definition**

::

  struct nvme_set_feature_event {
    __le32 layout;
    __le32 cdw_mem[0];
  };

**Members**

``layout``

``cdw_mem``





.. c:struct:: nvme_thermal_exc_event


**Definition**

::

  struct nvme_thermal_exc_event {
    __u8 over_temp;
    __u8 threshold;
  };

**Members**

``over_temp``

``threshold``





.. c:struct:: nvme_lba_rd


**Definition**

::

  struct nvme_lba_rd {
    __le64 rslba;
    __le32 rnlb;
    __u8 rsvd12[4];
  };

**Members**

``rslba``

``rnlb``

``rsvd12``





.. c:struct:: nvme_lbas_ns_element


**Definition**

::

  struct nvme_lbas_ns_element {
    __le32 neid;
    __le32 nlrd;
    __u8 ratype;
    __u8 rsvd8[7];
    struct nvme_lba_rd lba_rd[];
  };

**Members**

``neid``

``nlrd``

``ratype``

``rsvd8``

``lba_rd``





.. c:enum:: nvme_lba_status_atype


**Constants**

``NVME_LBA_STATUS_ATYPE_SCAN_UNTRACKED``

``NVME_LBA_STATUS_ATYPE_SCAN_TRACKED``




.. c:struct:: nvme_lba_status_log


**Definition**

::

  struct nvme_lba_status_log {
    __le32 lslplen;
    __le32 nlslne;
    __le32 estulb;
    __u8 rsvd12[2];
    __le16 lsgc;
    struct nvme_lbas_ns_element elements[];
  };

**Members**

``lslplen``

``nlslne``

``estulb``

``rsvd12``

``lsgc``

``elements``





.. c:struct:: nvme_eg_event_aggregate_log


**Definition**

::

  struct nvme_eg_event_aggregate_log {
    __le64 nr_entries;
    __le16 egids[];
  };

**Members**

``nr_entries``

``egids``





.. c:enum:: nvme_fid_supported_effects


**Constants**

``NVME_FID_SUPPORTED_EFFECTS_FSUPP``

``NVME_FID_SUPPORTED_EFFECTS_UDCC``

``NVME_FID_SUPPORTED_EFFECTS_NCC``

``NVME_FID_SUPPORTED_EFFECTS_NIC``

``NVME_FID_SUPPORTED_EFFECTS_CCC``

``NVME_FID_SUPPORTED_EFFECTS_UUID_SEL``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_SHIFT``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_MASK``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_NS``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_CTRL``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_NVM_SET``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_ENDGRP``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_DOMAIN``

``NVME_FID_SUPPORTED_EFFECTS_SCOPE_NSS``

**Description**

FID Supported and Effects Data Structure definitions




.. c:struct:: nvme_fid_supported_effects_log


**Definition**

::

  struct nvme_fid_supported_effects_log {
    __le32 fid_support[NVME_LOG_FID_SUPPORTED_EFFECTS_MAX];
  };

**Members**

``fid_support``


**Description**

Feature Identifiers Supported and Effects (Log Identifier 12h)




.. c:struct:: nvme_boot_partition


**Definition**

::

  struct nvme_boot_partition {
    __u8 lid;
    __u8 rsvd1[3];
    __le32 bpinfo;
    __u8 rsvd8[8];
    __u8 boot_partition_data[];
  };

**Members**

``lid``

``rsvd1``

``bpinfo``

``rsvd8``

``boot_partition_data``





.. c:struct:: nvme_media_unit_stat_desc


**Definition**

::

  struct nvme_media_unit_stat_desc {
    __le16 muid;
    __le16 domainid;
    __le16 endgid;
    __le16 nvmsetid;
    __le16 cap_adj_fctr;
    __u8 avl_spare;
    __u8 percent_used;
    __u8 mucs;
    __u8 cio;
  };

**Members**

``muid``
  Media Unit Identifier

``domainid``
  Domain Identifier

``endgid``
  Endurance Group Identifier

``nvmsetid``
  NVM Set Identifier

``cap_adj_fctr``
  Capacity Adjustment Factor

``avl_spare``
  Available Spare

``percent_used``
  Percentage Used

``mucs``
  Number of Channels attached to media units

``cio``
  Channel Identifiers Offset





.. c:struct:: nvme_media_unit_stat_log


**Definition**

::

  struct nvme_media_unit_stat_log {
    __le16 nmu;
    __le16 cchans;
    __le16 sel_config;
    __u8 rsvd6[10];
    struct nvme_media_unit_stat_desc mus_desc[];
  };

**Members**

``nmu``
  Number unit status descriptor

``cchans``
  Number of Channels

``sel_config``
  Selected Configuration

``rsvd6``
  Reserved

``mus_desc``
  Media unit statistic descriptors





.. c:struct:: nvme_media_unit_config_desc


**Definition**

::

  struct nvme_media_unit_config_desc {
    __le16 muid;
    __u8 rsvd2[4];
    __le16 mudl;
  };

**Members**

``muid``
  Media Unit Identifier

``mudl``
  Media Unit Descriptor Length


**Description**

Media Unit Configuration Descriptor
Structure Definitions




.. c:struct:: nvme_channel_config_desc


**Definition**

::

  struct nvme_channel_config_desc {
    __le16 chanid;
    __le16 chmus;
    struct nvme_media_unit_config_desc mu_config_desc[];
  };

**Members**

``chanid``
  Channel Identifier

``chmus``
  Number Channel Media Units


**Description**

Channel Configuration Descriptor
Structure Definitions




.. c:struct:: nvme_end_grp_chan_desc


**Definition**

::

  struct nvme_end_grp_chan_desc {
    __le16 egchans;
    struct nvme_channel_config_desc chan_config_desc[];
  };

**Members**

``egchans``
  Number of Channels


**Description**

Endurance group Channel Configuration Descriptor
Structure Definitions




.. c:struct:: nvme_end_grp_config_desc


**Definition**

::

  struct nvme_end_grp_config_desc {
    __le16 endgid;
    __le16 cap_adj_factor;
    __u8 rsvd4[12];
    __u8 tegcap[16];
    __u8 segcap[16];
    __u8 end_est[16];
    __u8 rsvd64[16];
    __le16 egsets;
    __le16 nvmsetid[];
  };

**Members**

``endgid``
  Endurance Group Identifier

``cap_adj_factor``
  Capacity Adjustment Factor

``tegcap``
  Total Endurance Group Capacity

``segcap``
  Spare Endurance Group Capacity

``end_est``
  Endurance Estimate

``egsets``
  Number of NVM Sets

``nvmsetid``
  NVM Set Identifier


**Description**

Endurance Group Configuration Descriptor
Structure Definitions




.. c:struct:: nvme_supported_cap_config_list_log


**Definition**

::

  struct nvme_supported_cap_config_list_log {
    __u8 sccn;
    __u8 rsvd1[15];
    struct nvme_capacity_config_desc cap_config_desc[];
  };

**Members**

``sccn``
  number of capacity configuration


**Description**

Supported Capacity Configuration list log page
structure definitions




.. c:struct:: nvme_resv_notification_log


**Definition**

::

  struct nvme_resv_notification_log {
    __le64 lpc;
    __u8 rnlpt;
    __u8 nalp;
    __u8 rsvd9[2];
    __le32 nsid;
    __u8 rsvd16[48];
  };

**Members**

``lpc``

``rnlpt``
  See :c:type:`enum nvme_resv_notify_rnlpt <nvme_resv_notify_rnlpt>`.

``nalp``

``rsvd9``

``nsid``

``rsvd16``





.. c:enum:: nvme_resv_notify_rnlpt


**Constants**

``NVME_RESV_NOTIFY_RNLPT_EMPTY``

``NVME_RESV_NOTIFY_RNLPT_REGISTRATION_PREEMPTED``

``NVME_RESV_NOTIFY_RNLPT_RESERVATION_RELEASED``

``NVME_RESV_NOTIFY_RNLPT_RESERVATION_PREEMPTED``




.. c:struct:: nvme_sanitize_log_page

   Sanitize Status (Log Identifier 81h)

**Definition**

::

  struct nvme_sanitize_log_page {
    __le16 sprog;
    __le16 sstat;
    __le32 scdw10;
    __le32 eto;
    __le32 etbe;
    __le32 etce;
    __le32 etond;
    __le32 etbend;
    __le32 etcend;
    __u8 rsvd32[480];
  };

**Members**

``sprog``
  Sanitize Progress (SPROG): indicates the fraction complete of the
  sanitize operation. The value is a numerator of the fraction
  complete that has 65,536 (10000h) as its denominator. This value
  shall be set to FFFFh if the **sstat** field is not set to
  ``NVME_SANITIZE_SSTAT_STATUS_IN_PROGESS``.

``sstat``
  Sanitize Status (SSTAT): indicates the status associated with
  the most recent sanitize operation. See :c:type:`enum nvme_sanitize_sstat <nvme_sanitize_sstat>`.

``scdw10``
  Sanitize Command Dword 10 Information (SCDW10): contains the value
  of the Command Dword 10 field of the Sanitize command that started
  the sanitize operation.

``eto``
  Estimated Time For Overwrite: indicates the number of seconds required
  to complete an Overwrite sanitize operation with 16 passes in
  the background when the No-Deallocate Modifies Media After Sanitize
  field is not set to 10b. A value of 0h indicates that the sanitize
  operation is expected to be completed in the background when the
  Sanitize command that started that operation is completed. A value
  of FFFFFFFFh indicates that no time period is reported.

``etbe``
  Estimated Time For Block Erase: indicates the number of seconds
  required to complete a Block Erase sanitize operation in the
  background when the No-Deallocate Modifies Media After Sanitize
  field is not set to 10b. A value of 0h indicates that the sanitize
  operation is expected to be completed in the background when the
  Sanitize command that started that operation is completed.
  A value of FFFFFFFFh indicates that no time period is reported.

``etce``
  Estimated Time For Crypto Erase: indicates the number of seconds
  required to complete a Crypto Erase sanitize operation in the
  background when the No-Deallocate Modifies Media After Sanitize
  field is not set to 10b. A value of 0h indicates that the sanitize
  operation is expected to be completed in the background when the
  Sanitize command that started that operation is completed.
  A value of FFFFFFFFh indicates that no time period is reported.

``etond``
  Estimated Time For Overwrite With No-Deallocate Media Modification:
  indicates the number of seconds required to complete an Overwrite
  sanitize operation and the associated additional media modification
  after the Overwrite sanitize operation in the background when
  the No-Deallocate After Sanitize bit was set to 1 in the Sanitize
  command that requested the Overwrite sanitize operation; and
  the No-Deallocate Modifies Media After Sanitize field is set to 10b.
  A value of 0h indicates that the sanitize operation is expected
  to be completed in the background when the Sanitize command that
  started that operation is completed. A value of FFFFFFFFh indicates
  that no time period is reported.

``etbend``
  Estimated Time For Block Erase With No-Deallocate Media Modification:
  indicates the number of seconds required to complete a Block Erase
  sanitize operation and the associated additional media modification
  after the Block Erase sanitize operation in the background when
  the No-Deallocate After Sanitize bit was set to 1 in the Sanitize
  command that requested the Overwrite sanitize operation; and
  the No-Deallocate Modifies Media After Sanitize field is set to 10b.
  A value of 0h indicates that the sanitize operation is expected
  to be completed in the background when the Sanitize command that
  started that operation is completed. A value of FFFFFFFFh indicates
  that no time period is reported.

``etcend``
  Estimated Time For Crypto Erase With No-Deallocate Media Modification:
  indicates the number of seconds required to complete a Crypto Erase
  sanitize operation and the associated additional media modification
  after the Crypto Erase sanitize operation in the background when
  the No-Deallocate After Sanitize bit was set to 1 in the Sanitize
  command that requested the Overwrite sanitize operation; and
  the No-Deallocate Modifies Media After Sanitize field is set to 10b.
  A value of 0h indicates that the sanitize operation is expected
  to be completed in the background when the Sanitize command that
  started that operation is completed. A value of FFFFFFFFh indicates
  that no time period is reported.

``rsvd32``
  Reserved





.. c:enum:: nvme_sanitize_sstat

   Sanitize Status (SSTAT)

**Constants**

``NVME_SANITIZE_SSTAT_STATUS_SHIFT``
  Shift amount to get the status value of
  the most recent sanitize operation from
  the :c:type:`struct nvme_sanitize_log_page <nvme_sanitize_log_page>`.sstat
  field.

``NVME_SANITIZE_SSTAT_STATUS_MASK``
  Mask to get the status value of the most
  recent sanitize operation.

``NVME_SANITIZE_SSTAT_STATUS_NEVER_SANITIZED``
  The NVM subsystem has never been
  sanitized.

``NVME_SANITIZE_SSTAT_STATUS_COMPLETE_SUCCESS``
  The most recent sanitize operation
  completed successfully including any
  additional media modification.

``NVME_SANITIZE_SSTAT_STATUS_IN_PROGESS``
  A sanitize operation is currently in progress.

``NVME_SANITIZE_SSTAT_STATUS_COMPLETED_FAILED``
  The most recent sanitize operation
  failed.

``NVME_SANITIZE_SSTAT_STATUS_ND_COMPLETE_SUCCESS``
  The most recent sanitize operation
  for which No-Deallocate After Sanitize was
  requested has completed successfully with
  deallocation of all user data.

``NVME_SANITIZE_SSTAT_COMPLETED_PASSES_SHIFT``
  Shift amount to get the number
  of completed passes if the most recent
  sanitize operation was an Overwrite. This
  value shall be cleared to 0h if the most
  recent sanitize operation was not
  an Overwrite.

``NVME_SANITIZE_SSTAT_COMPLETED_PASSES_MASK``
  Mask to get the number of completed
  passes.

``NVME_SANITIZE_SSTAT_GLOBAL_DATA_ERASED_SHIFT``
  Shift amount to get the Global
  Data Erased value from the
  :c:type:`struct nvme_sanitize_log_page <nvme_sanitize_log_page>`.sstat field.

``NVME_SANITIZE_SSTAT_GLOBAL_DATA_ERASED_MASK``
  Mask to get the Global Data Erased
  value.

``NVME_SANITIZE_SSTAT_GLOBAL_DATA_ERASED``
  Global Data Erased: if set, then no
  namespace user data in the NVM subsystem
  has been written to and no Persistent
  Memory Region in the NVM subsystem has
  been enabled since being manufactured and
  the NVM subsystem has never been sanitized;
  or since the most recent successful sanitize
  operation.




.. c:struct:: nvme_zns_changed_zone_log

   ZNS Changed Zone List log

**Definition**

::

  struct nvme_zns_changed_zone_log {
    __le16 nrzid;
    __u8 rsvd2[6];
    __le64 zid[NVME_ZNS_CHANGED_ZONES_MAX];
  };

**Members**

``nrzid``

``rsvd2``

``zid``





.. c:enum:: nvme_zns_zt


**Constants**

``NVME_ZONE_TYPE_SEQWRITE_REQ``




.. c:enum:: nvme_zns_za


**Constants**

``NVME_ZNS_ZA_ZFC``

``NVME_ZNS_ZA_FZR``

``NVME_ZNS_ZA_RZR``

``NVME_ZNS_ZA_ZRWAV``

``NVME_ZNS_ZA_ZDEV``




.. c:enum:: nvme_zns_zs


**Constants**

``NVME_ZNS_ZS_EMPTY``

``NVME_ZNS_ZS_IMPL_OPEN``

``NVME_ZNS_ZS_EXPL_OPEN``

``NVME_ZNS_ZS_CLOSED``

``NVME_ZNS_ZS_READ_ONLY``

``NVME_ZNS_ZS_FULL``

``NVME_ZNS_ZS_OFFLINE``




.. c:struct:: nvme_zns_desc


**Definition**

::

  struct nvme_zns_desc {
    __u8 zt;
    __u8 zs;
    __u8 za;
    __u8 zai;
    __u8 rsvd4[4];
    __le64 zcap;
    __le64 zslba;
    __le64 wp;
    __u8 rsvd32[32];
  };

**Members**

``zt``

``zs``

``za``

``zai``

``rsvd4``

``zcap``

``zslba``

``wp``

``rsvd32``





.. c:struct:: nvme_zone_report


**Definition**

::

  struct nvme_zone_report {
    __le64 nr_zones;
    __u8 rsvd8[56];
    struct nvme_zns_desc    entries[];
  };

**Members**

``nr_zones``
  Number of descriptors in **entries**

``rsvd8``
  Reserved

``entries``
  Zoned namespace descriptors





.. c:struct:: nvme_lba_status_desc


**Definition**

::

  struct nvme_lba_status_desc {
    __le64 dslba;
    __le32 nlb;
    __u8 rsvd12;
    __u8 status;
    __u8 rsvd14[2];
  };

**Members**

``dslba``

``nlb``

``rsvd12``

``status``

``rsvd14``





.. c:struct:: nvme_lba_status


**Definition**

::

  struct nvme_lba_status {
    __le32 nlsd;
    __u8 cmpc;
    __u8 rsvd5[3];
    struct nvme_lba_status_desc descs[];
  };

**Members**

``nlsd``

``cmpc``

``rsvd5``

``descs``





.. c:struct:: nvme_feat_auto_pst


**Definition**

::

  struct nvme_feat_auto_pst {
    __le64 apst_entry[32];
  };

**Members**

``apst_entry``
  See :c:type:`enum nvme_apst_entry <nvme_apst_entry>`





.. c:enum:: nvme_apst_entry


**Constants**

``NVME_APST_ENTRY_ITPS_SHIFT``

``NVME_APST_ENTRY_ITPT_SHIFT``

``NVME_APST_ENTRY_ITPS_MASK``

``NVME_APST_ENTRY_ITPT_MASK``




.. c:struct:: nvme_metadata_element_desc

   Metadata Element Descriptor

**Definition**

::

  struct nvme_metadata_element_desc {
    __u8 type;
    __u8 rev;
    __u16 len;
    __u8 val[0];
  };

**Members**

``type``
  Element Type (ET)

``rev``
  Element Revision (ER)

``len``
  Element Length (ELEN)

``val``
  Element Value (EVAL), UTF-8 string





.. c:struct:: nvme_host_metadata

   Host Metadata Data Structure

**Definition**

::

  struct nvme_host_metadata {
    __u8 ndesc;
    __u8 rsvd1;
    union {
      struct nvme_metadata_element_desc descs[0];
      __u8 descs_buf[4094];
    };
  };

**Members**

``ndesc``
  Number of metadata element descriptors

``rsvd1``
  Reserved

``{unnamed_union}``
  anonymous

``descs``
  Metadata element descriptors

``descs_buf``
  Metadata element descriptor buffer





.. c:enum:: nvme_ctrl_metadata_type

   Controller Metadata Element Types

**Constants**

``NVME_CTRL_METADATA_OS_CTRL_NAME``
  Name of the controller in
  the operating system.

``NVME_CTRL_METADATA_OS_DRIVER_NAME``
  Name of the driver in the
  operating system.

``NVME_CTRL_METADATA_OS_DRIVER_VER``
  Version of the driver in
  the operating system.

``NVME_CTRL_METADATA_PRE_BOOT_CTRL_NAME``
  Name of the controller in
  the pre-boot environment.

``NVME_CTRL_METADATA_PRE_BOOT_DRIVER_NAME``
  Name of the driver in the
  pre-boot environment.

``NVME_CTRL_METADATA_PRE_BOOT_DRIVER_VER``
  Version of the driver in the
  pre-boot environment.

``NVME_CTRL_METADATA_SYS_PROC_MODEL``
  Model of the processor.

``NVME_CTRL_METADATA_CHIPSET_DRV_NAME``
  Chipset driver name.

``NVME_CTRL_METADATA_CHIPSET_DRV_VERSION``
  Chipsset driver version.

``NVME_CTRL_METADATA_OS_NAME_AND_BUILD``
  Operating system name and build.

``NVME_CTRL_METADATA_SYS_PROD_NAME``
  System product name.

``NVME_CTRL_METADATA_FIRMWARE_VERSION``
  Host firmware (e.g UEFI) version.

``NVME_CTRL_METADATA_OS_DRIVER_FILENAME``
  Operating system driver filename.

``NVME_CTRL_METADATA_DISPLAY_DRV_NAME``
  Display driver name.

``NVME_CTRL_METADATA_DISPLAY_DRV_VERSION``
  Display driver version.

``NVME_CTRL_METADATA_HOST_DET_FAIL_REC``
  Failure record.




.. c:enum:: nvme_ns_metadata_type

   Namespace Metadata Element Types

**Constants**

``NVME_NS_METADATA_OS_NS_NAME``
  Name of the namespace in the the
  operating system

``NVME_NS_METADATA_PRE_BOOT_NS_NAME``
  Name of the namespace in the pre-boot
  environment.

``NVME_NS_METADATA_OS_NS_QUAL_1``
  First qualifier of the Operating System
  Namespace Name.

``NVME_NS_METADATA_OS_NS_QUAL_2``
  Second qualifier of the Operating System
  Namespace Name.




.. c:struct:: nvme_timestamp


**Definition**

::

  struct nvme_timestamp {
    __u8 timestamp[6];
    __u8 attr;
    __u8 rsvd;
  };

**Members**

``timestamp``

``attr``

``rsvd``





.. c:struct:: nvme_lba_range_type_entry


**Definition**

::

  struct nvme_lba_range_type_entry {
    __u8 type;
    __u8 attributes;
    __u8 rsvd2[14];
    __u64 slba;
    __u64 nlb;
    __u8 guid[16];
    __u8 rsvd48[16];
  };

**Members**

``type``

``attributes``

``rsvd2``

``slba``

``nlb``

``guid``

``rsvd48``





.. c:enum:: nvme_lbart


**Constants**

``NVME_LBART_TYPE_GP``

``NVME_LBART_TYPE_FS``

``NVME_LBART_TYPE_RAID``

``NVME_LBART_TYPE_CACHE``

``NVME_LBART_TYPE_SWAP``

``NVME_LBART_ATTRIB_TEMP``

``NVME_LBART_ATTRIB_HIDE``




.. c:struct:: nvme_lba_range_type


**Definition**

::

  struct nvme_lba_range_type {
    struct nvme_lba_range_type_entry entry[NVME_FEAT_LBA_RANGE_MAX];
  };

**Members**

``entry``





.. c:struct:: nvme_plm_config


**Definition**

::

  struct nvme_plm_config {
    __le16 ee;
    __u8 rsvd2[30];
    __le64 dtwinrt;
    __le64 dtwinwt;
    __le64 dtwintt;
    __u8 rsvd56[456];
  };

**Members**

``ee``

``rsvd2``

``dtwinrt``

``dtwinwt``

``dtwintt``

``rsvd56``





.. c:struct:: nvme_feat_host_behavior


**Definition**

::

  struct nvme_feat_host_behavior {
    __u8 acre;
    __u8 rsvd1[511];
  };

**Members**

``acre``

``rsvd1``





.. c:enum:: nvme_host_behavior_support


**Constants**

``NVME_ENABLE_ACRE``




.. c:struct:: nvme_dsm_range


**Definition**

::

  struct nvme_dsm_range {
    __le32 cattr;
    __le32 nlb;
    __le64 slba;
  };

**Members**

``cattr``

``nlb``

``slba``





.. c:struct:: nvme_copy_range


**Definition**

::

  struct nvme_copy_range {
    __u8 rsvd0[8];
    __le64 slba;
    __le16 nlb;
    __u8 rsvd18[6];
    __le32 eilbrt;
    __le16 elbatm;
    __le16 elbat;
  };

**Members**

``rsvd0``

``slba``

``nlb``

``rsvd18``

``eilbrt``

``elbatm``

``elbat``





.. c:struct:: nvme_registered_ctrl


**Definition**

::

  struct nvme_registered_ctrl {
    __le16 cntlid;
    __u8 rcsts;
    __u8 rsvd3[5];
    __le64 hostid;
    __le64 rkey;
  };

**Members**

``cntlid``

``rcsts``

``rsvd3``

``hostid``

``rkey``





.. c:struct:: nvme_registered_ctrl_ext


**Definition**

::

  struct nvme_registered_ctrl_ext {
    __le16 cntlid;
    __u8 rcsts;
    __u8 rsvd3[5];
    __le64 rkey;
    __u8 hostid[16];
    __u8 rsvd32[32];
  };

**Members**

``cntlid``

``rcsts``

``rsvd3``

``rkey``

``hostid``

``rsvd32``





.. c:struct:: nvme_resv_status


**Definition**

::

  struct nvme_resv_status {
    __le32 gen;
    __u8 rtype;
    __u8 regctl[2];
    __u8 rsvd7[2];
    __u8 ptpls;
    __u8 rsvd10[14];
    union {
      struct {
        __u8 rsvd24[40];
        struct nvme_registered_ctrl_ext regctl_eds[0];
      };
      struct nvme_registered_ctrl regctl_ds[0];
    };
  };

**Members**

``gen``

``rtype``

``regctl``

``rsvd7``

``ptpls``

``rsvd10``

``{unnamed_union}``
  anonymous

``{unnamed_struct}``
  anonymous

``rsvd24``

``regctl_eds``

``regctl_ds``





.. c:struct:: nvme_streams_directive_params


**Definition**

::

  struct nvme_streams_directive_params {
    __le16 msl;
    __le16 nssa;
    __le16 nsso;
    __u8 nssc;
    __u8 rsvd[9];
    __le32 sws;
    __le16 sgs;
    __le16 nsa;
    __le16 nso;
    __u8 rsvd2[6];
  };

**Members**

``msl``

``nssa``

``nsso``

``nssc``

``rsvd``

``sws``

``sgs``

``nsa``

``nso``

``rsvd2``





.. c:struct:: nvme_streams_directive_status


**Definition**

::

  struct nvme_streams_directive_status {
    __le16 osc;
    __le16 sid[];
  };

**Members**

``osc``

``sid``





.. c:struct:: nvme_id_directives


**Definition**

::

  struct nvme_id_directives {
    __u8 supported[32];
    __u8 enabled[32];
    __u8 rsvd64[4032];
  };

**Members**

``supported``

``enabled``

``rsvd64``





.. c:enum:: nvme_directive_types


**Constants**

``NVME_ID_DIR_ID_BIT``
  Identify directive is supported

``NVME_ID_DIR_SD_BIT``
  Streams directive is supported




.. c:struct:: nvme_host_mem_buf_attrs


**Definition**

::

  struct nvme_host_mem_buf_attrs {
    __le32 hsize;
    __le32 hmdlal;
    __le32 hmdlau;
    __le32 hmdlec;
    __u8 rsvd16[4080];
  };

**Members**

``hsize``

``hmdlal``

``hmdlau``

``hmdlec``

``rsvd16``





.. c:enum:: nvme_ae_type


**Constants**

``NVME_AER_ERROR``

``NVME_AER_SMART``

``NVME_AER_NOTICE``

``NVME_AER_CSS``

``NVME_AER_VS``




.. c:enum:: nvme_ae_info_error


**Constants**

``NVME_AER_ERROR_INVALID_DB_REG``

``NVME_AER_ERROR_INVALID_DB_VAL``

``NVME_AER_ERROR_DIAG_FAILURE``

``NVME_AER_ERROR_PERSISTENT_INTERNAL_ERROR``

``NVME_AER_ERROR_TRANSIENT_INTERNAL_ERROR``

``NVME_AER_ERROR_FW_IMAGE_LOAD_ERROR``




.. c:enum:: nvme_ae_info_smart


**Constants**

``NVME_AER_SMART_SUBSYSTEM_RELIABILITY``

``NVME_AER_SMART_TEMPERATURE_THRESHOLD``

``NVME_AER_SMART_SPARE_THRESHOLD``




.. c:enum:: nvme_ae_info_css_nvm


**Constants**

``NVME_AER_CSS_NVM_RESERVATION``

``NVME_AER_CSS_NVM_SANITIZE_COMPLETED``

``NVME_AER_CSS_NVM_UNEXPECTED_SANITIZE_DEALLOC``




.. c:enum:: nvme_ae_info_notice


**Constants**

``NVME_AER_NOTICE_NS_CHANGED``

``NVME_AER_NOTICE_FW_ACT_STARTING``

``NVME_AER_NOTICE_TELEMETRY``

``NVME_AER_NOTICE_ANA``

``NVME_AER_NOTICE_PL_EVENT``

``NVME_AER_NOTICE_LBA_STATUS_ALERT``

``NVME_AER_NOTICE_EG_EVENT``

``NVME_AER_NOTICE_DISC_CHANGED``




.. c:enum:: nvme_subsys_type

   Type of the NVM subsystem.

**Constants**

``NVME_NQN_DISC``
  Discovery type target subsystem. Describes a referral to another
  Discovery Service composed of Discovery controllers that provide
  additional discovery records. Multiple Referral entries may
  be reported for each Discovery Service (if that Discovery Service
  has multiple NVM subsystem ports or supports multiple protocols).

``NVME_NQN_NVME``
  NVME type target subsystem. Describes an NVM subsystem whose
  controllers may have attached namespaces (an NVM subsystem
  that is not composed of Discovery controllers). Multiple NVM
  Subsystem entries may be reported for each NVM subsystem if
  that NVM subsystem has multiple NVM subsystem ports.

``NVME_NQN_CURR``
  Current Discovery type target subsystem. Describes this Discovery
  subsystem (the Discovery Service that contains the controller
  processing the Get Log Page command). Multiple Current Discovery
  Subsystem entries may be reported for this Discovery subsystem
  if the current Discovery subsystem has multiple NVM subsystem
  ports.




.. c:enum:: nvmf_disc_eflags

   Discovery Log Page entry flags.

**Constants**

``NVMF_DISC_EFLAGS_NONE``
  Indicates that none of the DUPRETINFO or EPCSD
  features are supported.

``NVMF_DISC_EFLAGS_DUPRETINFO``
  Duplicate Returned Information (DUPRETINFO):
  Indicates that using the content of this entry
  to access this Discovery Service returns the same
  information that is returned by using the content
  of other entries in this log page that also have
  this flag set.

``NVMF_DISC_EFLAGS_EPCSD``
  Explicit Persistent Connection Support for Discovery (EPCSD):
  Indicates that Explicit Persistent Connections are
  supported for the Discovery controller.

``NVMF_DISC_EFLAGS_BOTH``
  Indicates that both the DUPRETINFO and EPCSD
  features are supported.




.. c:struct:: nvmf_disc_log_entry

   Discovery Log Page entry

**Definition**

::

  struct nvmf_disc_log_entry {
    __u8 trtype;
    __u8 adrfam;
    __u8 subtype;
    __u8 treq;
    __le16 portid;
    __le16 cntlid;
    __le16 asqsz;
    __le16 eflags;
    __u8 rsvd12[20];
    char trsvcid[NVMF_TRSVCID_SIZE];
    __u8 rsvd64[192];
    char subnqn[NVME_NQN_LENGTH];
    char traddr[NVMF_TRADDR_SIZE];
    union tsas {
      char common[NVMF_TSAS_SIZE];
      struct rdma {
        __u8 qptype;
        __u8 prtype;
        __u8 cms;
        __u8 rsvd3[5];
        __u16 pkey;
        __u8 rsvd10[246];
      } rdma;
      struct tcp {
        __u8 sectype;
      } tcp;
    } tsas;
  };

**Members**

``trtype``
  Transport Type (TRTYPE): Specifies the NVMe Transport type.
  See :c:type:`enum nvmf_trtype <nvmf_trtype>`.

``adrfam``
  Address Family (ADRFAM): Specifies the address family.
  See :c:type:`enum nvmf_addr_family <nvmf_addr_family>`.

``subtype``
  Subsystem Type (SUBTYPE): Specifies the type of the NVM subsystem
  that is indicated in this entry. See :c:type:`enum nvme_subsys_type <nvme_subsys_type>`.

``treq``
  Transport Requirements (TREQ): Indicates requirements for the NVMe
  Transport. See :c:type:`enum nvmf_treq <nvmf_treq>`.

``portid``
  Port ID (PORTID): Specifies a particular NVM subsystem port.
  Different NVMe Transports or address families may utilize the same
  Port ID value (e.g. a Port ID may support both iWARP and RoCE).

``cntlid``
  Controller ID (CNTLID): Specifies the controller ID. If the NVM
  subsystem uses a dynamic controller model, then this field shall
  be set to FFFFh. If the NVM subsystem uses a static controller model,
  then this field may be set to a specific controller ID (values 0h
  to FFEFh are valid). If the NVM subsystem uses a static controller
  model and the value indicated is FFFEh, then the host should remember
  the Controller ID returned as part of the Fabrics Connect command
  in order to re-establish an association in the future with the same
  controller.

``asqsz``
  Admin Max SQ Size (ASQSZ): Specifies the maximum size of an Admin
  Submission Queue. This applies to all controllers in the NVM
  subsystem. The value shall be a minimum of 32 entries.

``eflags``
  Entry Flags (EFLAGS): Indicates additional information related to
  the current entry. See :c:type:`enum nvmf_disc_eflags <nvmf_disc_eflags>`.

``rsvd12``
  Reserved

``trsvcid``
  Transport Service Identifier (TRSVCID): Specifies the NVMe Transport
  service identifier as an ASCII string. The NVMe Transport service
  identifier is specified by the associated NVMe Transport binding
  specification.

``rsvd64``
  Reserved

``subnqn``
  NVM Subsystem Qualified Name (SUBNQN): NVMe Qualified Name (NQN)
  that uniquely identifies the NVM subsystem. For a subsystem, if that
  Discovery subsystem has a unique NQN (i.e., the NVM Subsystem NVMe
  Qualified Name (SUBNQN) field in that Discovery subsystem's Identify
  Controller data structure contains a unique NQN value), then the
  value returned shall be that unique NQN. If the Discovery subsystem
  does not have a unique NQN, then the value returned shall be the
  well-known Discovery Service NQN (nqn.2014-08.org.nvmexpress.discovery).

``traddr``
  Transport Address (TRADDR): Specifies the address of the NVM subsystem
  that may be used for a Connect command as an ASCII string. The
  Address Family field describes the reference for parsing this field.

``tsas``
  Transport specific attribute settings





.. c:enum:: nvmf_trtype

   Transport Type codes for Discovery Log Page entry TRTYPE field

**Constants**

``NVMF_TRTYPE_UNSPECIFIED``
  Not indicated

``NVMF_TRTYPE_RDMA``
  RDMA

``NVMF_TRTYPE_FC``
  Fibre Channel

``NVMF_TRTYPE_TCP``
  TCP

``NVMF_TRTYPE_LOOP``
  Intra-host Transport (i.e., loopback), reserved
  for host usage.

``NVMF_TRTYPE_MAX``
  Maximum value for :c:type:`enum nvmf_trtype <nvmf_trtype>`




.. c:enum:: nvmf_addr_family

   Address Family codes for Discovery Log Page entry ADRFAM field

**Constants**

``NVMF_ADDR_FAMILY_PCI``
  PCIe

``NVMF_ADDR_FAMILY_IP4``
  AF_INET: IPv4 address family.

``NVMF_ADDR_FAMILY_IP6``
  AF_INET6: IPv6 address family.

``NVMF_ADDR_FAMILY_IB``
  AF_IB: InfiniBand address family.

``NVMF_ADDR_FAMILY_FC``
  Fibre Channel address family.

``NVMF_ADDR_FAMILY_LOOP``
  Intra-host Transport (i.e., loopback), reserved
  for host usage.




.. c:enum:: nvmf_treq

   Transport Requirements codes for Discovery Log Page entry TREQ field

**Constants**

``NVMF_TREQ_NOT_SPECIFIED``
  Not specified

``NVMF_TREQ_REQUIRED``
  Required

``NVMF_TREQ_NOT_REQUIRED``
  Not Required

``NVMF_TREQ_DISABLE_SQFLOW``
  SQ flow control disable supported




.. c:enum:: nvmf_rdma_qptype

   RDMA QP Service Type codes for Discovery Log Page entry TSAS RDMA_QPTYPE field

**Constants**

``NVMF_RDMA_QPTYPE_CONNECTED``
  Reliable Connected

``NVMF_RDMA_QPTYPE_DATAGRAM``
  Reliable Datagram




.. c:enum:: nvmf_rdma_prtype

   RDMA Provider Type codes for Discovery Log Page entry TSAS RDMA_PRTYPE field

**Constants**

``NVMF_RDMA_PRTYPE_NOT_SPECIFIED``
  No Provider Specified

``NVMF_RDMA_PRTYPE_IB``
  InfiniBand

``NVMF_RDMA_PRTYPE_ROCE``
  InfiniBand RoCE

``NVMF_RDMA_PRTYPE_ROCEV2``
  InfiniBand RoCEV2

``NVMF_RDMA_PRTYPE_IWARP``
  iWARP




.. c:enum:: nvmf_rdma_cms

   RDMA Connection Management Service Type codes for Discovery Log Page entry TSAS RDMA_CMS field

**Constants**

``NVMF_RDMA_CMS_RDMA_CM``
  Sockets based endpoint addressing




.. c:enum:: nvmf_tcp_sectype

   Transport Specific Address Subtype Definition for NVMe/TCP Transport

**Constants**

``NVMF_TCP_SECTYPE_NONE``
  No Security

``NVMF_TCP_SECTYPE_TLS``
  Transport Layer Security version 1.2

``NVMF_TCP_SECTYPE_TLS13``
  Transport Layer Security version 1.3 or a subsequent
  version. The TLS protocol negotiates the version and
  cipher suite for each TCP connection.




.. c:struct:: nvmf_discovery_log

   Discovery Log Page (Log Identifier 70h)

**Definition**

::

  struct nvmf_discovery_log {
    __le64 genctr;
    __le64 numrec;
    __le16 recfmt;
    __u8 rsvd14[1006];
    struct nvmf_disc_log_entry entries[];
  };

**Members**

``genctr``
  Generation Counter (GENCTR): Indicates the version of the discovery
  information, starting at a value of 0h. For each change in the
  Discovery Log Page, this counter is incremented by one. If the value
  of this field is FFFFFFFF_FFFFFFFFh, then the field shall be cleared
  to 0h when incremented (i.e., rolls over to 0h).

``numrec``
  Number of Records (NUMREC): Indicates the number of records
  contained in the log.

``recfmt``
  Record Format (RECFMT): Specifies the format of the Discovery Log
  Page. If a new format is defined, this value is incremented by one.
  The format of the record specified in this definition shall be 0h.

``rsvd14``
  Reserved

``entries``
  Discovery Log Page Entries - see :c:type:`struct nvmf_disc_log_entry <nvmf_disc_log_entry>`.





.. c:struct:: nvmf_connect_data

   Data payload for the 'connect' command

**Definition**

::

  struct nvmf_connect_data {
    __u8 hostid[16];
    __le16 cntlid;
    char rsvd4[238];
    char subsysnqn[NVME_NQN_LENGTH];
    char hostnqn[NVME_NQN_LENGTH];
    char rsvd5[256];
  };

**Members**

``hostid``
  Host ID of the connecting host

``cntlid``
  Requested controller ID

``rsvd4``
  Reserved

``subsysnqn``
  Subsystem NQN to connect to

``hostnqn``
  Host NQN of the connecting host

``rsvd5``
  Reserved





.. c:struct:: nvme_mi_read_nvm_ss_info


**Definition**

::

  struct nvme_mi_read_nvm_ss_info {
    __u8 nump;
    __u8 mjr;
    __u8 mnr;
    __u8 rsvd3[29];
  };

**Members**

``nump``

``mjr``

``mnr``

``rsvd3``





.. c:struct:: nvme_mi_port_pcie


**Definition**

::

  struct nvme_mi_port_pcie {
    __u8 mps;
    __u8 sls;
    __u8 cls;
    __u8 mlw;
    __u8 nlw;
    __u8 pn;
    __u8 rsvd14[18];
  };

**Members**

``mps``

``sls``

``cls``

``mlw``

``nlw``

``pn``

``rsvd14``





.. c:struct:: nvme_mi_port_smb


**Definition**

::

  struct nvme_mi_port_smb {
    __u8 vpd_addr;
    __u8 mvpd_freq;
    __u8 mme_addr;
    __u8 mme_freq;
    __u8 nvmebm;
    __u8 rsvd13[19];
  };

**Members**

``vpd_addr``

``mvpd_freq``

``mme_addr``

``mme_freq``

``nvmebm``

``rsvd13``





.. c:struct:: nvme_mi_read_port_info


**Definition**

::

  struct nvme_mi_read_port_info {
    __u8 portt;
    __u8 rsvd1;
    __le16 mmctptus;
    __le32 meb;
    union {
      struct nvme_mi_port_pcie pcie;
      struct nvme_mi_port_smb smb;
    };
  };

**Members**

``portt``

``rsvd1``

``mmctptus``

``meb``

``{unnamed_union}``
  anonymous

``pcie``

``smb``





.. c:struct:: nvme_mi_read_ctrl_info


**Definition**

::

  struct nvme_mi_read_ctrl_info {
    __u8 portid;
    __u8 rsvd1[4];
    __u8 prii;
    __le16 pri;
    __le16 vid;
    __le16 did;
    __le16 ssvid;
    __le16 ssid;
    __u8 rsvd16[16];
  };

**Members**

``portid``

``rsvd1``

``prii``

``pri``

``vid``

``did``

``ssvid``

``ssid``

``rsvd16``





.. c:struct:: nvme_mi_osc


**Definition**

::

  struct nvme_mi_osc {
    __u8 type;
    __u8 opc;
  };

**Members**

``type``

``opc``





.. c:struct:: nvme_mi_read_sc_list


**Definition**

::

  struct nvme_mi_read_sc_list {
    __le16 numcmd;
    struct nvme_mi_osc cmds[];
  };

**Members**

``numcmd``

``cmds``





.. c:struct:: nvme_mi_nvm_ss_health_status


**Definition**

::

  struct nvme_mi_nvm_ss_health_status {
    __u8 nss;
    __u8 sw;
    __u8 ctemp;
    __u8 pdlu;
    __le16 ccs;
    __u8 rsvd8[2];
  };

**Members**

``nss``

``sw``

``ctemp``

``pdlu``

``ccs``

``rsvd8``





.. c:enum:: nvme_mi_css


**Constants**

``NVME_MI_CCS_RDY``

``NVME_MI_CSS_CFS``

``NVME_MI_CSS_SHST``

``NVME_MI_CSS_NSSRO``

``NVME_MI_CSS_CECO``

``NVME_MI_CSS_NAC``

``NVME_MI_CSS_FA``

``NVME_MI_CSS_CSTS``

``NVME_MI_CSS_CTEMP``

``NVME_MI_CSS_PDLU``

``NVME_MI_CSS_SPARE``

``NVME_MI_CSS_CCWARN``




.. c:struct:: nvme_mi_ctrl_health_status


**Definition**

::

  struct nvme_mi_ctrl_health_status {
    __le16 ctlid;
    __le16 csts;
    __le16 ctemp;
    __u8 pdlu;
    __u8 spare;
    __u8 cwarn;
    __u8 rsvd9[7];
  };

**Members**

``ctlid``

``csts``

``ctemp``

``pdlu``

``spare``

``cwarn``

``rsvd9``





.. c:enum:: nvme_mi_csts


**Constants**

``NVME_MI_CSTS_RDY``

``NVME_MI_CSTS_CFS``

``NVME_MI_CSTS_SHST``

``NVME_MI_CSTS_NSSRO``

``NVME_MI_CSTS_CECO``

``NVME_MI_CSTS_NAC``

``NVME_MI_CSTS_FA``




.. c:enum:: nvme_mi_cwarn


**Constants**

``NVME_MI_CWARN_ST``

``NVME_MI_CWARN_TAUT``

``NVME_MI_CWARN_RD``

``NVME_MI_CWARN_RO``

``NVME_MI_CWARN_VMBF``




.. c:struct:: nvme_mi_vpd_mra


**Definition**

::

  struct nvme_mi_vpd_mra {
    __u8 nmravn;
    __u8 ff;
    __u8 rsvd7[6];
    __u8 i18vpwr;
    __u8 m18vpwr;
    __u8 i33vpwr;
    __u8 m33vpwr;
    __u8 rsvd17;
    __u8 m33vapsr;
    __u8 i5vapsr;
    __u8 m5vapsr;
    __u8 i12vapsr;
    __u8 m12vapsr;
    __u8 mtl;
    __u8 tnvmcap[16];
    __u8 rsvd37[27];
  };

**Members**

``nmravn``

``ff``

``rsvd7``

``i18vpwr``

``m18vpwr``

``i33vpwr``

``m33vpwr``

``rsvd17``

``m33vapsr``

``i5vapsr``

``m5vapsr``

``i12vapsr``

``m12vapsr``

``mtl``

``tnvmcap``

``rsvd37``





.. c:struct:: nvme_mi_vpd_ppmra


**Definition**

::

  struct nvme_mi_vpd_ppmra {
    __u8 nppmravn;
    __u8 pn;
    __u8 ppi;
    __u8 ls;
    __u8 mlw;
    __u8 mctp;
    __u8 refccap;
    __u8 pi;
    __u8 rsvd13[3];
  };

**Members**

``nppmravn``

``pn``

``ppi``

``ls``

``mlw``

``mctp``

``refccap``

``pi``

``rsvd13``





.. c:struct:: nvme_mi_vpd_telem


**Definition**

::

  struct nvme_mi_vpd_telem {
    __u8 type;
    __u8 rev;
    __u8 len;
    __u8 data[0];
  };

**Members**

``type``

``rev``

``len``

``data``





.. c:enum:: nvme_mi_elem


**Constants**

``NVME_MI_ELEM_EED``

``NVME_MI_ELEM_USCE``

``NVME_MI_ELEM_ECED``

``NVME_MI_ELEM_LED``

``NVME_MI_ELEM_SMBMED``

``NVME_MI_ELEM_PCIESED``

``NVME_MI_ELEM_NVMED``




.. c:struct:: nvme_mi_vpd_tra


**Definition**

::

  struct nvme_mi_vpd_tra {
    __u8 vn;
    __u8 rsvd6;
    __u8 ec;
    struct nvme_mi_vpd_telem elems[0];
  };

**Members**

``vn``

``rsvd6``

``ec``

``elems``





.. c:struct:: nvme_mi_vpd_mr_common


**Definition**

::

  struct nvme_mi_vpd_mr_common {
    __u8 type;
    __u8 rf;
    __u8 rlen;
    __u8 rchksum;
    __u8 hchksum;
    union {
      struct nvme_mi_vpd_mra nmra;
      struct nvme_mi_vpd_ppmra ppmra;
      struct nvme_mi_vpd_tra tmra;
    };
  };

**Members**

``type``

``rf``

``rlen``

``rchksum``

``hchksum``

``{unnamed_union}``
  anonymous

``nmra``

``ppmra``

``tmra``





.. c:struct:: nvme_mi_vpd_hdr


**Definition**

::

  struct nvme_mi_vpd_hdr {
    __u8 ipmiver;
    __u8 iuaoff;
    __u8 ciaoff;
    __u8 biaoff;
    __u8 piaoff;
    __u8 mrioff;
    __u8 rsvd6;
    __u8 chchk;
    __u8 vpd[];
  };

**Members**

``ipmiver``

``iuaoff``

``ciaoff``

``biaoff``

``piaoff``

``mrioff``

``rsvd6``

``chchk``

``vpd``





.. c:enum:: nvme_status_field

   Defines all parts of the nvme status field: status code, status code type, and additional flags.

**Constants**

``NVME_SCT_GENERIC``
  Generic errors applicable to multiple opcodes

``NVME_SCT_CMD_SPECIFIC``
  Errors associated to a specific opcode

``NVME_SCT_MEDIA``
  Errors associated with media and data integrity

``NVME_SCT_PATH``
  Errors associated with the paths connection

``NVME_SCT_VS``
  Vendor specific errors

``NVME_SCT_MASK``
  Mask to get the value of the Status Code Type

``NVME_SC_MASK``
  Mask to get the value of the status code.

``NVME_SC_SUCCESS``
  Successful Completion: The command
  completed without error.

``NVME_SC_INVALID_OPCODE``
  Invalid Command Opcode: A reserved coded
  value or an unsupported value in the
  command opcode field.

``NVME_SC_INVALID_FIELD``
  Invalid Field in Command: A reserved
  coded value or an unsupported value in a
  defined field.

``NVME_SC_CMDID_CONFLICT``
  Command ID Conflict: The command
  identifier is already in use.

``NVME_SC_DATA_XFER_ERROR``
  Data Transfer Error: Transferring the
  data or metadata associated with a
  command experienced an error.

``NVME_SC_POWER_LOSS``
  Commands Aborted due to Power Loss
  Notification: Indicates that the command
  was aborted due to a power loss
  notification.

``NVME_SC_INTERNAL``
  Internal Error: The command was not
  completed successfully due to an internal error.

``NVME_SC_ABORT_REQ``
  Command Abort Requested: The command was
  aborted due to an Abort command being
  received that specified the Submission
  Queue Identifier and Command Identifier
  of this command.

``NVME_SC_ABORT_QUEUE``
  Command Aborted due to SQ Deletion: The
  command was aborted due to a Delete I/O
  Submission Queue request received for the
  Submission Queue to which the command was
  submitted.

``NVME_SC_FUSED_FAIL``
  Command Aborted due to Failed Fused Command:
  The command was aborted due to the other
  command in a fused operation failing.

``NVME_SC_FUSED_MISSING``
  Aborted due to Missing Fused Command: The
  fused command was aborted due to the
  adjacent submission queue entry not
  containing a fused command that is the
  other command.

``NVME_SC_INVALID_NS``
  Invalid Namespace or Format: The
  namespace or the format of that namespace
  is invalid.

``NVME_SC_CMD_SEQ_ERROR``
  Command Sequence Error: The command was
  aborted due to a protocol violation in a
  multi-command sequence.

``NVME_SC_SGL_INVALID_LAST``
  Invalid SGL Segment Descriptor: The
  command includes an invalid SGL Last
  Segment or SGL Segment descriptor.

``NVME_SC_SGL_INVALID_COUNT``
  Invalid Number of SGL Descriptors: There
  is an SGL Last Segment descriptor or an
  SGL Segment descriptor in a location
  other than the last descriptor of a
  segment based on the length indicated.

``NVME_SC_SGL_INVALID_DATA``
  Data SGL Length Invalid: This may occur
  if the length of a Data SGL is too short.
  This may occur if the length of a Data
  SGL is too long and the controller does
  not support SGL transfers longer than the
  amount of data to be transferred as
  indicated in the SGL Support field of the
  Identify Controller data structure.

``NVME_SC_SGL_INVALID_METADATA``
  Metadata SGL Length Invalid: This may
  occur if the length of a Metadata SGL is
  too short. This may occur if the length
  of a Metadata SGL is too long and the
  controller does not support SGL transfers
  longer than the amount of data to be
  transferred as indicated in the SGL
  Support field of the Identify Controller
  data structure.

``NVME_SC_SGL_INVALID_TYPE``
  SGL Descriptor Type Invalid: The type of
  an SGL Descriptor is a type that is not
  supported by the controller.

``NVME_SC_CMB_INVALID_USE``
  Invalid Use of Controller Memory Buffer:
  The attempted use of the Controller
  Memory Buffer is not supported by the
  controller.

``NVME_SC_PRP_INVALID_OFFSET``
  PRP Offset Invalid: The Offset field for
  a PRP entry is invalid.

``NVME_SC_AWU_EXCEEDED``
  Atomic Write Unit Exceeded: The length
  specified exceeds the atomic write unit size.

``NVME_SC_OP_DENIED``
  Operation Denied: The command was denied
  due to lack of access rights. Refer to
  the appropriate security specification.

``NVME_SC_SGL_INVALID_OFFSET``
  SGL Offset Invalid: The offset specified
  in a descriptor is invalid. This may
  occur when using capsules for data
  transfers in NVMe over Fabrics
  implementations and an invalid offset in
  the capsule is specified.

``NVME_SC_HOSTID_FORMAT``
  Host Identifier Inconsistent Format: The
  NVM subsystem detected the simultaneous
  use of 64- bit and 128-bit Host
  Identifier values on different
  controllers.

``NVME_SC_KAT_EXPIRED``
  Keep Alive Timer Expired: The Keep Alive
  Timer expired.

``NVME_SC_KAT_INVALID``
  Keep Alive Timeout Invalid: The Keep
  Alive Timeout value specified is invalid.

``NVME_SC_CMD_ABORTED_PREMEPT``
  Command Aborted due to Preempt and Abort:
  The command was aborted due to a
  Reservation Acquire command.

``NVME_SC_SANITIZE_FAILED``
  Sanitize Failed: The most recent sanitize
  operation failed and no recovery action
  has been successfully completed.

``NVME_SC_SANITIZE_IN_PROGRESS``
  Sanitize In Progress: The requested
  function (e.g., command) is prohibited
  while a sanitize operation is in
  progress.

``NVME_SC_SGL_INVALID_GRANULARITY``
  SGL Data Block Granularity Invalid: The
  Address alignment or Length granularity
  for an SGL Data Block descriptor is
  invalid.

``NVME_SC_CMD_IN_CMBQ_NOT_SUPP``
  Command Not Supported for Queue in CMB:
  The implementation does not support
  submission of the command to a Submission
  Queue in the Controller Memory Buffer or
  command completion to a Completion Queue
  in the Controller Memory Buffer.

``NVME_SC_NS_WRITE_PROTECTED``
  Namespace is Write Protected: The command
  is prohibited while the namespace is
  write protected as a result of a change
  in the namespace write protection state
  as defined by the Namespace Write
  Protection State Machine.

``NVME_SC_CMD_INTERRUPTED``
  Command Interrupted: Command processing
  was interrupted and the controller is
  unable to successfully complete the
  command. The host should retry the
  command.

``NVME_SC_TRAN_TPORT_ERROR``
  Transient Transport Error: A transient
  transport error was detected. If the
  command is retried on the same
  controller, the command is likely to
  succeed. A command that fails with a
  transient transport error four or more
  times should be treated as a persistent
  transport error that is not likely to
  succeed if retried on the same
  controller.

``NVME_SC_PROHIBITED_BY_CMD_AND_FEAT``
  Command Prohibited by Command and Feature
  Lockdown: The command was aborted due to
  command execution being prohibited by
  the Command and Feature Lockdown.

``NVME_SC_ADMIN_CMD_MEDIA_NOT_READY``
  Admin Command Media Not Ready: The Admin
  command requires access to media and
  the media is not ready.

``NVME_SC_LBA_RANGE``
  LBA Out of Range: The command references
  an LBA that exceeds the size of the namespace.

``NVME_SC_CAP_EXCEEDED``
  Capacity Exceeded: Execution of the
  command has caused the capacity of the
  namespace to be exceeded.

``NVME_SC_NS_NOT_READY``
  Namespace Not Ready: The namespace is not
  ready to be accessed as a result of a
  condition other than a condition that is
  reported as an Asymmetric Namespace
  Access condition.

``NVME_SC_RESERVATION_CONFLICT``
  Reservation Conflict: The command was
  aborted due to a conflict with a
  reservation held on the accessed
  namespace.

``NVME_SC_FORMAT_IN_PROGRESS``
  Format In Progress: A Format NVM command
  is in progress on the namespace.

``NVME_SC_CQ_INVALID``
  Completion Queue Invalid: The Completion
  Queue identifier specified in the command
  does not exist.

``NVME_SC_QID_INVALID``
  Invalid Queue Identifier: The creation of
  the I/O Completion Queue failed due to an
  invalid queue identifier specified as
  part of the command. An invalid queue
  identifier is one that is currently in
  use or one that is outside the range
  supported by the controller.

``NVME_SC_QUEUE_SIZE``
  Invalid Queue Size: The host attempted to
  create an I/O Completion Queue with an
  invalid number of entries.

``NVME_SC_ABORT_LIMIT``
  Abort Command Limit Exceeded: The number
  of concurrently outstanding Abort commands
  has exceeded the limit indicated in the
  Identify Controller data structure.

``NVME_SC_ABORT_MISSING``
  Abort Command is missing: The abort
  command is missing.

``NVME_SC_ASYNC_LIMIT``
  Asynchronous Event Request Limit
  Exceeded: The number of concurrently
  outstanding Asynchronous Event Request
  commands has been exceeded.

``NVME_SC_FIRMWARE_SLOT``
  Invalid Firmware Slot: The firmware slot
  indicated is invalid or read only. This
  error is indicated if the firmware slot
  exceeds the number supported.

``NVME_SC_FIRMWARE_IMAGE``
  Invalid Firmware Image: The firmware
  image specified for activation is invalid
  and not loaded by the controller.

``NVME_SC_INVALID_VECTOR``
  Invalid Interrupt Vector: The creation of
  the I/O Completion Queue failed due to an
  invalid interrupt vector specified as
  part of the command.

``NVME_SC_INVALID_LOG_PAGE``
  Invalid Log Page: The log page indicated
  is invalid. This error condition is also
  returned if a reserved log page is
  requested.

``NVME_SC_INVALID_FORMAT``
  Invalid Format: The LBA Format specified
  is not supported.

``NVME_SC_FW_NEEDS_CONV_RESET``
  Firmware Activation Requires Conventional Reset:
  The firmware commit was successful,
  however, activation of the firmware image
  requires a conventional reset.

``NVME_SC_INVALID_QUEUE``
  Invalid Queue Deletion: Invalid I/O
  Completion Queue specified to delete.

``NVME_SC_FEATURE_NOT_SAVEABLE``
  Feature Identifier Not Saveable: The
  Feature Identifier specified does not
  support a saveable value.

``NVME_SC_FEATURE_NOT_CHANGEABLE``
  Feature Not Changeable: The Feature
  Identifier is not able to be changed.

``NVME_SC_FEATURE_NOT_PER_NS``
  Feature Not Namespace Specific: The
  Feature Identifier specified is not
  namespace specific. The Feature
  Identifier settings apply across all
  namespaces.

``NVME_SC_FW_NEEDS_SUBSYS_RESET``
  Firmware Activation Requires NVM
  Subsystem Reset: The firmware commit was
  successful, however, activation of the
  firmware image requires an NVM Subsystem.

``NVME_SC_FW_NEEDS_RESET``
  Firmware Activation Requires Controller
  Level Reset: The firmware commit was
  successful; however, the image specified
  does not support being activated without
  a reset.

``NVME_SC_FW_NEEDS_MAX_TIME``
  Firmware Activation Requires Maximum Time
  Violation: The image specified if
  activated immediately would exceed the
  Maximum Time for Firmware Activation
  (MTFA) value reported in Identify
  Controller.

``NVME_SC_FW_ACTIVATE_PROHIBITED``
  Firmware Activation Prohibited: The image
  specified is being prohibited from
  activation by the controller for vendor
  specific reasons.

``NVME_SC_OVERLAPPING_RANGE``
  Overlapping Range: The downloaded
  firmware image has overlapping ranges.

``NVME_SC_NS_INSUFFICIENT_CAP``
  Namespace Insufficient Capacity: Creating
  the namespace requires more free space
  than is currently available.

``NVME_SC_NS_ID_UNAVAILABLE``
  Namespace Identifier Unavailable: The
  number of namespaces supported has been
  exceeded.

``NVME_SC_NS_ALREADY_ATTACHED``
  Namespace Already Attached: The
  controller is already attached to the
  namespace specified.

``NVME_SC_NS_IS_PRIVATE``
  Namespace Is Private: The namespace is
  private and is already attached to one
  controller.

``NVME_SC_NS_NOT_ATTACHED``
  Namespace Not Attached: The request to
  detach the controller could not be
  completed because the controller is not
  attached to the namespace.

``NVME_SC_THIN_PROV_NOT_SUPP``
  Thin Provisioning Not Supported: Thin
  provisioning is not supported by the
  controller.

``NVME_SC_CTRL_LIST_INVALID``
  Controller List Invalid: The controller
  list provided contains invalid controller
  ids.

``NVME_SC_SELF_TEST_IN_PROGRESS``
  Device Self-test In Progress: The controller
  or NVM subsystem already has a device
  self-test operation in process.

``NVME_SC_BP_WRITE_PROHIBITED``
  Boot Partition Write Prohibited: The
  command is trying to modify a locked Boot
  Partition.

``NVME_SC_INVALID_CTRL_ID``
  Invalid Controller Identifier:

``NVME_SC_INVALID_SEC_CTRL_STATE``
  Invalid Secondary Controller State

``NVME_SC_INVALID_CTRL_RESOURCES``
  Invalid Number of Controller Resources

``NVME_SC_INVALID_RESOURCE_ID``
  Invalid Resource Identifier

``NVME_SC_PMR_SAN_PROHIBITED``
  Sanitize Prohibited While Persistent
  Memory Region is Enabled

``NVME_SC_ANA_GROUP_ID_INVALID``
  ANA Group Identifier Invalid: The specified
  ANA Group Identifier (ANAGRPID) is not
  supported in the submitted command.

``NVME_SC_ANA_ATTACH_FAILED``
  ANA Attach Failed: The controller is not
  attached to the namespace as a result
  of an ANA condition.

``NVME_SC_INSUFFICIENT_CAP``
  Insufficient Capacity: Requested operation
  requires more free space than is currently
  available.

``NVME_SC_NS_ATTACHMENT_LIMIT_EXCEEDED``
  Namespace Attachment Limit Exceeded:
  Attaching the ns to a controller causes
  max number of ns attachments allowed
  to be exceeded.

``NVME_SC_PROHIBIT_CMD_EXEC_NOT_SUPPORTED``
  Prohibition of Command Execution
  Not Supported

``NVME_SC_IOCS_NOT_SUPPORTED``
  I/O Command Set Not Supported

``NVME_SC_IOCS_NOT_ENABLED``
  I/O Command Set Not Enabled

``NVME_SC_IOCS_COMBINATION_REJECTED``
  I/O Command Set Combination Rejected

``NVME_SC_INVALID_IOCS``
  Invalid I/O Command Set

``NVME_SC_ID_UNAVAILABLE``
  Identifier Unavailable

``NVME_SC_BAD_ATTRIBUTES``
  Conflicting Dataset Management Attributes

``NVME_SC_INVALID_PI``
  Invalid Protection Information

``NVME_SC_READ_ONLY``
  Attempted Write to Read Only Range

``NVME_SC_CMD_SIZE_LIMIT_EXCEEDED``
  Command Size Limit Exceeded

``NVME_SC_CONNECT_FORMAT``
  Incompatible Format: The NVM subsystem
  does not support the record format
  specified by the host.

``NVME_SC_CONNECT_CTRL_BUSY``
  Controller Busy: The controller is
  already associated with a host.

``NVME_SC_CONNECT_INVALID_PARAM``
  Connect Invalid Parameters: One or more
  of the command parameters.

``NVME_SC_CONNECT_RESTART_DISC``
  Connect Restart Discovery: The NVM
  subsystem requested is not available.

``NVME_SC_CONNECT_INVALID_HOST``
  Connect Invalid Host: The host is either
  not allowed to establish an association
  to any controller in the NVM subsystem or
  the host is not allowed to establish an
  association to the specified controller

``NVME_SC_DISCONNECT_INVALID_QTYPE``
  Invalid Queue Type: The command was sent
  on the wrong queue type.

``NVME_SC_DISCOVERY_RESTART``
  Discover Restart: The snapshot of the
  records is now invalid or out of date.

``NVME_SC_AUTH_REQUIRED``
  Authentication Required: NVMe in-band
  authentication is required and the queue
  has not yet been authenticated.

``NVME_SC_ZNS_INVALID_OP_REQUEST``
  Invalid Zone Operation Request:
  The operation requested is invalid. This may be due to
  various conditions, including: attempting to allocate a
  ZRWA when a zone is not in the ZSE:Empty state; or
  invalid Flush Explicit ZRWA Range Send Zone Action
  operation.

``NVME_SC_ZNS_ZRWA_RESOURCES_UNAVAILABLE``
  ZRWA Resources Unavailable:
  No ZRWAs are available.

``NVME_SC_ZNS_BOUNDARY_ERROR``
  Zone Boundary Error: The command specifies
  logical blocks in more than one zone.

``NVME_SC_ZNS_FULL``
  Zone Is Full: The accessed zone is in the
  ZSF:Full state.

``NVME_SC_ZNS_READ_ONLY``
  Zone Is Read Only: The accessed zone is
  in the ZSRO:Read Only state.

``NVME_SC_ZNS_OFFLINE``
  Zone Is Offline: The accessed zone is
  in the ZSO:Offline state.

``NVME_SC_ZNS_INVALID_WRITE``
  Zone Invalid Write: The write to a zone
  was not at the write pointer.

``NVME_SC_ZNS_TOO_MANY_ACTIVE``
  Too Many Active Zones: The controller
  does not allow additional active zones.

``NVME_SC_ZNS_TOO_MANY_OPENS``
  Too Many Open Zones: The controller does
  not allow additional open zones.

``NVME_SC_ZNS_INVAL_TRANSITION``
  Invalid Zone State Transition: The request
  is not a valid zone state transition.

``NVME_SC_WRITE_FAULT``
  Write Fault: The write data could not be
  committed to the media.

``NVME_SC_READ_ERROR``
  Unrecovered Read Error: The read data
  could not be recovered from the media.

``NVME_SC_GUARD_CHECK``
  End-to-end Guard Check Error: The command
  was aborted due to an end-to-end guard
  check failure.

``NVME_SC_APPTAG_CHECK``
  End-to-end Application Tag Check Error:
  The command was aborted due to an
  end-to-end application tag check failure.

``NVME_SC_REFTAG_CHECK``
  End-to-end Reference Tag Check Error: The
  command was aborted due to an end-to-end
  reference tag check failure.

``NVME_SC_COMPARE_FAILED``
  Compare Failure: The command failed due
  to a miscompare during a Compare command.

``NVME_SC_ACCESS_DENIED``
  Access Denied: Access to the namespace
  and/or LBA range is denied due to lack of
  access rights.

``NVME_SC_UNWRITTEN_BLOCK``
  Deallocated or Unwritten Logical Block:
  The command failed due to an attempt to
  read from or verify an LBA range
  containing a deallocated or unwritten
  logical block.

``NVME_SC_STORAGE_TAG_CHECK``
  End-to-End Storage Tag Check Error: The
  command was aborted due to an end-to-end
  storage tag check failure.

``NVME_SC_ANA_INTERNAL_PATH_ERROR``
  Internal Path Error: The command was not
  completed as the result of a controller
  internal error that is specific to the
  controller processing the command.

``NVME_SC_ANA_PERSISTENT_LOSS``
  Asymmetric Access Persistent Loss: The
  requested function (e.g., command) is not
  able to be performed as a result of the
  relationship between the controller and
  the namespace being in the ANA Persistent
  Loss state.

``NVME_SC_ANA_INACCESSIBLE``
  Asymmetric Access Inaccessible: The
  requested function (e.g., command) is not
  able to be performed as a result of the
  relationship between the controller and
  the namespace being in the ANA
  Inaccessible state.

``NVME_SC_ANA_TRANSITION``
  Asymmetric Access Transition: The
  requested function (e.g., command) is not
  able to be performed as a result of the
  relationship between the controller and
  the namespace transitioning between
  Asymmetric Namespace Access states.

``NVME_SC_CTRL_PATH_ERROR``
  Controller Pathing Error: A pathing error
  was detected by the controller.

``NVME_SC_HOST_PATH_ERROR``
  Host Pathing Error: A pathing error was
  detected by the host.

``NVME_SC_CMD_ABORTED_BY_HOST``
  Command Aborted By Host: The command was
  aborted as a result of host action.

``NVME_SC_CRD``
  Mask to get value of Command Retry Delay
  index

``NVME_SC_MORE``
  More bit. If set, more status information
  for this command as part of the Error
  Information log that may be retrieved with
  the Get Log Page command.

``NVME_SC_DNR``
  Do Not Retry bit. If set, if the same
  command is re-submitted to any controller
  in the NVM subsystem, then that
  re-submitted command is expected to fail.


.. c:function:: __u16 nvme_status_code_type (__u16 status_field)

   Returns the NVMe Status Code Type

**Parameters**

``__u16 status_field``
  The NVMe Completion Queue Entry's Status Field

**Description**

See :c:type:`enum nvme_status_field <nvme_status_field>`


.. c:function:: __u16 nvme_status_code (__u16 status_field)

   Returns the NVMe Status Code

**Parameters**

``__u16 status_field``
  The NVMe Completion Queue Entry's Status Field

**Description**

See :c:type:`enum nvme_status_field <nvme_status_field>`




.. c:enum:: nvme_admin_opcode

   Known NVMe admin opcodes

**Constants**

``nvme_admin_delete_sq``

``nvme_admin_create_sq``

``nvme_admin_get_log_page``

``nvme_admin_delete_cq``

``nvme_admin_create_cq``

``nvme_admin_identify``

``nvme_admin_abort_cmd``

``nvme_admin_set_features``

``nvme_admin_get_features``

``nvme_admin_async_event``

``nvme_admin_ns_mgmt``

``nvme_admin_fw_commit``

``nvme_admin_fw_activate``

``nvme_admin_fw_download``

``nvme_admin_dev_self_test``

``nvme_admin_ns_attach``

``nvme_admin_keep_alive``

``nvme_admin_directive_send``

``nvme_admin_directive_recv``

``nvme_admin_virtual_mgmt``

``nvme_admin_nvme_mi_send``

``nvme_admin_nvme_mi_recv``

``nvme_admin_capacity_mgmt``

``nvme_admin_lockdown``

``nvme_admin_dbbuf``

``nvme_admin_fabrics``

``nvme_admin_format_nvm``

``nvme_admin_security_send``

``nvme_admin_security_recv``

``nvme_admin_sanitize_nvm``

``nvme_admin_get_lba_status``




.. c:enum:: nvme_identify_cns


**Constants**

``NVME_IDENTIFY_CNS_NS``

``NVME_IDENTIFY_CNS_CTRL``

``NVME_IDENTIFY_CNS_NS_ACTIVE_LIST``

``NVME_IDENTIFY_CNS_NS_DESC_LIST``

``NVME_IDENTIFY_CNS_NVMSET_LIST``

``NVME_IDENTIFY_CNS_CSI_NS``

``NVME_IDENTIFY_CNS_CSI_CTRL``

``NVME_IDENTIFY_CNS_CSI_NS_ACTIVE_LIST``

``NVME_IDENTIFY_CNS_CSI_INDEPENDENT_ID_NS``

``NVME_IDENTIFY_CNS_NS_USER_DATA_FORMAT``
  *undescribed*

``NVME_IDENTIFY_CNS_CSI_NS_USER_DATA_FORMAT``
  *undescribed*

``NVME_IDENTIFY_CNS_ALLOCATED_NS_LIST``

``NVME_IDENTIFY_CNS_ALLOCATED_NS``

``NVME_IDENTIFY_CNS_NS_CTRL_LIST``

``NVME_IDENTIFY_CNS_CTRL_LIST``

``NVME_IDENTIFY_CNS_PRIMARY_CTRL_CAP``

``NVME_IDENTIFY_CNS_SECONDARY_CTRL_LIST``

``NVME_IDENTIFY_CNS_NS_GRANULARITY``

``NVME_IDENTIFY_CNS_UUID_LIST``

``NVME_IDENTIFY_CNS_DOMAIN_LIST``

``NVME_IDENTIFY_CNS_ENDURANCE_GROUP_ID``

``NVME_IDENTIFY_CNS_CSS_ALLOCATED_NS_LIST``

``NVME_IDENTIFY_CNS_COMMAND_SET_STRUCTURE``
  Base Specification 2.0a section 5.17.2.21




.. c:enum:: nvme_cmd_get_log_lid


**Constants**

``NVME_LOG_LID_SUPPORTED_LOG_PAGES``

``NVME_LOG_LID_ERROR``

``NVME_LOG_LID_SMART``

``NVME_LOG_LID_FW_SLOT``

``NVME_LOG_LID_CHANGED_NS``

``NVME_LOG_LID_CMD_EFFECTS``

``NVME_LOG_LID_DEVICE_SELF_TEST``

``NVME_LOG_LID_TELEMETRY_HOST``

``NVME_LOG_LID_TELEMETRY_CTRL``

``NVME_LOG_LID_ENDURANCE_GROUP``

``NVME_LOG_LID_PREDICTABLE_LAT_NVMSET``

``NVME_LOG_LID_PREDICTABLE_LAT_AGG``

``NVME_LOG_LID_ANA``

``NVME_LOG_LID_PERSISTENT_EVENT``

``NVME_LOG_LID_LBA_STATUS``

``NVME_LOG_LID_ENDURANCE_GRP_EVT``

``NVME_LOG_LID_MEDIA_UNIT_STATUS``

``NVME_LOG_LID_SUPPORTED_CAP_CONFIG_LIST``

``NVME_LOG_LID_FID_SUPPORTED_EFFECTS``

``NVME_LOG_LID_BOOT_PARTITION``

``NVME_LOG_LID_DISCOVER``

``NVME_LOG_LID_RESERVATION``

``NVME_LOG_LID_SANITIZE``

``NVME_LOG_LID_ZNS_CHANGED_ZONES``




.. c:enum:: nvme_features_id


**Constants**

``NVME_FEAT_FID_ARBITRATION``

``NVME_FEAT_FID_POWER_MGMT``

``NVME_FEAT_FID_LBA_RANGE``

``NVME_FEAT_FID_TEMP_THRESH``

``NVME_FEAT_FID_ERR_RECOVERY``

``NVME_FEAT_FID_VOLATILE_WC``

``NVME_FEAT_FID_NUM_QUEUES``

``NVME_FEAT_FID_IRQ_COALESCE``

``NVME_FEAT_FID_IRQ_CONFIG``

``NVME_FEAT_FID_WRITE_ATOMIC``

``NVME_FEAT_FID_ASYNC_EVENT``

``NVME_FEAT_FID_AUTO_PST``

``NVME_FEAT_FID_HOST_MEM_BUF``

``NVME_FEAT_FID_TIMESTAMP``

``NVME_FEAT_FID_KATO``

``NVME_FEAT_FID_HCTM``

``NVME_FEAT_FID_NOPSC``

``NVME_FEAT_FID_RRL``

``NVME_FEAT_FID_PLM_CONFIG``

``NVME_FEAT_FID_PLM_WINDOW``

``NVME_FEAT_FID_LBA_STS_INTERVAL``

``NVME_FEAT_FID_HOST_BEHAVIOR``

``NVME_FEAT_FID_SANITIZE``

``NVME_FEAT_FID_ENDURANCE_EVT_CFG``

``NVME_FEAT_FID_IOCS_PROFILE``

``NVME_FEAT_FID_SPINUP_CONTROL``

``NVME_FEAT_FID_ENH_CTRL_METADATA``
  Enhanced Controller Metadata

``NVME_FEAT_FID_CTRL_METADATA``
  Controller Metadata

``NVME_FEAT_FID_NS_METADATA``
  Namespace Metadata

``NVME_FEAT_FID_SW_PROGRESS``

``NVME_FEAT_FID_HOST_ID``

``NVME_FEAT_FID_RESV_MASK``

``NVME_FEAT_FID_RESV_PERSIST``

``NVME_FEAT_FID_WRITE_PROTECT``




.. c:enum:: nvme_feat


**Constants**

``NVME_FEAT_ARBITRATION_BURST_SHIFT``

``NVME_FEAT_ARBITRATION_BURST_MASK``

``NVME_FEAT_ARBITRATION_LPW_SHIFT``

``NVME_FEAT_ARBITRATION_LPW_MASK``

``NVME_FEAT_ARBITRATION_MPW_SHIFT``

``NVME_FEAT_ARBITRATION_MPW_MASK``

``NVME_FEAT_ARBITRATION_HPW_SHIFT``

``NVME_FEAT_ARBITRATION_HPW_MASK``

``NVME_FEAT_PWRMGMT_PS_SHIFT``

``NVME_FEAT_PWRMGMT_PS_MASK``

``NVME_FEAT_PWRMGMT_WH_SHIFT``

``NVME_FEAT_PWRMGMT_WH_MASK``

``NVME_FEAT_LBAR_NR_SHIFT``

``NVME_FEAT_LBAR_NR_MASK``

``NVME_FEAT_TT_TMPTH_SHIFT``

``NVME_FEAT_TT_TMPTH_MASK``

``NVME_FEAT_TT_TMPSEL_SHIFT``

``NVME_FEAT_TT_TMPSEL_MASK``

``NVME_FEAT_TT_THSEL_SHIFT``

``NVME_FEAT_TT_THSEL_MASK``

``NVME_FEAT_ERROR_RECOVERY_TLER_SHIFT``

``NVME_FEAT_ERROR_RECOVERY_TLER_MASK``

``NVME_FEAT_ERROR_RECOVERY_DULBE_SHIFT``

``NVME_FEAT_ERROR_RECOVERY_DULBE_MASK``

``NVME_FEAT_VWC_WCE_SHIFT``

``NVME_FEAT_VWC_WCE_MASK``

``NVME_FEAT_NRQS_NSQR_SHIFT``

``NVME_FEAT_NRQS_NSQR_MASK``

``NVME_FEAT_NRQS_NCQR_SHIFT``

``NVME_FEAT_NRQS_NCQR_MASK``

``NVME_FEAT_IRQC_THR_SHIFT``

``NVME_FEAT_IRQC_THR_MASK``

``NVME_FEAT_IRQC_TIME_SHIFT``

``NVME_FEAT_IRQC_TIME_MASK``

``NVME_FEAT_ICFG_IV_SHIFT``

``NVME_FEAT_ICFG_IV_MASK``

``NVME_FEAT_ICFG_CD_SHIFT``

``NVME_FEAT_ICFG_CD_MASK``

``NVME_FEAT_WA_DN_SHIFT``

``NVME_FEAT_WA_DN_MASK``

``NVME_FEAT_AE_SMART_SHIFT``

``NVME_FEAT_AE_SMART_MASK``

``NVME_FEAT_AE_NAN_SHIFT``

``NVME_FEAT_AE_NAN_MASK``

``NVME_FEAT_AE_FW_SHIFT``

``NVME_FEAT_AE_FW_MASK``

``NVME_FEAT_AE_TELEM_SHIFT``

``NVME_FEAT_AE_TELEM_MASK``

``NVME_FEAT_AE_ANA_SHIFT``

``NVME_FEAT_AE_ANA_MASK``

``NVME_FEAT_AE_PLA_SHIFT``

``NVME_FEAT_AE_PLA_MASK``

``NVME_FEAT_AE_LBAS_SHIFT``

``NVME_FEAT_AE_LBAS_MASK``

``NVME_FEAT_AE_EGA_SHIFT``

``NVME_FEAT_AE_EGA_MASK``

``NVME_FEAT_APST_APSTE_SHIFT``

``NVME_FEAT_APST_APSTE_MASK``

``NVME_FEAT_HMEM_EHM_SHIFT``

``NVME_FEAT_HMEM_EHM_MASK``

``NVME_FEAT_HCTM_TMT2_SHIFT``

``NVME_FEAT_HCTM_TMT2_MASK``

``NVME_FEAT_HCTM_TMT1_SHIFT``

``NVME_FEAT_HCTM_TMT1_MASK``

``NVME_FEAT_NOPS_NOPPME_SHIFT``

``NVME_FEAT_NOPS_NOPPME_MASK``

``NVME_FEAT_RRL_RRL_SHIFT``

``NVME_FEAT_RRL_RRL_MASK``

``NVME_FEAT_PLM_PLME_SHIFT``

``NVME_FEAT_PLM_PLME_MASK``

``NVME_FEAT_PLMW_WS_SHIFT``

``NVME_FEAT_PLMW_WS_MASK``

``NVME_FEAT_LBAS_LSIRI_SHIFT``

``NVME_FEAT_LBAS_LSIRI_MASK``

``NVME_FEAT_LBAS_LSIPI_SHIFT``

``NVME_FEAT_LBAS_LSIPI_MASK``

``NVME_FEAT_SC_NODRM_SHIFT``

``NVME_FEAT_SC_NODRM_MASK``

``NVME_FEAT_EG_ENDGID_SHIFT``

``NVME_FEAT_EG_ENDGID_MASK``

``NVME_FEAT_EG_EGCW_SHIFT``

``NVME_FEAT_EG_EGCW_MASK``

``NVME_FEAT_SPM_PBSLC_SHIFT``

``NVME_FEAT_SPM_PBSLC_MASK``

``NVME_FEAT_HOSTID_EXHID_SHIFT``

``NVME_FEAT_HOSTID_EXHID_MASK``

``NVME_FEAT_RM_REGPRE_SHIFT``

``NVME_FEAT_RM_REGPRE_MASK``

``NVME_FEAT_RM_RESREL_SHIFT``

``NVME_FEAT_RM_RESREL_MASK``

``NVME_FEAT_RM_RESPRE_SHIFT``

``NVME_FEAT_RM_RESPRE_MASK``

``NVME_FEAT_RP_PTPL_SHIFT``

``NVME_FEAT_RP_PTPL_MASK``

``NVME_FEAT_WP_WPS_SHIFT``

``NVME_FEAT_WP_WPS_MASK``

``NVME_FEAT_IOCSP_IOCSCI_SHIFT``

``NVME_FEAT_IOCSP_IOCSCI_MASK``




.. c:enum:: nvme_get_features_sel


**Constants**

``NVME_GET_FEATURES_SEL_CURRENT``

``NVME_GET_FEATURES_SEL_DEFAULT``

``NVME_GET_FEATURES_SEL_SAVED``

``NVME_GET_FEATURES_SEL_SUPPORTED``




.. c:enum:: nvme_cmd_format_mset

   Format NVM - Metadata Settings

**Constants**

``NVME_FORMAT_MSET_SEPARATE``
  indicates that the metadata is transferred
  as part of a separate buffer.

``NVME_FORMAT_MSET_EXTENDED``
  indicates that the metadata is transferred
  as part of an extended data LBA.




.. c:enum:: nvme_cmd_format_pi

   Format NVM - Protection Information

**Constants**

``NVME_FORMAT_PI_DISABLE``
  Protection information is not enabled.

``NVME_FORMAT_PI_TYPE1``
  Protection information is enabled, Type 1.

``NVME_FORMAT_PI_TYPE2``
  Protection information is enabled, Type 2.

``NVME_FORMAT_PI_TYPE3``
  Protection information is enabled, Type 3.




.. c:enum:: nvme_cmd_format_pil

   Format NVM - Protection Information Location

**Constants**

``NVME_FORMAT_PIL_LAST``
  Protection information is transferred as the last
  bytes of metadata.

``NVME_FORMAT_PIL_FIRST``
  Protection information is transferred as the first
  bytes of metadata.




.. c:enum:: nvme_cmd_format_ses

   Format NVM - Secure Erase Settings

**Constants**

``NVME_FORMAT_SES_NONE``
  No secure erase operation requested.

``NVME_FORMAT_SES_USER_DATA_ERASE``
  User Data Erase: All user data shall be erased,
  contents of the user data after the erase is
  indeterminate (e.g. the user data may be zero
  filled, one filled, etc.). If a User Data Erase
  is requested and all affected user data is
  encrypted, then the controller is allowed
  to use a cryptographic erase to perform
  the requested User Data Erase.

``NVME_FORMAT_SES_CRYPTO_ERASE``
  Cryptographic Erase: All user data shall
  be erased cryptographically. This is
  accomplished by deleting the encryption key.




.. c:enum:: nvme_ns_mgmt_sel


**Constants**

``NVME_NS_MGMT_SEL_CREATE``

``NVME_NS_MGMT_SEL_DELETE``




.. c:enum:: nvme_ns_attach_sel


**Constants**

``NVME_NS_ATTACH_SEL_CTRL_ATTACH``

``NVME_NS_ATTACH_SEL_CTRL_DEATTACH``




.. c:enum:: nvme_fw_commit_ca


**Constants**

``NVME_FW_COMMIT_CA_REPLACE``

``NVME_FW_COMMIT_CA_REPLACE_AND_ACTIVATE``

``NVME_FW_COMMIT_CA_SET_ACTIVE``

``NVME_FW_COMMIT_CA_REPLACE_AND_ACTIVATE_IMMEDIATE``

``NVME_FW_COMMIT_CA_REPLACE_BOOT_PARTITION``

``NVME_FW_COMMIT_CA_ACTIVATE_BOOT_PARTITION``




.. c:enum:: nvme_directive_dtype


**Constants**

``NVME_DIRECTIVE_DTYPE_IDENTIFY``

``NVME_DIRECTIVE_DTYPE_STREAMS``




.. c:enum:: nvme_directive_receive_doper


**Constants**

``NVME_DIRECTIVE_RECEIVE_IDENTIFY_DOPER_PARAM``

``NVME_DIRECTIVE_RECEIVE_STREAMS_DOPER_PARAM``

``NVME_DIRECTIVE_RECEIVE_STREAMS_DOPER_STATUS``

``NVME_DIRECTIVE_RECEIVE_STREAMS_DOPER_RESOURCE``




.. c:enum:: nvme_directive_send_doper


**Constants**

``NVME_DIRECTIVE_SEND_IDENTIFY_DOPER_ENDIR``

``NVME_DIRECTIVE_SEND_STREAMS_DOPER_RELEASE_IDENTIFIER``

``NVME_DIRECTIVE_SEND_STREAMS_DOPER_RELEASE_RESOURCE``




.. c:enum:: nvme_directive_send_identify_endir


**Constants**

``NVME_DIRECTIVE_SEND_IDENTIFY_ENDIR_DISABLE``

``NVME_DIRECTIVE_SEND_IDENTIFY_ENDIR_ENABLE``




.. c:enum:: nvme_sanitize_sanact

   Sanitize Action

**Constants**

``NVME_SANITIZE_SANACT_EXIT_FAILURE``
  Exit Failure Mode.

``NVME_SANITIZE_SANACT_START_BLOCK_ERASE``
  Start a Block Erase sanitize operation.

``NVME_SANITIZE_SANACT_START_OVERWRITE``
  Start an Overwrite sanitize operation.

``NVME_SANITIZE_SANACT_START_CRYPTO_ERASE``
  Start a Crypto Erase sanitize operation.




.. c:enum:: nvme_dst_stc

   Action taken by the Device Self-test command

**Constants**

``NVME_DST_STC_SHORT``
  Start a short device self-test operation

``NVME_DST_STC_LONG``
  Start an extended device self-test operation

``NVME_DST_STC_VS``
  Start a vendor specific device self-test operation

``NVME_DST_STC_ABORT``
  Abort device self-test operation




.. c:enum:: nvme_virt_mgmt_act


**Constants**

``NVME_VIRT_MGMT_ACT_PRIM_CTRL_FLEX_ALLOC``

``NVME_VIRT_MGMT_ACT_OFFLINE_SEC_CTRL``

``NVME_VIRT_MGMT_ACT_ASSIGN_SEC_CTRL``

``NVME_VIRT_MGMT_ACT_ONLINE_SEC_CTRL``




.. c:enum:: nvme_virt_mgmt_rt


**Constants**

``NVME_VIRT_MGMT_RT_VQ_RESOURCE``

``NVME_VIRT_MGMT_RT_VI_RESOURCE``




.. c:enum:: nvme_ns_write_protect_cfg


**Constants**

``NVME_NS_WP_CFG_NONE``

``NVME_NS_WP_CFG_PROTECT``

``NVME_NS_WP_CFG_PROTECT_POWER_CYCLE``

``NVME_NS_WP_CFG_PROTECT_PERMANENT``




.. c:enum:: nvme_log_ana_lsp


**Constants**

``NVME_LOG_ANA_LSP_RGO_NAMESPACES``

``NVME_LOG_ANA_LSP_RGO_GROUPS_ONLY``




.. c:enum:: nvme_pevent_log_action


**Constants**

``NVME_PEVENT_LOG_READ``

``NVME_PEVENT_LOG_EST_CTX_AND_READ``

``NVME_PEVENT_LOG_RELEASE_CTX``




.. c:enum:: nvme_feat_tmpthresh_thsel


**Constants**

``NVME_FEATURE_TEMPTHRESH_THSEL_OVER``

``NVME_FEATURE_TEMPTHRESH_THSEL_UNDER``




.. c:enum:: nvme_features_async_event_config_flags


**Constants**

``NVME_FEATURE_AENCFG_SMART_CRIT_SPARE``

``NVME_FEATURE_AENCFG_SMART_CRIT_TEMPERATURE``

``NVME_FEATURE_AENCFG_SMART_CRIT_DEGRADED``

``NVME_FEATURE_AENCFG_SMART_CRIT_READ_ONLY``

``NVME_FEATURE_AENCFG_SMART_CRIT_VOLATILE_BACKUP``

``NVME_FEATURE_AENCFG_SMART_CRIT_READ_ONLY_PMR``

``NVME_FEATURE_AENCFG_NOTICE_NAMESPACE_ATTRIBUTES``

``NVME_FEATURE_AENCFG_NOTICE_FIRMWARE_ACTIVATION``

``NVME_FEATURE_AENCFG_NOTICE_TELEMETRY_LOG``

``NVME_FEATURE_AENCFG_NOTICE_ANA_CHANGE``

``NVME_FEATURE_AENCFG_NOTICE_PL_EVENT``

``NVME_FEATURE_AENCFG_NOTICE_LBA_STATUS``

``NVME_FEATURE_AENCFG_NOTICE_EG_EVENT``

``NVME_FEATURE_AENCFG_NOTICE_DISCOVERY_CHANGE``




.. c:enum:: nvme_feat_plm_window_select


**Constants**

``NVME_FEATURE_PLM_DTWIN``

``NVME_FEATURE_PLM_NDWIN``




.. c:enum:: nvme_feat_resv_notify_flags


**Constants**

``NVME_FEAT_RESV_NOTIFY_REGPRE``

``NVME_FEAT_RESV_NOTIFY_RESREL``

``NVME_FEAT_RESV_NOTIFY_RESPRE``




.. c:enum:: nvme_feat_nswpcfg_state


**Constants**

``NVME_FEAT_NS_NO_WRITE_PROTECT``

``NVME_FEAT_NS_WRITE_PROTECT``

``NVME_FEAT_NS_WRITE_PROTECT_PWR_CYCLE``

``NVME_FEAT_NS_WRITE_PROTECT_PERMANENT``




.. c:enum:: nvme_fctype


**Constants**

``nvme_fabrics_type_property_set``

``nvme_fabrics_type_connect``

``nvme_fabrics_type_property_get``

``nvme_fabrics_type_auth_send``

``nvme_fabrics_type_auth_receive``

``nvme_fabrics_type_disconnect``




.. c:enum:: nvme_io_opcode


**Constants**

``nvme_cmd_flush``

``nvme_cmd_write``

``nvme_cmd_read``

``nvme_cmd_write_uncor``

``nvme_cmd_compare``

``nvme_cmd_write_zeroes``

``nvme_cmd_dsm``

``nvme_cmd_verify``

``nvme_cmd_resv_register``

``nvme_cmd_resv_report``

``nvme_cmd_resv_acquire``

``nvme_cmd_resv_release``

``nvme_cmd_copy``

``nvme_zns_cmd_mgmt_send``

``nvme_zns_cmd_mgmt_recv``

``nvme_zns_cmd_append``




.. c:enum:: nvme_io_control_flags


**Constants**

``NVME_IO_DTYPE_STREAMS``

``NVME_IO_DEAC``

``NVME_IO_ZNS_APPEND_PIREMAP``

``NVME_IO_PRINFO_PRCHK_REF``

``NVME_IO_PRINFO_PRCHK_APP``

``NVME_IO_PRINFO_PRCHK_GUARD``

``NVME_IO_PRINFO_PRACT``

``NVME_IO_FUA``

``NVME_IO_LR``




.. c:enum:: nvme_io_dsm_flags


**Constants**

``NVME_IO_DSM_FREQ_UNSPEC``

``NVME_IO_DSM_FREQ_TYPICAL``

``NVME_IO_DSM_FREQ_RARE``

``NVME_IO_DSM_FREQ_READS``

``NVME_IO_DSM_FREQ_WRITES``

``NVME_IO_DSM_FREQ_RW``

``NVME_IO_DSM_FREQ_ONCE``

``NVME_IO_DSM_FREQ_PREFETCH``

``NVME_IO_DSM_FREQ_TEMP``

``NVME_IO_DSM_LATENCY_NONE``

``NVME_IO_DSM_LATENCY_IDLE``

``NVME_IO_DSM_LATENCY_NORM``

``NVME_IO_DSM_LATENCY_LOW``

``NVME_IO_DSM_SEQ_REQ``

``NVME_IO_DSM_COMPRESSED``




.. c:enum:: nvme_dsm_attributes


**Constants**

``NVME_DSMGMT_IDR``

``NVME_DSMGMT_IDW``

``NVME_DSMGMT_AD``




.. c:enum:: nvme_resv_rtype


**Constants**

``NVME_RESERVATION_RTYPE_WE``

``NVME_RESERVATION_RTYPE_EA``

``NVME_RESERVATION_RTYPE_WERO``

``NVME_RESERVATION_RTYPE_EARO``

``NVME_RESERVATION_RTYPE_WEAR``

``NVME_RESERVATION_RTYPE_EAAR``




.. c:enum:: nvme_resv_racqa


**Constants**

``NVME_RESERVATION_RACQA_ACQUIRE``

``NVME_RESERVATION_RACQA_PREEMPT``

``NVME_RESERVATION_RACQA_PREEMPT_AND_ABORT``




.. c:enum:: nvme_resv_rrega


**Constants**

``NVME_RESERVATION_RREGA_REGISTER_KEY``

``NVME_RESERVATION_RREGA_UNREGISTER_KEY``

``NVME_RESERVATION_RREGA_REPLACE_KEY``




.. c:enum:: nvme_resv_cptpl


**Constants**

``NVME_RESERVATION_CPTPL_NO_CHANGE``

``NVME_RESERVATION_CPTPL_CLEAR``

``NVME_RESERVATION_CPTPL_PERSIST``




.. c:enum:: nvme_resv_rrela


**Constants**

``NVME_RESERVATION_RRELA_RELEASE``

``NVME_RESERVATION_RRELA_CLEAR``




.. c:enum:: nvme_zns_send_action


**Constants**

``NVME_ZNS_ZSA_CLOSE``

``NVME_ZNS_ZSA_FINISH``

``NVME_ZNS_ZSA_OPEN``

``NVME_ZNS_ZSA_RESET``

``NVME_ZNS_ZSA_OFFLINE``

``NVME_ZNS_ZSA_SET_DESC_EXT``

``NVME_ZNS_ZSA_ZRWA_FLUSH``




.. c:enum:: nvme_zns_recv_action


**Constants**

``NVME_ZNS_ZRA_REPORT_ZONES``

``NVME_ZNS_ZRA_EXTENDED_REPORT_ZONES``




.. c:enum:: nvme_zns_report_options


**Constants**

``NVME_ZNS_ZRAS_REPORT_ALL``

``NVME_ZNS_ZRAS_REPORT_EMPTY``

``NVME_ZNS_ZRAS_REPORT_IMPL_OPENED``

``NVME_ZNS_ZRAS_REPORT_EXPL_OPENED``

``NVME_ZNS_ZRAS_REPORT_CLOSED``

``NVME_ZNS_ZRAS_REPORT_FULL``

``NVME_ZNS_ZRAS_REPORT_READ_ONLY``

``NVME_ZNS_ZRAS_REPORT_OFFLINE``


.. _fabrics.h:

**fabrics.h**


Fabrics-specific definitions.



.. c:struct:: nvme_fabrics_config

   Defines all linux nvme fabrics initiator options

**Definition**

::

  struct nvme_fabrics_config {
    char *host_traddr;
    char *host_iface;
    int queue_size;
    int nr_io_queues;
    int reconnect_delay;
    int ctrl_loss_tmo;
    int fast_io_fail_tmo;
    int keep_alive_tmo;
    int nr_write_queues;
    int nr_poll_queues;
    int tos;
    bool duplicate_connect;
    bool disable_sqflow;
    bool hdr_digest;
    bool data_digest;
    bool tls;
  };

**Members**

``host_traddr``
  Host transport address

``host_iface``
  Host interface name

``queue_size``
  Number of IO queue entries

``nr_io_queues``
  Number of controller IO queues to establish

``reconnect_delay``
  Time between two consecutive reconnect attempts.

``ctrl_loss_tmo``
  Override the default controller reconnect attempt timeout in seconds

``fast_io_fail_tmo``
  Set the fast I/O fail timeout in seconds.

``keep_alive_tmo``
  Override the default keep-alive-timeout to this value in seconds

``nr_write_queues``
  Number of queues to use for exclusively for writing

``nr_poll_queues``
  Number of queues to reserve for polling completions

``tos``
  Type of service

``duplicate_connect``
  Allow multiple connections to the same target

``disable_sqflow``
  Disable controller sq flow control

``hdr_digest``
  Generate/verify header digest (TCP)

``data_digest``
  Generate/verify data digest (TCP)

``tls``
  Start TLS on the connection (TCP)



.. c:function:: const char * nvmf_trtype_str (__u8 trtype)

   Decode TRTYPE field

**Parameters**

``__u8 trtype``
  value to be decoded

**Description**

Decode the transport type field in the discovery
log page entry.

**Return**

decoded string


.. c:function:: const char * nvmf_adrfam_str (__u8 adrfam)

   Decode ADRFAM field

**Parameters**

``__u8 adrfam``
  value to be decoded

**Description**

Decode the address family field in the discovery
log page entry.

**Return**

decoded string


.. c:function:: const char * nvmf_subtype_str (__u8 subtype)

   Decode SUBTYPE field

**Parameters**

``__u8 subtype``
  value to be decoded

**Description**

Decode the subsystem type field in the discovery
log page entry.

**Return**

decoded string


.. c:function:: const char * nvmf_treq_str (__u8 treq)

   Decode TREQ field

**Parameters**

``__u8 treq``
  value to be decoded

**Description**

Decode the transport requirements field in the
discovery log page entry.

**Return**

decoded string


.. c:function:: const char * nvmf_eflags_str (__u16 eflags)

   Decode EFLAGS field

**Parameters**

``__u16 eflags``
  value to be decoded

**Description**

Decode the EFLAGS field in the discovery log page
entry.

**Return**

decoded string


.. c:function:: const char * nvmf_sectype_str (__u8 sectype)

   Decode SECTYPE field

**Parameters**

``__u8 sectype``
  value to be decoded

**Description**

Decode the SECTYPE field in the discovery log page
entry.

**Return**

decoded string


.. c:function:: const char * nvmf_prtype_str (__u8 prtype)

   Decode RDMA Provider type field

**Parameters**

``__u8 prtype``
  value to be decoded

**Description**

Decode the RDMA Provider type field in the discovery
log page entry.

**Return**

decoded string


.. c:function:: const char * nvmf_qptype_str (__u8 qptype)

   Decode RDMA QP Service type field

**Parameters**

``__u8 qptype``
  value to be decoded

**Description**

Decode the RDMA QP Service type field in the discovery log page
entry.

**Return**

decoded string


.. c:function:: const char * nvmf_cms_str (__u8 cms)

   Decode RDMA connection management service field

**Parameters**

``__u8 cms``
  value to be decoded

**Description**

Decode the RDMA connection management service field in the discovery
log page entry.

**Return**

decoded string


.. c:function:: void nvmf_default_config (struct nvme_fabrics_config *cfg)

   Default values for fabrics configuration

**Parameters**

``struct nvme_fabrics_config *cfg``
  config values to set

**Description**

Initializes **cfg** with default values.


.. c:function:: int nvmf_add_ctrl (nvme_host_t h, nvme_ctrl_t c, const struct nvme_fabrics_config *cfg)

   Connect a controller and update topology

**Parameters**

``nvme_host_t h``
  Host to which the controller should be attached

``nvme_ctrl_t c``
  Controller to be connected

``const struct nvme_fabrics_config *cfg``
  Default configuration for the controller

**Description**

Issues a 'connect' command to the NVMe-oF controller and inserts **c**
into the topology using **h** as parent.
**c** must be initialized and not connected to the topology.

**Return**

0 on success; on failure errno is set and -1 is returned.


.. c:function:: int nvmf_get_discovery_log (nvme_ctrl_t c, struct nvmf_discovery_log **logp, int max_retries)

   Return the discovery log page

**Parameters**

``nvme_ctrl_t c``
  Discover controller to use 

``struct nvmf_discovery_log **logp``
  Pointer to the log page to be returned

``int max_retries``
  maximum number of log page entries to be returned

**Return**

0 on success; on failure -1 is returned and errno is set


.. c:function:: char * nvmf_hostnqn_generate ()

   Generate a machine specific host nqn

**Parameters**

**Return**

An nvm namespace qualified name string based on the machine
identifier, or NULL if not successful.


.. c:function:: char * nvmf_hostnqn_from_file ()

   Reads the host nvm qualified name from the config default location in /etc/nvme/

**Parameters**

**Return**

The host nqn, or NULL if unsuccessful. If found, the caller
is responsible to free the string.


.. c:function:: char * nvmf_hostid_from_file ()

   Reads the host identifier from the config default location in /etc/nvme/.

**Parameters**

**Return**

The host identifier, or NULL if unsuccessful. If found, the caller
        is responsible to free the string.


.. c:function:: nvme_ctrl_t nvmf_connect_disc_entry (nvme_host_t h, struct nvmf_disc_log_entry *e, const struct nvme_fabrics_config *defcfg, bool *discover)

   Connect controller based on the discovery log page entry

**Parameters**

``nvme_host_t h``
  Host to which the controller should be connected

``struct nvmf_disc_log_entry *e``
  Discovery log page entry

``const struct nvme_fabrics_config *defcfg``
  Default configurationn to be used for the new controller

``bool *discover``
  Set to 'true' if the new controller is a discovery controller

**Return**

Pointer to the new controller


.. c:function:: void nvme_chomp (char *s, int l)

   Strip trailing white space

**Parameters**

``char *s``
  String to strip

``int l``
  Maximum length of string


.. _util.h:

**util.h**


libnvme utility functions



.. c:enum:: nvme_connect_err

   nvme connect error codes

**Constants**

``ENVME_CONNECT_RESOLVE``
  failed to resolve host

``ENVME_CONNECT_ADDRFAM``
  unrecognized address family

``ENVME_CONNECT_TRADDR``
  failed to get traddr

``ENVME_CONNECT_TARG``
  need a transport (-t) argument

``ENVME_CONNECT_AARG``
  need a address (-a) argument

``ENVME_CONNECT_OPEN``
  failed to open nvme-fabrics device

``ENVME_CONNECT_WRITE``
  failed to write to nvme-fabrics device

``ENVME_CONNECT_READ``
  failed to read from nvme-fabrics device

``ENVME_CONNECT_PARSE``
  failed to parse ctrl info

``ENVME_CONNECT_INVAL_TR``
  invalid transport type

``ENVME_CONNECT_LOOKUP_SUBSYS_NAME``
  failed to lookup subsystem name

``ENVME_CONNECT_LOOKUP_SUBSYS``
  failed to lookup subsystem


.. c:function:: __u8 nvme_status_to_errno (int status, bool fabrics)

   Converts nvme return status to errno

**Parameters**

``int status``
  Return status from an nvme passthrough commmand

``bool fabrics``
  Set to true if :c:type:`status` is to a fabrics target.

**Return**

An errno representing the nvme status if it is an nvme status field,
or unchanged status is < 0 since errno is already set.


.. c:function:: const char * nvme_status_to_string (int status, bool fabrics)

   Returns string describing nvme return status.

**Parameters**

``int status``
  Return status from an nvme passthrough commmand

``bool fabrics``
  Set to true if :c:type:`status` is to a fabrics target.

**Return**

String representation of the nvme status if it is an nvme status field,
or a standard errno string if status is < 0.


.. c:function:: const char * nvme_errno_to_string (int err)

   Returns string describing nvme connect failures

**Parameters**

``int err``
  Returned error code from nvme_add_ctrl()

**Return**

String representation of the nvme connect error codes


.. c:function:: void nvme_init_id_ns (struct nvme_id_ns *ns, __u64 nsze, __u64 ncap, __u8 flbas, __u8 dps, __u8 nmic, __u32 anagrpid, __u16 nvmsetid)

   Initialize an Identify Namepsace structure for creation.

**Parameters**

``struct nvme_id_ns *ns``
  Address of the Identify Namespace structure to initialize

``__u64 nsze``
  Namespace size

``__u64 ncap``
  namespace capacity

``__u8 flbas``
  formatted logical block size settings

``__u8 dps``
  Data protection settings

``__u8 nmic``
  Namespace sharing capabilities

``__u32 anagrpid``
  ANA group identifier

``__u16 nvmsetid``
  NVM Set identifer

**Description**

This is intended to be used with a namespace management "create", see
nvme_ns_mgmt_create().


.. c:function:: void nvme_init_ctrl_list (struct nvme_ctrl_list *cntlist, __u16 num_ctrls, __u16 *ctrlist)

   Initialize an nvme_ctrl_list structure from an array.

**Parameters**

``struct nvme_ctrl_list *cntlist``
  The controller list structure to initialize

``__u16 num_ctrls``
  The number of controllers in the array, :c:type:`ctrlist`.

``__u16 *ctrlist``
  An array of controller identifiers in CPU native endian.

**Description**

This is intended to be used with any command that takes a controller list
argument. See nvme_ns_attach_ctrls() and nvme_ns_detach().


.. c:function:: void nvme_init_dsm_range (struct nvme_dsm_range *dsm, __u32 *ctx_attrs, __u32 *llbas, __u64 *slbas, __u16 nr_ranges)

   Constructs a data set range structure

**Parameters**

``struct nvme_dsm_range *dsm``
  DSM range array

``__u32 *ctx_attrs``
  Array of context attributes

``__u32 *llbas``
  Array of length in logical blocks

``__u64 *slbas``
  Array of starting logical blocks

``__u16 nr_ranges``
  The size of the dsm arrays

**Description**

Each array must be the same size of size 'nr_ranges'. This is intended to be
used with constructing a payload for nvme_dsm().

**Return**

The nvme command status if a response was received or -errno
otherwise.


.. c:function:: void nvme_init_copy_range (struct nvme_copy_range *copy, __u16 *nlbs, __u64 *slbas, __u32 *eilbrts, __u32 *elbatms, __u32 *elbats, __u16 nr)

   Constructs a copy range structure

**Parameters**

``struct nvme_copy_range *copy``
  Copy range array

``__u16 *nlbs``
  Number of logical blocks

``__u64 *slbas``
  Starting LBA

``__u32 *eilbrts``
  Expected initial logical block reference tag

``__u32 *elbatms``
  Expected logical block application tag mask

``__u32 *elbats``
  Expected logical block application tag

``__u16 nr``
  Number of descriptors to construct


.. c:function:: int nvme_get_feature_length (int fid, __u32 cdw11, __u32 *len)

   Retreive the command payload length for a specific feature identifier

**Parameters**

``int fid``
  Feature identifier, see :c:type:`enum nvme_features_id <nvme_features_id>`.

``__u32 cdw11``
  The cdw11 value may affect the transfer (only known fid is
  ``NVME_FEAT_FID_HOST_ID``)

``__u32 *len``
  On success, set to this features payload length in bytes.

**Return**

0 on success, -1 with errno set to EINVAL if the function did not
recognize :c:type:`fid`.


.. c:function:: int nvme_get_directive_receive_length (enum nvme_directive_dtype dtype, enum nvme_directive_receive_doper doper, __u32 *len)


**Parameters**

``enum nvme_directive_dtype dtype``
  Directive type, see :c:type:`enum nvme_directive_dtype <nvme_directive_dtype>`

``enum nvme_directive_receive_doper doper``
  Directive receive operation, see :c:type:`enum nvme_directive_receive_doper <nvme_directive_receive_doper>`

``__u32 *len``
  On success, set to this directives payload length in bytes.

**Return**

0 on success, -1 with errno set to EINVAL if the function did not
recognize :c:type:`dtype` or :c:type:`doper`.


